#ifndef _KARIN_PREY_GLSL_SHADER_300_H
#define _KARIN_PREY_GLSL_SHADER_300_H

// screenprocess
GLSL_SHADER const char ES3_SCREENPROCESS_VERT[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"in highp vec4 attr_Vertex;\n"
"in highp vec4 attr_TexCoord;\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"\n"
"out highp vec4 var_TexCoord;\n"
"\n"
"// # texture 0 takes the texture coordinates unmodified\n"
"\n"
"void main(void)\n"
"{\n"
"    gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"\n"
"    var_TexCoord = attr_TexCoord;\n"
"}\n"
;

GLSL_SHADER const char ES3_SCREENPROCESS_FRAG[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"uniform sampler2D u_fragmentMap0;\n"
"uniform highp vec4 u_nonPowerOfTwo;\n"
"uniform highp vec4 u_fragmentParm0;\n"
"uniform highp vec4 u_fragmentParm1;\n"
"uniform highp vec4 u_fragmentParm2;\n"
"uniform highp vec4 u_fragmentParm3;\n"
"\n"
"in highp vec4 var_TexCoord;\n"
"out vec4 _gl_FragColor;\n"
"\n"
"// # texture 0 is _currentRender\n"
"// # texture 1 is a normal map that we will use to deform texture 0\n"
"\n"
"// # env[0] is the 1.0 to _currentRender conversion\n"
"// # env[1] is the fragment.position to 0.0 - 1.0 conversion\n"
"\n"
"void main(void)\n"
"{\n"
"// # scale by the screen non-power-of-two-adjust\n"
"    vec3 color = texture( u_fragmentMap0, var_TexCoord.st * u_nonPowerOfTwo.xy ).rgb;\n"
"    float R0 = dot( color, vec3( 0.3, 0.5, 0.1 ) );\n"
"    color = mix( vec3( R0 ), color, u_fragmentParm0.xyz );\n"
"    color = mix( vec3( u_fragmentParm1.y ), color, u_fragmentParm1.x );\n"
"    color = color * u_fragmentParm2.xyz + u_fragmentParm3.xyz;\n"
"    _gl_FragColor = vec4( color, 0.2 );\n"
"}\n"
;

// screeneffect
GLSL_SHADER const char ES3_SCREENEFFECT_VERT[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"in highp vec4 attr_Vertex;\n"
"in highp vec4 attr_TexCoord;\n"
"in highp vec4 attr_Color;\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"\n"
"out highp vec4 var_TexCoord;\n"
"out lowp vec4 var_Color;\n"
"\n"
"// # texture 0 takes the texture coordinates unmodified\n"
"\n"
"void main(void)\n"
"{\n"
"    gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"\n"
"    var_TexCoord = attr_TexCoord;\n"
"    var_Color = attr_Color / 255.0;\n"
"}\n"
;

GLSL_SHADER const char ES3_SCREENEFFECT_FRAG[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"uniform sampler2D u_fragmentMap0;\n"
"uniform sampler2D u_fragmentMap2;\n"
"uniform highp vec4 u_nonPowerOfTwo;\n"
"uniform highp vec4 u_fragmentParm0;\n"
"uniform highp vec4 u_fragmentParm1;\n"
"uniform highp vec4 u_fragmentParm2;\n"
"uniform highp vec4 u_fragmentParm3;\n"
"uniform highp vec4 u_fragmentParm4;\n"
"uniform highp vec4 u_fragmentParm5;\n"
"\n"
"in highp vec4 var_TexCoord;\n"
"in lowp vec4 var_Color;\n"
"out vec4 _gl_FragColor;\n"
"\n"
"// # texture 0 is _currentRender\n"
"// # texture 1 is a normal map that we will use to deform texture 0\n"
"\n"
"// # env[0] is the 1.0 to _currentRender conversion\n"
"// # env[1] is the fragment.position to 0.0 - 1.0 conversion\n"
"\n"
"void main(void)\n"
"{\n"
"    vec2 sampleOffsets[12] = vec2[12](\n"
"        vec2( -0.326212, -0.405805 ), \n"
"        vec2( -0.840144, -0.073580 ), \n"
"        vec2( -0.695914,  0.457137 ), \n"
"        vec2( -0.203345,  0.620716 ), \n"
"        vec2( 0.962340, -0.194983 ), \n"
"        vec2( 0.473434, -0.480026 ), \n"
"        vec2( 0.519456,  0.767022 ), \n"
"        vec2( 0.185461, -0.893124 ), \n"
"        vec2( 0.507431,  0.064425 ), \n"
"        vec2( 0.896420,  0.412458 ), \n"
"        vec2( -0.321940, -0.932615 ), \n"
"        vec2( -0.791559, -0.597705 ) \n"
"    );\n"
"\n"
"    vec2 size = u_fragmentParm0.xy;\n"
"    vec2 strength = u_fragmentParm0.xy;\n"
"\n"
"// # calculate the screen texcoord in the 0.0 to 1.0 range\n"
"// # scale by the screen non-power-of-two-adjust\n"
"    vec2 pos = var_TexCoord.st * u_nonPowerOfTwo.xy;\n"
"\n"
"    vec3 color = vec3( 0.0 );\n"
"\n"
"    for( int i = 0; i < 12; ++i ) {\n"
"        vec2 tc = sampleOffsets[i] * size.x + pos;\n"
"        vec3 c = texture( u_fragmentMap0, tc ).rgb;\n"
"        color = c * strength.y + color;\n"
"    }\n"
"\n"
"    vec3 R0 = texture( u_fragmentMap0, pos ).rgb;\n"
"\n"
"    color = clamp( u_fragmentParm1.x * color + u_fragmentParm1.y, 0.0, 1.0 );\n"
"\n"
"    color = mix( color, R0, u_fragmentParm0.z );\n"
"\n"
"    float R1 = dot( color, vec3( 0.3, 0.5, 0.1 ) );\n"
"    color = mix( vec3( R1 ), color, u_fragmentParm2.x );\n"
"    color = mix( vec3( u_fragmentParm3.y ), color, u_fragmentParm3.x );\n"
"    R1 = R1 * u_fragmentParm4.a;\n"
"    color = mix( color, u_fragmentParm4.xyz, R1 );\n"
"    color = color * 0.95 + u_fragmentParm5.xyz;\n"
"\n"
"    vec3 R1v3 = texture( u_fragmentMap2, var_TexCoord.st ).rgb;\n"
"    color = mix( R0, color, R1v3 );\n"
"\n"
"    _gl_FragColor = vec4( color, 1.0 );\n"
"}\n"
;

// radialblur
GLSL_SHADER const char ES3_RADIALBLUR_VERT[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"in highp vec4 attr_Vertex;\n"
"in highp vec4 attr_TexCoord;\n"
"in highp vec4 attr_Color;\n"
"\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"\n"
"out highp vec4 var_TexCoord;\n"
"out lowp vec4 var_Color;\n"
"\n"
"// # texture 0 takes the texture coordinates unmodified\n"
"\n"
"void main(void)\n"
"{\n"
"    gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"\n"
"    var_TexCoord = attr_TexCoord;\n"
"    var_Color = attr_Color / 255.0;\n"
"}\n"
;

GLSL_SHADER const char ES3_RADIALBLUR_FRAG[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"uniform sampler2D u_fragmentMap0;\n"
"uniform highp vec4 u_nonPowerOfTwo;\n"
"uniform highp vec4 u_fragmentParm0;\n"
"uniform highp vec4 u_fragmentParm1;\n"
"uniform highp vec4 u_fragmentParm2;\n"
"uniform highp vec4 u_fragmentParm3;\n"
"uniform highp vec4 u_fragmentParm4;\n"
"uniform highp vec4 u_fragmentParm5;\n"
"\n"
"in highp vec4 var_TexCoord;\n"
"in lowp vec4 var_Color;\n"
"out vec4 _gl_FragColor;\n"
"\n"
"// # texture 0 is _currentRender\n"
"// # texture 1 is a normal map that we will use to deform texture 0\n"
"\n"
"// # env[0] is the 1.0 to _currentRender conversion\n"
"// # env[1] is the fragment.position to 0.0 - 1.0 conversion\n"
"\n"
"void main(void)\n"
"{\n"
"    vec2 size = u_fragmentParm0.xy;\n"
"    vec2 strength = u_fragmentParm0.xy;\n"
"\n"
"// # calculate the screen texcoord in the 0.0 to 1.0 range\n"
"// # scale by the screen non-power-of-two-adjust\n"
"    vec2 pos = var_TexCoord.st * u_nonPowerOfTwo.xy;\n"
"\n"
"    vec3 color = vec3( 0.0 );\n"
"\n"
"    vec2 halfTemp = u_nonPowerOfTwo.xy * 0.5;\n"
"    vec2 R1 = pos.xy - halfTemp;\n"
"\n"
"    float displace = 1.0;\n"
"    vec2 tc = R1 * displace + halfTemp;\n"
"    vec3 c = texture( u_fragmentMap0, tc ).rgb;\n"
"    color = c * strength.y + color;\n"
"\n"
"    displace = displace - size.x;\n"
"    tc = R1 * displace + halfTemp;\n"
"    c = texture( u_fragmentMap0, tc ).rgb;\n"
"    color = c * strength.y + color;\n"
"\n"
"    displace = displace - size.x;\n"
"    tc = R1 * displace + halfTemp;\n"
"    c = texture( u_fragmentMap0, tc ).rgb;\n"
"    color = c * strength.y + color;\n"
"\n"
"    displace = displace - size.x;\n"
"    tc = R1 * displace + halfTemp;\n"
"    c = texture( u_fragmentMap0, tc ).rgb;\n"
"    color = c * strength.y + color;\n"
"\n"
"    displace = displace - size.x;\n"
"    tc = R1 * displace + halfTemp;\n"
"    c = texture( u_fragmentMap0, tc ).rgb;\n"
"    color = c * strength.y + color;\n"
"\n"
"    displace = displace - size.x;\n"
"    tc = R1 * displace + halfTemp;\n"
"    c = texture( u_fragmentMap0, tc ).rgb;\n"
"    color = c * strength.y + color;\n"
"\n"
"    displace = displace - size.x;\n"
"    tc = R1 * displace + halfTemp;\n"
"    c = texture( u_fragmentMap0, tc ).rgb;\n"
"    color = c * strength.y + color;\n"
"\n"
"    displace = displace - size.x;\n"
"    tc = R1 * displace + halfTemp;\n"
"    c = texture( u_fragmentMap0, tc ).rgb;\n"
"    color = c * strength.y + color;\n"
"\n"
"    vec3 R0 = texture( u_fragmentMap0, pos ).rgb;\n"
"\n"
"    color = clamp( u_fragmentParm1.x * color + u_fragmentParm1.y, 0.0, 1.0 );\n"
"\n"
"    color = mix( color, R0, u_fragmentParm0.z );\n"
"\n"
"    float R1F = dot( color, vec3( 0.3, 0.5, 0.1 ) );\n"
"    color = mix( vec3( R1F ), color, u_fragmentParm2.x );\n"
"    color = mix( vec3( u_fragmentParm3.y ), color, u_fragmentParm3.x );\n"
"    R1F = R1F * u_fragmentParm4.a;\n"
"    color = mix( color, u_fragmentParm4.xyz, R1F );\n"
"    color = color * 0.95 + u_fragmentParm5.xyz;\n"
"\n"
"    _gl_FragColor = vec4( color, 1.0 );\n"
"}\n"
;

// liquid
GLSL_SHADER const char ES3_LIQUID_VERT[] =
"#version 300 es\n"
"\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"in vec4 attr_TexCoord;\n"
"in vec3 attr_Tangent;\n"
"in vec3 attr_Bitangent;\n"
"in vec3 attr_Normal;\n"
"in highp vec4 attr_Vertex;\n"
"\n"
"uniform vec4 u_viewOrigin;\n"
"uniform highp mat4 u_modelViewProjectionMatrix;\n"
"uniform highp mat4 u_modelMatrix;\n"
"uniform highp mat4 u_modelViewMatrix;\n"
"uniform highp mat4 u_projectionMatrix;\n"
"uniform vec4 u_vertexParm1; // deform magnitude (1.0 is reasonable, 2.0 is twice as wavy, 0.5 is half as wavy, etc)\n"
"\n"
"out vec4 var_TexCoord0; // texCoord[0] is the normal map texcoord\n"
"out highp vec4 var_TexCoord1; // texCoord[1] is the vector to the eye in global space //karin: must high precison on GLSL\n"
"out vec4 var_TexCoord2; // texCoord[2] is the surface tangent to global coordiantes\n"
"out vec4 var_TexCoord3; // texCoord[3] is the surface bitangent to global coordiantes\n"
"out vec4 var_TexCoord4; // texCoord[4] is the surface normal to global coordiantes\n"
"out vec4 var_TexCoord6; // texCoord[6] is the copied deform magnitude\n"
"//out vec4 var_TexCoord7; // texCoord[7] is the copied scroll\n"
"\n"
"void main(void)\n"
"{\n"
"    vec4 scale = vec4( 2.0, 2.0, 2.0, 2.0 );\n"
"    vec4 R0 = u_viewOrigin - attr_Vertex;\n"
"\n"
"    // texture 1 is the vector to the eye in global coordinates\n"
"    var_TexCoord1.x = dot(R0.xyz, u_modelMatrix[0].xyz);\n"
"    var_TexCoord1.y = dot(R0.xyz, u_modelMatrix[1].xyz);\n"
"    var_TexCoord1.z = dot(R0.xyz, u_modelMatrix[2].xyz);\n"
"\n"
"    // texture 2 gets the transformed tangent\n"
"    var_TexCoord2.x = dot(attr_Tangent, u_modelMatrix[0].xyz);\n"
"    var_TexCoord3.x = dot(attr_Tangent, u_modelMatrix[1].xyz);\n"
"    var_TexCoord4.x = dot(attr_Tangent, u_modelMatrix[2].xyz);\n"
"\n"
"    // texture 3 gets the transformed bitangent\n"
"    var_TexCoord2.y = dot(attr_Bitangent, u_modelMatrix[0].xyz);\n"
"    var_TexCoord3.y = dot(attr_Bitangent, u_modelMatrix[1].xyz);\n"
"    var_TexCoord4.y = dot(attr_Bitangent, u_modelMatrix[2].xyz);\n"
"\n"
"    // texture 4 gets the transformed normal\n"
"    var_TexCoord2.z = dot(attr_Normal, u_modelMatrix[0].xyz);\n"
"    var_TexCoord3.z = dot(attr_Normal, u_modelMatrix[1].xyz);\n"
"    var_TexCoord4.z = dot(attr_Normal, u_modelMatrix[2].xyz);\n"
"\n"
"    // take the texture coordinates and add a scroll\n"
"    var_TexCoord0 = attr_TexCoord;\n"
"\n"
"    // texture 6 takes the deform magnitude and scales it by the projection distance\n"
"    R0 = vec4( 1.0, 0.0, 0.0, 1.0 );\n"
"    R0.z = dot(attr_Vertex, u_modelViewMatrix[2]);\n"
"\n"
"    float R1 = dot(R0, u_projectionMatrix[0]);\n"
"    float R2 = dot(R0, u_projectionMatrix[3]);\n"
"\n"
"    // don't let the recip get near zero for polygons that cross the view plane\n"
"    R2 = max(R2, 1.0);\n"
"\n"
"    R2 = 1.0 / R2;\n"
"    R1 = R1 * R2;\n"
"\n"
"    // clamp the distance so the the deformations don't get too wacky near the view\n"
"    R1 = min(R1, 0.02);\n"
"    var_TexCoord6 = R1 * u_vertexParm1;\n"
"\n"
"    //var_TexCoord7 = scroll;\n"
"\n"
"    gl_Position = u_modelViewProjectionMatrix * attr_Vertex;\n"
"}\n"
;

GLSL_SHADER const char ES3_LIQUID_FRAG[] =
"#version 300 es\n"
"\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"// per-pixel reflection-refraction liquid\n"
"in vec4 var_TexCoord0; // texCoord[0] is the normal map texcoord\n"
"in highp vec4 var_TexCoord1; // texCoord[1] is the vector to the eye in global space //karin: must high precison on GLSL\n"
"in vec4 var_TexCoord2; // texCoord[2] is the surface tangent to global coordiantes\n"
"in vec4 var_TexCoord3; // texCoord[3] is the surface bitangent to global coordiantes\n"
"in vec4 var_TexCoord4; // texCoord[4] is the surface normal to global coordiantes\n"
"in vec4 var_TexCoord6; // texCoord[6] is the copied deform magnitude\n"
"//in vec4 var_TexCoord7; // texCoord[7] is the copied scroll\n"
"\n"
"uniform highp vec4 u_nonPowerOfTwo; // env[0] is the 1.0 to _currentRender conversion\n"
"uniform highp vec4 u_windowCoords; // env[1] is the fragment.position to 0.0 - 1.0 conversion\n"
"uniform vec4 u_fragmentParm0; // scroll\n"
"uniform vec4 u_fragmentParm1; // deform magnitude (1.0 is reasonable, 2.0 is twice as wavy, 0.5 is half as wavy, etc)\n"
"uniform vec4 u_fragmentParm2; // refract color\n"
"uniform vec4 u_fragmentParm3; // reflect color\n"
"\n"
"uniform samplerCube u_fragmentCubeMap0; // texture 0 is the environment cube map\n"
"uniform sampler2D u_fragmentMap1; // texture 1 is the normal map\n"
"uniform sampler2D u_fragmentMap2; // texture 2 is _currentRender\n"
"\n"
"out vec4 _gl_FragColor;\n"
"\n"
"void main(void)\n"
"{\n"
"    vec4 scroll = u_fragmentParm3;\n"
"\n"
"    const vec4 subOne = vec4( -1.0, -1.0, -1.0, -1.0 );\n"
"    const vec4 scaleTwo = vec4( 2.0, 2.0, 2.0, 2.0 );\n"
"\n"
"    // load the filtered normal map, then normalize to full scale,\n"
"    vec4 R0 = 0.02 * scroll + var_TexCoord0;\n"
"    R0 = 0.9 * R0;\n"
"    vec4 localNormal = texture(u_fragmentMap1, R0.st);\n"
"\n"
"    R0 = 0.1 * scroll.zyxy + var_TexCoord0;\n"
"    R0 = 0.125 * R0;\n"
"    R0 = texture(u_fragmentMap1, R0.st);\n"
"    localNormal = R0 + localNormal;\n"
"\n"
"    R0 = -0.17 * scroll.wxxy + var_TexCoord0;\n"
"    R0 = 0.5 * R0;\n"
"    R0 = texture(u_fragmentMap1, R0.st);\n"
"    localNormal = R0 + localNormal;\n"
"\n"
"    R0 = 0.2 * scroll.wwxy + var_TexCoord0;\n"
"    R0 = 0.25 * R0;\n"
"    R0 = texture(u_fragmentMap1, R0.st);\n"
"    localNormal = R0 + localNormal;\n"
"\n"
"    localNormal = localNormal.agbr * scaleTwo - 4.0;\n"
"    localNormal.xy = localNormal.xy * 1.5;\n"
"\n"
"    // transform the surface normal by the local tangent space\n"
"    vec4 globalNormal;\n"
"    globalNormal.x = dot(localNormal.xyz, var_TexCoord2.xyz);\n"
"    globalNormal.y = dot(localNormal.xyz, var_TexCoord3.xyz);\n"
"    globalNormal.z = dot(localNormal.xyz, var_TexCoord4.xyz);\n"
"    globalNormal.w = 1.0;\n"
"\n"
"    // normalize\n"
"    vec4 R1;\n"
"    R1.x = dot(globalNormal.xyz, globalNormal.xyz);\n"
"    R1.x = 1.0 / sqrt(R1.x);\n"
"    globalNormal.xyz = (globalNormal * R1.x).xyz;\n"
"\n"
"    // normalize vector to eye\n"
"    highp float R0_x = dot(var_TexCoord1.xyz, var_TexCoord1.xyz); //karin: must high precison on GLSL\n"
"    R0_x = 1.0 / sqrt(R0_x);\n"
"    vec4 globalEye = var_TexCoord1 * R0_x;\n"
"\n"
"    // calculate reflection vector\n"
"    R1 = vec4(dot(globalEye.xyz, globalNormal.xyz));\n"
"    R0 = R1 * globalNormal;\n"
"    R0 = R0 * scaleTwo - globalEye;\n"
"\n"
"    // read the environment map with the reflection vector\n"
"    R0 = texture(u_fragmentCubeMap0, R0.xyz);\n"
"\n"
"    // calculate fresnel\n"
"    vec4 fresnel = vec4(1.0 - R1); // 1 - V dot N\n"
"    fresnel = vec4(pow(fresnel.x, u_fragmentParm0.x)); // assume index is 1\n"
"    fresnel = fresnel * u_fragmentParm0.y + u_fragmentParm0.z;\n"
"\n"
"    // calculate the screen texcoord in the 0.0 to 1.0 range\n"
"    R1 = gl_FragCoord * u_windowCoords;\n"
"\n"
"    // offset by the scaled globalNormal and clamp it to 0.0 - 1.0\n"
"    R1 = clamp(globalNormal * var_TexCoord6 + R1, 0.0, 1.0);\n"
"\n"
"    // scale by the screen non-power-of-two-adjust\n"
"    R1 = R1 * u_nonPowerOfTwo;\n"
"\n"
"    // load the screen render\n"
"    R1 = texture(u_fragmentMap2, R1.st);\n"
"\n"
"    R1 = R1 * u_fragmentParm1;\n"
"    R0 = R0 * u_fragmentParm2;\n"
"\n"
"    vec3 color = mix(R1, R0, fresnel).xyz; // lerp refract and reflect\n"
"\n"
"    _gl_FragColor = vec4(color, 1.0);\n"
"}\n"
;

#endif
