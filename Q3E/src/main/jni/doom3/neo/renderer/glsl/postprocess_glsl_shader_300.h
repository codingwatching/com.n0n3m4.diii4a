
// retro postprocess 2D general vertex shader
GLSL_SHADER const char ES3_RETRO_POSTPROCESS_2D_VERT[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"in vec4 attr_TexCoord;\n"
"in highp vec4 attr_Vertex;\n"
"\n"
"out vec2 var_TexCoord;\n"
"\n"
"void main(void)\n"
"{\n"
"    gl_Position = attr_Vertex;\n"
"    gl_Position.y = -attr_Vertex.y;\n"
"\n"
"    var_TexCoord = attr_TexCoord.xy;\n"
"}\n"
;

#define _ES3_RETRO_POSTPROCESS_GENERAL_FUNCTION \
"#define RGB(r, g, b) vec3(float(r)/255.0, float(g)/255.0, float(b)/255.0)\n" \
"\n" \
"// array/table version from http://www.anisopteragames.com/how-to-fix-color-banding-with-dithering/\n" \
"const int ArrayDitherArray8x8[64] = int[64] (\n" \
"    0, 32,  8, 40,  2, 34, 10, 42,   /* 8x8 Bayer ordered dithering  */\n" \
"    48, 16, 56, 24, 50, 18, 58, 26,  /* pattern.  Each input pixel   */\n" \
"    12, 44,  4, 36, 14, 46,  6, 38,  /* is scaled to the 0..63 range */\n" \
"    60, 28, 52, 20, 62, 30, 54, 22,  /* before looking in this table */\n" \
"    3, 35, 11, 43,  1, 33,  9, 41,   /* to determine the action.     */\n" \
"    51, 19, 59, 27, 49, 17, 57, 25,\n" \
"    15, 47,  7, 39, 13, 45,  5, 37,\n" \
"    63, 31, 55, 23, 61, 29, 53, 21\n" \
");\n" \
"\n" \
"float DitherArray8x8( vec2 pos )\n" \
"{\n" \
"    int stippleOffset = ( int( pos.y ) % 8 ) * 8 + ( int( pos.x ) % 8 );\n" \
"    int byte = ArrayDitherArray8x8[stippleOffset];\n" \
"    float stippleThreshold = float(byte) / 64.0f;\n" \
"    return stippleThreshold;\n" \
"}\n"

// 2bit retro postprocess
GLSL_SHADER const char ES3_RETRO_2BIT_FRAG[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"#define RESOLUTION_DIVISOR 4.0\n"
"#define NUM_COLORS 4\n"
"\n"
"uniform sampler2D u_fragmentMap0; // currentRender\n"
"\n"
"uniform highp vec4 u_windowCoords;\n"
"uniform highp vec4 u_nonPowerOfTwo;\n"
"uniform highp vec4 u_uniformParm0; // rpJitterTexScale\n"
"\n"
"in vec2 var_TexCoord;\n"
"in lowp vec4 var_Color;\n"
"out vec4 _gl_FragColor;\n"
"\n"
"vec3 Average( vec3 pal[NUM_COLORS] )\n"
"{\n"
"    vec3 sum = vec3( 0.0 );\n"
"\n"
"    for( int i = 0; i < NUM_COLORS; i++ )\n"
"    {\n"
"        sum += pal[i];\n"
"    }\n"
"\n"
"    return sum / float( NUM_COLORS );\n"
"}\n"
"\n"
"vec3 Deviation( vec3 pal[NUM_COLORS] )\n"
"{\n"
"    vec3 sum = vec3( 0.0 );\n"
"    vec3 avg = Average( pal );\n"
"\n"
"    for( int i = 0; i < NUM_COLORS; i++ )\n"
"    {\n"
"        sum += abs( pal[i] - avg );\n"
"    }\n"
"\n"
"    return sum / float( NUM_COLORS );\n"
"}\n"
"\n"
"// squared distance to avoid the sqrt of distance function\n"
"float ColorCompare( vec3 a, vec3 b )\n"
"{\n"
"    vec3 diff = b - a;\n"
"    return dot( diff, diff );\n"
"}\n"
"\n"
"// find nearest palette color using Euclidean distance\n"
"vec3 LinearSearch( vec3 c, vec3 pal[NUM_COLORS] )\n"
"{\n"
"    int index = 0;\n"
"    float minDist = ColorCompare( c, pal[0] );\n"
"\n"
"    for( int i = 1; i < NUM_COLORS; i++ )\n"
"    {\n"
"        float dist = ColorCompare( c, pal[i] );\n"
"\n"
"        if( dist < minDist )\n"
"        {\n"
"            minDist = dist;\n"
"            index = i;\n"
"        }\n"
"    }\n"
"\n"
"    return pal[index];\n"
"}\n"
"\n"
_ES3_RETRO_POSTPROCESS_GENERAL_FUNCTION
"\n"
"void main(void)\n"
"{\n"
"    // CGA\n"
"    // https://lospec.com/palette-list/cga-mibend4\n"
"    const vec3 palette[NUM_COLORS] = vec3[NUM_COLORS] (// 4\n"
"        RGB( 41, 31, 35 ),\n"
"        RGB( 189, 80, 47 ),\n"
"        RGB( 52, 209, 175 ),\n"
"        RGB( 247, 236, 185 )\n"
"    );\n"
"\n"
"    vec2 uv = ( var_TexCoord );\n"
"    vec2 uvPixelated = floor( gl_FragCoord.xy / RESOLUTION_DIVISOR ) * RESOLUTION_DIVISOR;\n"
"\n"
"    vec3 quantizationPeriod = vec3( 1.0 / float(NUM_COLORS) );\n"
"    vec3 quantDeviation = Deviation( palette );\n"
"\n"
"    // get pixellated base color\n"
"    vec3 color = texture( u_fragmentMap0, uvPixelated * u_windowCoords.xy * u_nonPowerOfTwo.xy ).rgb;\n"
"\n"
"    vec2 uvDither = uvPixelated;\n"
"    //if( u_uniformParm0.x > 1.0 )\n"
"    {\n"
"        uvDither = gl_FragCoord.xy / ( RESOLUTION_DIVISOR / u_uniformParm0.x );\n"
"    }\n"
"    float dither = DitherArray8x8( uvDither ) - 0.5;\n"
"\n"
"    color.rgb += vec3( dither, dither, dither ) * quantDeviation * u_uniformParm0.y;\n"
"\n"
"    // find closest color match from C64 color palette\n"
"    color = LinearSearch( color.rgb, palette );\n"
"\n"
"    _gl_FragColor = vec4( color, 1.0 );\n"
"}\n"
;

// c64 retro postprocess
GLSL_SHADER const char ES3_RETRO_C64_FRAG[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"#define RESOLUTION_DIVISOR 4.0\n"
"#define NUM_COLORS 16\n"
"\n"
"uniform sampler2D u_fragmentMap0; // currentRender\n"
"\n"
"uniform highp vec4 u_windowCoords;\n"
"uniform highp vec4 u_nonPowerOfTwo;\n"
"uniform highp vec4 u_uniformParm0; // rpJitterTexScale\n"
"\n"
"in vec2 var_TexCoord;\n"
"in lowp vec4 var_Color;\n"
"out vec4 _gl_FragColor;\n"
"\n"
"vec3 Average( vec3 pal[NUM_COLORS] )\n"
"{\n"
"    vec3 sum = vec3( 0.0 );\n"
"\n"
"    for( int i = 0; i < NUM_COLORS; i++ )\n"
"    {\n"
"        sum += pal[i];\n"
"    }\n"
"\n"
"    return sum / float( NUM_COLORS );\n"
"}\n"
"\n"
"vec3 Deviation( vec3 pal[NUM_COLORS] )\n"
"{\n"
"    vec3 sum = vec3( 0.0 );\n"
"    vec3 avg = Average( pal );\n"
"\n"
"    for( int i = 0; i < NUM_COLORS; i++ )\n"
"    {\n"
"        sum += abs( pal[i] - avg );\n"
"    }\n"
"\n"
"    return sum / float( NUM_COLORS );\n"
"}\n"
"\n"
"// squared distance to avoid the sqrt of distance function\n"
"float ColorCompare( vec3 a, vec3 b )\n"
"{\n"
"    vec3 diff = b - a;\n"
"    return dot( diff, diff );\n"
"}\n"
"\n"
"// find nearest palette color using Euclidean distance\n"
"vec3 LinearSearch( vec3 c, vec3 pal[NUM_COLORS] )\n"
"{\n"
"    int index = 0;\n"
"    float minDist = ColorCompare( c, pal[0] );\n"
"\n"
"    for( int i = 1; i < NUM_COLORS; i++ )\n"
"    {\n"
"        float dist = ColorCompare( c, pal[i] );\n"
"\n"
"        if( dist < minDist )\n"
"        {\n"
"            minDist = dist;\n"
"            index = i;\n"
"        }\n"
"    }\n"
"\n"
"    return pal[index];\n"
"}\n"
"\n"
_ES3_RETRO_POSTPROCESS_GENERAL_FUNCTION
"\n"
"void main(void)\n"
"{\n"
"    // gamma corrected version\n"
"    const vec3 palette[NUM_COLORS] = vec3[NUM_COLORS] (\n"
"        RGB( 0, 0, 0 ),            // black\n"
"        RGB( 255, 255, 255 ),    // white\n"
"        RGB( 104, 55,  43 ),    // red\n"
"        RGB( 112, 164, 178 ),    // cyan\n"
"        RGB( 111, 61,  134 ),    // purple\n"
"        RGB( 88,  141, 67 ),    // green\n"
"        RGB( 53,  40,  121 ),    // blue\n"
"        RGB( 184, 199, 111 ),    // yellow\n"
"        RGB( 111, 79,  37 ),    // orange\n"
"        RGB( 67,  57,  0 ),        // brown\n"
"        RGB( 154, 103, 89 ),    // light red\n"
"        RGB( 68,  68,  68 ),    // dark grey\n"
"        RGB( 108, 108, 108 ),    // grey\n"
"        RGB( 154, 210, 132 ),    // light green\n"
"        RGB( 108, 94,  181 ),    // light blue\n"
"        RGB( 149, 149, 149 )    // light grey\n"
"    );\n"
"    vec2 uv = ( var_TexCoord );\n"
"    vec2 uvPixelated = floor( gl_FragCoord.xy / RESOLUTION_DIVISOR ) * RESOLUTION_DIVISOR;\n"
"\n"
"    vec3 quantizationPeriod = vec3( 1.0 / float(NUM_COLORS) );\n"
"    vec3 quantDeviation = Deviation( palette );\n"
"\n"
"    // get pixellated base color\n"
"    vec3 color = texture( u_fragmentMap0, uvPixelated * u_windowCoords.xy * u_nonPowerOfTwo.xy ).rgb;\n"
"\n"
"    vec2 uvDither = uvPixelated;\n"
"    //if( u_uniformParm0.x > 1.0 )\n"
"    {\n"
"        uvDither = gl_FragCoord.xy / ( RESOLUTION_DIVISOR / u_uniformParm0.x );\n"
"    }\n"
"    float dither = DitherArray8x8( uvDither ) - 0.5;\n"
"\n"
"    //color.rgb += vec3( dither, dither, dither ) * quantizationPeriod;\n"
"    color.rgb += vec3( dither, dither, dither ) * quantDeviation * u_uniformParm0.y;\n"
"\n"
"    // find closest color match from C64 color palette\n"
"    color = LinearSearch( color.rgb, palette );\n"
"\n"
"    //color = texture( u_fragmentMap0, uv ).rgb;\n"
"    _gl_FragColor = vec4( color, 1.0 );\n"
"}\n"
;

// cpc retro postprocess
GLSL_SHADER const char ES3_RETRO_CPC_FRAG[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"#define RESOLUTION_DIVISOR 4.0\n"
"#define NUM_COLORS 31 // original 27\n"
"\n"
"uniform sampler2D u_fragmentMap0; // currentRendert\n"
"\n"
"uniform highp vec4 u_windowCoords;\n"
"uniform highp vec4 u_nonPowerOfTwo;\n"
"uniform highp vec4 u_uniformParm0; // rpJitterTexScale\n"
"\n"
"in vec2 var_TexCoord;\n"
"in lowp vec4 var_Color;\n"
"out vec4 _gl_FragColor;\n"
"\n"
"\n"
"vec3 Average( vec3 pal[NUM_COLORS] )\n"
"{\n"
"    vec3 sum = vec3( 0.0 );\n"
"\n"
"    for( int i = 0; i < NUM_COLORS; i++ )\n"
"    {\n"
"        sum += pal[i];\n"
"    }\n"
"\n"
"    return sum / float( NUM_COLORS );\n"
"}\n"
"\n"
"vec3 Deviation( vec3 pal[NUM_COLORS] )\n"
"{\n"
"    vec3 sum = vec3( 0.0 );\n"
"    vec3 avg = Average( pal );\n"
"\n"
"    for( int i = 0; i < NUM_COLORS; i++ )\n"
"    {\n"
"        sum += abs( pal[i] - avg );\n"
"    }\n"
"\n"
"    return sum / float( NUM_COLORS );\n"
"}\n"
"\n"
"// squared distance to avoid the sqrt of distance function\n"
"float ColorCompare( vec3 a, vec3 b )\n"
"{\n"
"    vec3 diff = b - a;\n"
"    return dot( diff, diff );\n"
"}\n"
"\n"
"// find nearest palette color using Euclidean distance\n"
"vec3 LinearSearch( vec3 c, vec3 pal[NUM_COLORS] )\n"
"{\n"
"    int index = 0;\n"
"    float minDist = ColorCompare( c, pal[0] );\n"
"\n"
"    for( int i = 1; i < NUM_COLORS; i++ )\n"
"    {\n"
"        float dist = ColorCompare( c, pal[i] );\n"
"\n"
"        if( dist < minDist )\n"
"        {\n"
"            minDist = dist;\n"
"            index = i;\n"
"        }\n"
"    }\n"
"\n"
"    return pal[index];\n"
"}\n"
"\n"
_ES3_RETRO_POSTPROCESS_GENERAL_FUNCTION
"\n"
"void main(void)\n"
"{\n"
"    // https://lospec.com/palette-list/ruzzi-cpc\n"
"    const vec3 palette[NUM_COLORS] = vec3[NUM_COLORS]( // 31\n"
"        RGB( 0, 0, 28 ), // dark blue\n"
"        RGB( 28, 0, 28 ), // dark magenta\n"
"        RGB( 33, 30, 32 ),\n"
"        RGB( 85, 85, 104 ),\n"
"\n"
"        RGB( 36, 14, 11 ),\n"
"        RGB( 26, 34, 114 ),\n"
"        RGB( 68, 118, 16 ),\n"
"        RGB( 129, 16, 51 ),\n"
"        RGB( 50, 131, 113 ),\n"
"        RGB( 124, 36, 136 ),\n"
"        RGB( 151, 122, 44 ),\n"
"        RGB( 16, 55, 218 ),\n"
"        RGB( 143, 136, 132 ),\n"
"        RGB( 222, 18, 92 ),\n"
"        RGB( 100, 222, 21 ),\n"
"        RGB( 32, 144, 210 ),\n"
"        RGB( 120, 58, 220 ),\n"
"        RGB( 74, 228, 112 ),\n"
"        RGB( 223, 39, 158 ),\n"
"        RGB( 236, 126, 74 ),\n"
"        RGB( 174, 228, 38 ),\n"
"        RGB( 136, 151, 219 ),\n"
"        RGB( 49, 234, 203 ),\n"
"        RGB( 163, 236, 128 ),\n"
"        RGB( 238, 142, 151 ),\n"
"        RGB( 224, 60, 223 ),\n"
"        RGB( 249, 234, 56 ),\n"
"        RGB( 152, 244, 218 ),\n"
"        RGB( 239, 157, 228 ),\n"
"        RGB( 252, 244, 144 ),\n"
"        RGB( 255, 255, 233 )\n"
"    );\n"
"\n"
"    const vec3 medianAbsoluteDeviation = RGB( 175, 6, 56 );\n"
"    const vec3 deviation = RGB( 67, 70, 62 );\n"
"    \n"
"    vec2 uv = ( var_TexCoord );\n"
"    vec2 uvPixelated = floor( gl_FragCoord.xy / RESOLUTION_DIVISOR ) * RESOLUTION_DIVISOR;\n"
"\n"
"    vec3 quantizationPeriod = vec3( 1.0 / float(NUM_COLORS) );\n"
"    vec3 quantDeviation = Deviation( palette );\n"
"\n"
"    // get pixellated base color\n"
"    vec3 color = texture( u_fragmentMap0, uvPixelated * u_windowCoords.xy * u_nonPowerOfTwo.xy ).rgb;\n"
"\n"
"    vec2 uvDither = uvPixelated;\n"
"    //if( u_uniformParm0.x > 1.0 )\n"
"    {\n"
"        uvDither = gl_FragCoord.xy / ( RESOLUTION_DIVISOR / u_uniformParm0.x );\n"
"    }\n"
"    float dither = DitherArray8x8( uvDither ) - 0.5;\n"
"\n"
"    //color.rgb += vec3( dither, dither, dither ) * quantizationPeriod;\n"
"    color += vec3( dither, dither, dither ) * quantDeviation * u_uniformParm0.y;\n"
"\n"
"    // find closest color match from CPC color palette\n"
"    color = LinearSearch( color, palette );\n"
"\n"
"    //color = texture( u_fragmentMap0, uv ).rgb;\n"
"    _gl_FragColor = vec4( color, 1.0 );\n"
"}\n"
;

// genesis retro postprocess
GLSL_SHADER const char ES3_RETRO_GENESIS_FRAG[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"#define RESOLUTION_DIVISOR 4.0\n"
"#define NUM_COLORS 64 // original 61\n"
"\n"
"uniform sampler2D u_fragmentMap0; // currentRender\n"
"\n"
"uniform highp vec4 u_windowCoords;\n"
"uniform highp vec4 u_nonPowerOfTwo;\n"
"uniform highp vec4 u_uniformParm0; // rpJitterTexScale\n"
"\n"
"in vec2 var_TexCoord;\n"
"in lowp vec4 var_Color;\n"
"out vec4 _gl_FragColor;\n"
"\n"
"// squared distance to avoid the sqrt of distance function\n"
"float ColorCompare( vec3 a, vec3 b )\n"
"{\n"
"    vec3 diff = b - a;\n"
"    return dot( diff, diff );\n"
"}\n"
"\n"
"// find nearest palette color using Euclidean distance\n"
"vec3 LinearSearch( vec3 c, vec3 pal[NUM_COLORS] )\n"
"{\n"
"    int index = 0;\n"
"    float minDist = ColorCompare( c, pal[0] );\n"
"\n"
"    for( int i = 1; i < NUM_COLORS; i++ )\n"
"    {\n"
"        float dist = ColorCompare( c, pal[i] );\n"
"\n"
"        if( dist < minDist )\n"
"        {\n"
"            minDist = dist;\n"
"            index = i;\n"
"        }\n"
"    }\n"
"\n"
"    return pal[index];\n"
"}\n"
"\n"
_ES3_RETRO_POSTPROCESS_GENERAL_FUNCTION
"\n"
"void main(void)\n"
"{\n"
"    // + very good dithering variety at dark grey values\n"
"    // + does not leak too much color into grey values\n"
"    // + good saturation when colors are really needed\n"
"    // - a bit too strong visible dithering pattern\n"
"    // https://lospec.com/palette-list/famicube\n"
"    /*const*/ vec3 palette[NUM_COLORS] = vec3[NUM_COLORS] (// 64\n"
"        RGB( 0, 0, 0 ),\n"
"        RGB( 21, 21, 21 ),\n"
"        RGB( 35, 23, 18 ),\n"
"        RGB( 23, 40, 8 ),\n"
"        RGB( 13, 32, 48 ),\n"
"        RGB( 33, 22, 64 ),\n"
"        RGB( 0, 78, 0 ),\n"
"        RGB( 79, 21, 7 ),\n"
"        RGB( 52, 52, 52 ),\n"
"        RGB( 92, 60, 13 ),\n"
"        RGB( 0, 96, 75 ),\n"
"        RGB( 55, 109, 3 ),\n"
"        RGB( 0, 23, 125 ),\n"
"        RGB( 0, 82, 128 ),\n"
"        RGB( 65, 93, 102 ),\n"
"        RGB( 135, 22, 70 ),\n"
"        RGB( 130, 60, 61 ),\n"
"        RGB( 19, 157, 8 ),\n"
"        RGB( 90, 25, 145 ),\n"
"        RGB( 61, 52, 165 ),\n"
"        RGB( 173, 78, 26 ),\n"
"        RGB( 32, 181, 98 ),\n"
"        RGB( 106, 180, 23 ),\n"
"        RGB( 147, 151, 23 ),\n"
"        RGB( 174, 108, 55 ),\n"
"        RGB( 123, 123, 123 ),\n"
"        RGB( 2, 74, 202 ),\n"
"        RGB( 10, 152, 172 ),\n"
"        RGB( 106, 49, 202 ),\n"
"        RGB( 88, 211, 50 ),\n"
"        RGB( 224, 60, 40 ),\n"
"        RGB( 207, 60, 113 ),\n"
"        RGB( 163, 40, 179 ),\n"
"        RGB( 204, 143, 21 ),\n"
"        RGB( 140, 214, 18 ),\n"
"        RGB( 113, 166, 161 ),\n"
"        RGB( 218, 101, 94 ),\n"
"        RGB( 98, 100, 220 ),\n"
"        RGB( 182, 193, 33 ),\n"
"        RGB( 197, 151, 130 ),\n"
"        RGB( 10, 137, 255 ),\n"
"        RGB( 246, 143, 55 ),\n"
"        RGB( 168, 168, 168 ),\n"
"        RGB( 225, 130, 137 ),\n"
"        RGB( 37, 226, 205 ),\n"
"        RGB( 91, 168, 255 ),\n"
"        RGB( 255, 187, 49 ),\n"
"        RGB( 190, 235, 113 ),\n"
"        RGB( 204, 105, 228 ),\n"
"        RGB( 166, 117, 254 ),\n"
"        RGB( 155, 160, 239 ),\n"
"        RGB( 245, 183, 132 ),\n"
"        RGB( 255, 231, 55 ),\n"
"        RGB( 255, 130, 206 ),\n"
"        RGB( 226, 215, 181 ),\n"
"        RGB( 213, 156, 252 ),\n"
"        RGB( 152, 220, 255 ),\n"
"        RGB( 215, 215, 215 ),\n"
"        RGB( 189, 255, 202 ),\n"
"        RGB( 238, 255, 169 ),\n"
"        RGB( 226, 201, 255 ),\n"
"        RGB( 255, 233, 197 ),\n"
"        RGB( 254, 201, 237 ),\n"
"        RGB( 255, 255, 255 )\n"
"    );\n"
"\n"
"    const vec3 medianAbsoluteDeviation = RGB( 63, 175, 2 );\n"
"    const vec3 deviation = RGB( 76, 62, 75 );\n"
"\n"
"    vec2 uv = ( var_TexCoord );\n"
"    vec2 uvPixelated = floor( gl_FragCoord.xy / RESOLUTION_DIVISOR ) * RESOLUTION_DIVISOR;\n"
"\n"
"    vec3 quantizationPeriod = vec3( 1.0 / float(NUM_COLORS) );\n"
"    vec3 quantDeviation = deviation;\n"
"\n"
"    // get pixellated base color\n"
"    vec3 color = texture( u_fragmentMap0, uvPixelated * u_windowCoords.xy * u_nonPowerOfTwo.xy ).rgb;\n"
"\n"
"    vec2 uvDither = uvPixelated;\n"
"    //if( u_uniformParm0.x > 1.0 )\n"
"    {\n"
"        uvDither = gl_FragCoord.xy / ( RESOLUTION_DIVISOR / u_uniformParm0.x );\n"
"    }\n"
"    float dither = DitherArray8x8( uvDither ) - 0.5;\n"
"\n"
"    color.rgb += vec3( dither, dither, dither ) * quantDeviation * u_uniformParm0.y;\n"
"\n"
"    // find closest color match from C64 color palette\n"
"    color = LinearSearch( color.rgb, palette );\n"
"\n"
"    //color = texture( u_fragmentMap0, uv ).rgb;\n"
"    _gl_FragColor = vec4( color, 1.0 );\n"
"}\n"
;

// ps1 retro postprocess
GLSL_SHADER const char ES3_RETRO_PS1_FRAG[] =
"#version 300 es\n"
"//#pragma optimize(off)\n"
"\n"
"precision mediump float;\n"
"\n"
"#define RESOLUTION_DIVISOR                4.0\n"
"#define Dithering_QuantizationSteps        32.0 // 8.0 = 2 ^ 3 quantization bits\n"
"\n"
"uniform sampler2D u_fragmentMap0; // currentRender\n"
"\n"
"uniform highp vec4 u_windowCoords;\n"
"uniform highp vec4 u_nonPowerOfTwo;\n"
"\n"
"in vec2 var_TexCoord;\n"
"in lowp vec4 var_Color;\n"
"out vec4 _gl_FragColor;\n"
"\n"
"vec3 Quantize( vec3 color, vec3 period )\n"
"{\n"
"    return floor( color * Dithering_QuantizationSteps ) * ( 1.0 / ( Dithering_QuantizationSteps - 1.0 ) );\n"
"}\n"
"\n"
_ES3_RETRO_POSTPROCESS_GENERAL_FUNCTION
"\n"
"void main(void)\n"
"{\n"
"    vec2 uv = ( var_TexCoord );\n"
"    vec2 uvPixelated = floor( gl_FragCoord.xy / RESOLUTION_DIVISOR ) * RESOLUTION_DIVISOR;\n"
"\n"
"    // most Sony Playstation 1 titles used 5 bit per RGB channel\n"
"    // 2^5 = 32\n"
"    // 32 * 32 * 32 = 32768 colors\n"
"\n"
"    const float quantizationSteps = Dithering_QuantizationSteps;\n"
"    vec3 quantizationPeriod = vec3( 1.0 / ( quantizationSteps - 1.0 ) );\n"
"\n"
"    // get pixellated base color\n"
"    vec3 color = texture( u_fragmentMap0, uvPixelated * u_windowCoords.xy * u_nonPowerOfTwo.xy ).rgb;\n"
"\n"
"    // add Bayer 8x8 dithering\n"
"    vec2 uvDither = gl_FragCoord.xy / RESOLUTION_DIVISOR;\n"
"\n"
"    float dither = DitherArray8x8( uvDither ) - 0.5;\n"
"\n"
"    color.rgb += vec3( dither, dither, dither ) * quantizationPeriod;\n"
"\n"
"    // PSX color quantization with 15-bit\n"
"    color = Quantize( color, quantizationPeriod );\n"
"\n"
"    //color = texture( u_fragmentMap0, uv ).rgb;\n"
"    _gl_FragColor = vec4( color, 1.0 );\n"
"}\n"
;
