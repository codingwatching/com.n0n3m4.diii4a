
/*******************************************************************************
SABot - Stupid Angry Bot - release alpha 9
"I obey these words, written in my head. I think they are spelled wrong."

bot_sabot_events.script
Events for SaBot script. Obviously.
***********************************************************************/
idStr botAi::GetBotEventsScript(void)
{
    return "\n"
           "// sets the next state and goes to it immediately\n"
           "scriptEvent\tvoid \t\t\tsetState( string stateFunc );\n"
           "scriptEvent\tstring  \tgetState();\n"
           "\n"
           "scriptEvent\tvoid \t\t\tsetEnemy( entity enemy );\n"
           "scriptEvent\tvoid \t\t\tclearEnemy();\n"
           "scriptEvent\tentity\t\theardSound( float ignore_team );\n"
           "\n"
           "// Updates the last known position of the enemy independent\n"
           "// from whether or not the enemy is visible.\n"
           "scriptEvent void\t\t\tlocateEnemy();\n"
           "\n"
           "scriptEvent\tentity\t\tgetEnemy();\n"
           "scriptEvent\tvector\t\tgetEnemyPos();\n"
           "scriptEvent\tvector\t\tgetEnemyEyePos();\n"
           "\n"
           "scriptEvent\tfloat\t\t\tenemyRange();\n"
           "scriptEvent float\t\t\tenemyRange2D();\n"
           "\n"
           "// Tries to predict the player's movement based on the AAS and his direction of movement.\n"
           "scriptEvent\tvector\t\tpredictEnemyPos( float time );\n"
           "\n"
           "scriptEvent entity\t\tgetBody(); // TinMan: Return fake client entity.\n"
           "\n"
           "scriptEvent float\t\t\tgetGameType();\n"
           "scriptEvent float\t\t\tisTeamGame();\n"
           "\n"
           "scriptEvent float \t\thasWeapon( string weaponName );\n"
           "scriptEvent float \t\thasAmmo( string ammoName );\n"
           "scriptEvent float \t\thasAmmoForWeapon( string weaponName );\n"
           "\n"
           "scriptEvent\tvoid\t\t\tsetAimRate( float rate );\n"
           "\n"
           "scriptEvent\tvoid\t\t\tsetAimDirection( vector dir );\n"
           "scriptEvent\tvector\t\tgetMovePosition(); // TinMan: Next point on path set by a setMove.\n"
           "//scriptEvent\tvector\t\tgetSecondaryMovePosition(); // TinMan: Position on path to do something, eg jump.\n"
           "scriptEvent\tfloat\t\t\tgetPathType(); // TinMan: Type of path, eg PATHTYPE_BARRIERJUMP.\n"
           "scriptEvent\tvoid\t\t\tsetMoveDirection( vector dir, float speed ); // TinMan: Set direction and speed for bot to (strafe)move in, 400 being da max. hmm, needs sprucing up with an unfunny and unrelated comment.\n"
           "\n"
           "scriptEvent\tfloat\t\t\tcanSeeEntity( entity ent, float useFov );\n"
           "scriptEvent\tfloat\t\t\tcanSeePosition( vector pos, float useFov );\n"
           "\n"
           "scriptEvent vector \t\tgetEyePosition();\n"
           "scriptEvent vector \t\tgetViewPosition();\n"
           "scriptEvent vector \t\tgetAIAimTargets( entity aimAtEnt, float head );\n"
           "scriptEvent vector \t\tgetAimDir( entity aimAtEnt, float prefered ); // TinMan: wizzbang all in one aim prediction\n"
           "\n"
           "// TinMan: Entity list functions, compiles a list and returns index.\n"
           "scriptEvent\tfloat\t\t\tfindEnemies( float onlyInFov ); // TinMan: Returns all clients and actors visible.\n"
           "scriptEvent float\t\t\tfindInRadius( vector pos, float radius ); // TinMan: Classname is class type (spawnclass) of entity you want to look for eg idItem.\n"
           "scriptEvent float\t\t\tfindItems(); // TinMan: Compile list of all idItems and all idItemPowerups.\n"
           "scriptEvent entity\t\tgetEntityList( float index ); // TinMan: Used to acess entity list, should only be used imediately after using one of the above functions.\n"
           "\n"
           "scriptEvent\tvoid \t\t\tsaveMove();\n"
           "scriptEvent\tvoid \t\t\trestoreMove();\n"
           "scriptEvent void\t\t\tstopMove(); \t// TinMan: ( allready defined in idAI ) Reset move state\n"
           "scriptEvent float\t\t\tmoveStatus(); // TinMan: ( allready defined in idAI )\n"
           "// TinMan: Calculate a route, use getMovePosition to get where bot should go.\n"
           "scriptEvent\tvoid \t\t\tsetMoveToCover();\n"
           "scriptEvent\tvoid \t\t\tsetMoveToEnemy();\n"
           "scriptEvent\tvoid \t\t\tsetMoveOutOfRange( entity ent, float range );\n"
           "scriptEvent\tvoid \t\t\tsetMoveToAttackPosition( entity ent );\n"
           "scriptEvent\tvoid \t\t\tsetMoveWander();\n"
           "scriptEvent\tvoid \t\t\tsetMoveToEntity( entity destination );\n"
           "scriptEvent\tvoid \t\t\tsetMoveToPosition( vector position );\n"
           "\n"
           "// returns true if character can walk to specified position.  for walking monsters, position should be near the floor.\n"
           "scriptEvent float\t\t\tcanReachPosition( vector pos );\n"
           "\n"
           "// returns true if character can walk to entity's position.  for walking monsters, entity should be near the floor.\n"
           "scriptEvent float\t\t\tcanReachEntity( entity ent );\n"
           "\n"
           "// returns true if character can walk to enemy's position.  for walking monsters, enemy should be near the floor.\n"
           "scriptEvent float\t\t\tcanReachEnemy();\n"
           "\n"
           "// returns the position of the entity within the aas if possible, otherwise just the entity position.\n"
           "scriptEvent vector\t\tgetReachableEntityPosition( entity ent );\n"
           "\n"
           "// Note: traveldistance - is approximate becuase it gets travel times between area centers, when the bot is travelling of course it's path is optimised\n"
           "scriptEvent\tfloat\t\t\ttravelDistanceToPoint( vector destination ); // Approximate travel distance to point.\n"
           "scriptEvent\tfloat\t\t\ttravelDistanceToEntity( entity destination ); // Approximate travel distance to entity.\n"
           "scriptEvent\tfloat\t\t\ttravelDistanceBetweenEntities( entity source, entity dest ); // Approximate travel distance between two entities.\n"
           "scriptEvent\tfloat\t\t\ttravelDistanceBetweenPoints( vector source, vector dest ); // Approximate travel distance between two points.\n"
           "\n"
           "scriptEvent\tfloat\ttestMoveToPosition( vector position );\n"
           "\n"
           "scriptEvent entity\t\tgetObstacle(); // gets the obstacle in the character's path\n"
           "scriptEvent vector\t\tpushPointIntoAAS( vector pos ); // tries to push the point into a valid AAS area\n"
           "\n"
           "scriptEvent void\t\t\tnextBestWeapon();\n"
           "\n"
           "// TinMan: The old integration vs independence argument, the proper way would be to integrate the following script events into different classes\n"
           "scriptEvent float\t\t \tgetActorHealth( entity actor ); // TinMan: Could be in actor\n"
           "scriptEvent float\t\t \tgetArmor( entity player ); // TinMan: Could be in player\n"
           "\n"
           "scriptEvent float\t\t \tgetTeam( entity ent ); // TinMan: Could be in actor\n"
           "\n"
           "// TinMan: Direct access to entities array\n"
           "scriptEvent entity \t\tgetEntityByNum( float index );\n"
           "scriptEvent float \t\tgetNumEntities();\n"
           "\n"
           "// TinMan: Could be in entity\n"
           "scriptEvent string \t\tgetClassName( entity ent ); // TinMan: returns classname of entity.\n"
           "scriptEvent string \t\tgetClassType( entity ent ); // TinMan: returns class type of entity.\n"
           "\n"
           "scriptEvent float\t\t\tacos( float a ); // TinMan: Could be in script sys\n"
           "\n"
           "// TinMan: *CTF*\n"
           "scriptEvent entity\t\tgetFlag( float team );\n"
           "scriptEvent float\t\t\tgetFlagStatus( float team );\n"
           "scriptEvent entity\t\tgetFlagCarrier( float team );\n"
           "scriptEvent entity\t\tgetCapturePoint( float team );\n"
           "\n"
           "// TinMan: Plat\n"
           "scriptEvent float\t\t\tisUnderPlat( entity plat );\n"
           "scriptEvent vector\t\tgetWaitPosition( entity plat );\n"
           "\n"
           "scriptEvent float\t\t\tpowerUpActive(); // TinMan: at the moment just returns if any powerups are active *todo* plug it into playerent powerupactive and return which\n";
}

/*******************************************************************************
SABot - Stupid Angry Bot - release alpha 9
"I obey these words, written in my head. I think they are spelled wrong."

bot_sabot_ai
The brains of SABot. Braaaaaiiinnns!
********************************************************************************/
idStr botAi::GetBotSabotScript(void)
{
    return "\n"
           "#define\tSABOT_NEXT_ENEMY_LOOK\t\t\t\t\t\t\t0.2\n"
           "#define\tSABOT_NEXT_GOAL_CHOOSE\t\t\t\t\t\t1\n"
           "#define\tSABOT_NEXT_GOAL_LOOK\t\t\t\t\t\t\t0.3\n"
           "#define\tSABOT_NEXT_AIM\t\t\t\t\t\t\t\t\t\t0 //0.05\n"
           "\n"
           "#define\tSABOT_ENEMY_LOST_TIME\t\t\t\t\t\t\t0.6\n"
           "#define SABOT_SUBGOAL_LOST_TIME\t\t\t\t\t\t3\n"
           "\n"
           "#define SABOT_CHASE_TIME\t\t\t\t\t\t\t\t\t12 // TinMan: Time to chase (out of view) enemy before giving up\n"
           "#define SABOT_HOLD_TIME\t\t\t\t\t\t\t\t\t\t90\n"
           "\n"
           "#define\tSABOT_CHECK_MOVE_DISTANCE\t\t\t\t\t48\n"
           "\n"
           "// TinMan: time between random strafe changes\n"
           "#define\tSABOT_STRAFE_MIN\t\t\t\t\t\t\t\t\t1\n"
           "#define\tSABOT_STRAFE_MAX\t\t\t\t\t\t\t\t\t3\n"
           "\n"
           "// TinMan: Distances for following\n"
           "#define SABOT_FOLLOWDIST_MAX\t\t\t\t\t\t\t140\n"
           "#define SABOT_FOLLOWDIST_MIN\t\t\t\t\t\t\t100\n"
           "\n"
           "#define SABOT_GOAL_NONE\t\t\t\t\t\t\t\t\t\t\t0\n"
           "#define SABOT_GOAL_MOVE\t\t\t\t\t\t\t\t\t\t\t1\n"
           "#define SABOT_GOAL_HOLD\t\t\t\t\t\t\t\t\t\t\t2\n"
           "#define SABOT_GOAL_FOLLOW\t\t\t\t\t\t\t\t\t\t3\n"
           "#define SABOT_GOAL_ATTACK\t\t\t\t\t\t\t\t\t\t4\n"
           "#define SABOT_GOAL_CHASE\t\t\t\t\t\t\t\t\t\t5\n"
           "\n"
           "#define SABOT_ROLE_ROAM\t\t\t\t\t\t\t\t\t\t\t0\n"
           "#define SABOT_ROLE_OFFENCE\t\t\t\t\t\t\t\t\t1\n"
           "#define SABOT_ROLE_DEFENCE\t\t\t\t\t\t\t\t\t2\n"
           "\n"
           "#define SABOT_MOVETYPE_ENTITY\t\t\t\t\t\t\t\t0\n"
           "#define SABOT_MOVETYPE_POSITION\t\t\t\t\t\t\t1\n"
           "\n"
           "#define\tSABOT_ITEMTYPE_NONE\t\t\t\t\t\t\t\t\t0\n"
           "#define\tSABOT_ITEMTYPE_HEALTH\t\t\t\t\t\t\t\t1\n"
           "#define\tSABOT_ITEMTYPE_ARMOR\t\t\t\t\t\t\t\t2\n"
           "#define\tSABOT_ITEMTYPE_WEAPON\t\t\t\t\t\t\t\t3\n"
           "#define\tSABOT_ITEMTYPE_AMMO\t\t\t\t\t\t\t\t\t4\n"
           "#define\tSABOT_ITEMTYPE_POWERUP\t\t\t\t\t\t\t5\n"
           "#define\tSABOT_ITEMTYPE_TEAM\t\t\t\t\t\t\t\t\t6\n"
           "#define\tSABOT_ITEMTYPE_ITEM\t\t\t\t\t\t\t\t\t7\n"
           "\n"
           "object bot_sabot {\n"
           "\t// TinMan: Movement control - script/bot->gamecode/fakeclient - Reset each frame\n"
           "\tboolean\t\tAI_FORWARD;\n"
           "\tboolean\t\tAI_BACKWARD;\n"
           "\tboolean\t\tAI_LEFT;\n"
           "\tboolean\t\tAI_RIGHT;\n"
           "\tboolean\t\tAI_JUMP;\n"
           "\tboolean\t\tAI_CROUCH;\n"
           "\t\n"
           "\tboolean\t\tAI_RUN;\n"
           "\t\n"
           "\t// TinMan: Fire control - script/bot->gamecode/fakeclient - Reset each frame\n"
           "\tboolean\t\tAI_FIRE;\n"
           "\tboolean\t\tAI_RELOAD;\n"
           "\t\n"
           "\t// TinMan: Body status - gamecode/fakeclient->script/bot\n"
           "\tboolean\t\tAI_DEAD;\n"
           "\tboolean\t\tAI_PAIN;\n"
           "\tboolean\t\tAI_ONGROUND;\n"
           "\tboolean\t\tAI_TELEPORT;\n"
           "\t\n"
           "\tboolean\t\tAI_RESPAWN;\n"
           "\n"
           "\t// TinMan: Currently unused\t\n"
           "\tboolean\t\tAI_ATTACK_HELD;\n"
           "\tboolean\t\tAI_WEAPON_FIRED;\n"
           "\n"
           "\t// TinMan: Enemy status - gamecode->script\n"
           "\tboolean\t\tENEMY_VISIBLE;\n"
           "\tboolean\t\tENEMY_IN_FOV;\n"
           "\tboolean\t\tENEMY_DEAD;\n"
           "\t\n"
           "\t// TinMan: Movement status - gamecode->script\n"
           "\tboolean\t\tAI_MOVE_DONE;\n"
           "\tboolean\t\tAI_DEST_UNREACHABLE;\n"
           "\tboolean\t\tAI_BLOCKED;\n"
           "\tboolean\t\tAI_OBSTACLE_IN_PATH;\n"
           "\t\n"
           "\t// TinMan: Currently unused\n"
           "\tboolean\t\tAI_PUSHED;\n"
           "\t\n"
           "\t// TinMan: *todo* shoddy, pull out for q4\n"
           "\tboolean\t\tBOT_COMMAND;\n"
           "\tfloat \t\tBOT_COMMAND_TYPE;\n"
           "\tstring \t\tBOT_COMMAND_ENTITY;\n"
           "\tvector\t\tBOT_COMMAND_VECTOR;\n"
           "\n"
           "\t// TinMan: Globalistics\n"
           "\tstring\t\tme;\n"
           "\tstring\t\tname;\n"
           "\t\n"
           "\tentity\t\tbody;\n"
           "\n"
           "\tentity\t\tweapon;\n"
           "\tstring\t\tcurrentWeapon;\n"
           "\tvector\t\tweaponRange;\n"
           "\tfloat\t\t\tlastWeaponSwitch;\n"
           "\n"
           "\n"
           "\tentity \t\tgoal;\n"
           "\tvector\t\tgoalPosition;\n"
           "\tfloat\t\t\tgoalType;\n"
           "\tfloat\t\t\tgoalPriority;\n"
           "\t\n"
           "\tentity \t\toldGoal;\n"
           "\t\n"
           "\tfloat\t\t\tmoveType;\n"
           "\t\n"
           "\t// TinMan: alternate goal for comparing against current, oh yes the crudeness of script\n"
           "\tentity \t\tnewGoal;\n"
           "\tvector\t\tnewGoalPosition;\n"
           "\tfloat\t\t\tnewMoveType;\n"
           "\tfloat\t\t\tnewGoalType;\n"
           "\tfloat\t\t\tnewGoalPriority;\t\n"
           "\t\n"
           "\tfloat\t\t\trole;\n"
           "\tfloat\t\t\troleDefault;\n"
           "\t\n"
           "\tfloat \t\tteam;\n"
           "\t// TinMan: *CTF*\n"
           "\tentity\t\tourFlag;\n"
           "\tentity\t\ttheirFlag;\n"
           "\tvector\t\tourCap;\n"
           "\tvector\t\ttheirCap;\n"
           "\t\n"
           "\tfloat \t\tgameType;\n"
           "\t\n"
           "\tfloat\t\t\tviewHeight;\n"
           "\tfloat\t\t\tjumpHeight;\n"
           "\t\n"
           "\tfloat\t\t\treact_to_enemy;\n"
           "\tfloat\t\t\treact_to_enemy_sound;\n"
           "\tfloat\t\t\treact_fire;\n"
           "\t\n"
           "\tfloat\t\t\ttimerAmount;\n"
           "\tfloat\t\t\ttimerStart;\n"
           "\tfloat\t\t\ttimerEnd;\n"
           "\t\n"
           "\tvector\t\tlastPosition;\n"
           "\tfloat\t\t\tlastPositionTime;\n"
           "\t\n"
           "\tfloat\t\t\tnextEnemyLookTime;\n"
           "\t\n"
           "\tvector\t\tplatTop;\n"
           "\t\n"
           "\tvoid \t\t\tdebugPrint( string func, string message );\n"
           "\tvoid \t\t\tdebugVis( string func, string message );\n"
           "\n"
           "\t// TinMan: States\n"
           "\tvoid \t\t\tstate_Begin();\n"
           "\tvoid \t\t\tstate_MoveToGoal();\n"
           "\tvoid \t\t\tstate_Combat();\n"
           "\tvoid \t\t\tstate_Chase();\n"
           "\tvoid\t\t\tstate_Retreat();\n"
           "\tvoid\t\t\tstate_Hold();\n"
           "\tvoid\t\t\tstate_Follow();\n"
           "\tvoid \t\t\tstate_Killed();\n"
           "\n"
           "\t// TinMan: Functions\n"
           "\tvoid \t\t\tsetNewGoal();\n"
           "\tvoid\t\t\tclearGoal();\n"
           "\tvoid\t\t\tclearNewGoal();\n"
           "\t\n"
           "\tvoid \t\t\tmoveForward();\n"
           "\tvoid \t\t\tmoveBackward();\n"
           "\tvoid \t\t\tmoveRight();\n"
           "\tvoid \t\t\tmoveLeft();\n"
           "\t\n"
           "\tvector \t\tmoveAction();\n"
           "\n"
           "\tvoid \t\t\tsetTimer( float endTime );\n"
           "\tfloat \t\tgetTimer();\n"
           "\tvoid \t\t\tclearTimer();\n"
           "\tboolean\t\tnextEnemyLook();\n"
           "\n"
           "\tboolean \tcheckGoal();\n"
           "\tboolean\t\tgotFlag();\n"
           "\t\n"
           "\tboolean \tcheckSelf();\n"
           "\tboolean \tcheckLeader( entity thisLeader );\n"
           "\tboolean\t\tcheckWeapon();\n"
           "\n"
           "\tboolean \tcheckStrafeLeft();\n"
           "\tboolean \tcheckStrafeRight();\n"
           "\tboolean \tcheckMoveForward();\n"
           "\tboolean \tcheckMoveBack();\n"
           "\tfloat\t\t \tcheckMoves();\n"
           "\t\n"
           "\tboolean \tcheckBlocked();\n"
           "\n"
           "\tboolean \tcheckShot( boolean simple );\n"
           "\tboolean \tcheckAimedShot( vector aimDir, float range );\n"
           "\t\n"
           "\tvoid \t\t\tchooseWeapon( float range );\n"
           "\n"
           "\tvector\t\tpredictTargetPosition( vector targetPosition, vector myPosition, vector targetVelocity );\n"
           "\tvector \t\taddAimVariation( vector aimDir );\n"
           "\n"
           "\tfloat \t\tgetItemPriority( entity item );\n"
           "\tfloat \t\tgetPlayerPriority( entity badass );\n"
           "\n"
           "\tentity \t\tchooseGoal();\n"
           "\tentity \t\tlookForGoal( float useFov );\n"
           "\tentity \t\tlookForEnemies( float useFov );\n"
           "\tentity\t\tlistenForEnemies();\n"
           "\t\n"
           "\tvoid\t\t\tupdateTeam();\n"
           "\tboolean \tisCTF();\n"
           "};\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::init\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::init() {\n"
           "\tme\t\t= getName();\n"
           "\tname \t=\tgetKey( \"npc_name\" );\n"
           "\t\n"
           "\tbody \t= getBody(); // TinMan: Grab fakeclient entity.\n"
           "\t\n"
           "\t// TinMan: Grab your keys please\n"
           "\tviewHeight = body.getFloatKey( \"pm_normalviewheight\" );\n"
           "\tjumpHeight = body.getFloatKey( \"pm_jumpheight\" );\n"
           "\t\n"
           "\treact_to_enemy\t\t\t\t= getFloatKey( \"react_to_enemy\" );\n"
           "\treact_to_enemy_sound\t= getFloatKey( \"react_to_enemy_sound\" );\n"
           "\treact_fire\t\t\t\t\t\t= getFloatKey( \"react_fire\" );\n"
           "\t\n"
           "\troleDefault = SABOT_ROLE_ROAM;\n"
           "\t\n"
           "\tclearTimer();\n"
           "\t\n"
           "\tteam = -1; // TinMan: set to non team value so updateTeam picks it up\n"
           "\t\n"
           "\tsetState( \"state_Begin\" );\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::destroy\n"
           "TinMan: Clean up stuff for when script is killed.\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::destroy() {\n"
           "\twaitFrame();\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::debugPrint\n"
           "TinMan: Sommat a leetle cleaner, lets you have more control over what bots are spamming out debug. For great justice!\n"
           "*todo* is there a easy way to grab the name of the func from script?\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::debugPrint( string func, string message ) {\n"
           "\tstring text;\n"
           "\tif ( getIntKey( \"debug\" ) ) {\n"
           "\t\ttext = \"[\" + int( sys.getTime() ) + \"][\" + me + \"]\";\n"
           "\t\tif ( func ) {\n"
           "\t\t\ttext = text + \"[\" + func + \"]\";\n"
           "\t\t}\n"
           "\t\tif ( message ) {\n"
           "\t\t\ttext = text + \"[\" + message + \"]\";\n"
           "\t\t}\n"
           "\n"
           "\t\tsys.println( text );\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::debugVis\n"
           "TinMan: Do debug visuals. Don't trip up trying to read the text above your head.\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::debugVis( string func, string message ) {\n"
           "\tstring text;\n"
           "\t\n"
           "\tif ( getIntKey( \"debug\" ) ) {\n"
           "\t\ttext \t= func + \"\\n\" \n"
           "\t\t\t\t  + message + \"\\n\";\n"
           "\t\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][\" + func + \"][\" + message + \"]\" );\n"
           "\t\t// TinMan: *todo* DEFINE some colours\n"
           "\t\tvector org = body.getOrigin();\n"
           "\t\torg_z += 72;\n"
           "\t\t//sys.drawText( string text, vector origin, float scale, vector color, float align, float lifetime );\n"
           "\t\tsys.drawText( text, org, 0.24, '1 1 1', 1, 0 ); // scale 0.12\n"
           "\t}\n"
           "}\n"
           "\n"
           "/***********************************************************************\n"
           "\n"
           "\tStates - Main AI\n"
           "\n"
           "***********************************************************************/\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::state_Begin\n"
           "TinMan: Basic setup. Wakey wakey, rise 'n' shine.\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::state_Begin() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Begin]\" ); // TinMan *debug*\n"
           "\t\n"
           "\twhile( AI_RESPAWN ) {\n"
           "\t\twaitFrame();\n"
           "\t}\n"
           "\t\n"
           "\tweapon = body.getWeaponEntity();\n"
           "\n"
           "\tcheckWeapon(); // TinMan: Update our weapon vars (currentweapon, weaponrange)\n"
           "\t\n"
           "\tAI_RUN = true;\n"
           "\t\n"
           "\tclearGoal();\n"
           "\t\n"
           "\tclearEnemy();\n"
           "\t\n"
           "\trole = roleDefault;\n"
           "\t\n"
           "\tgameType = getGameType(); // TinMan: *todo* see if gametype change restarts map (and bot), on brief look it does\n"
           "\t\n"
           "\tupdateTeam();\n"
           "\t\n"
           "\tsetState( \"state_Idle\" );\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::state_Idle\n"
           "TinMan: Default fallback state \n"
           "*todo* With the redundancy I'm getting with aiming/firing, shortgoal/enemy over movetogoal/combat I'm thinking may hauling those here and not trapping in the state would be better.\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::state_Idle() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Idle]\" ); // TinMan *debug*\n"
           "\tfloat nextGoalChoose;\n"
           "\tfloat reactToEnemy;\n"
           "\tentity newEnemy;\n"
           "\t\n"
           "\tclearNewGoal();\n"
           "\t\n"
           "\teachFrame {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Idle]\" ); // TinMan *debug*\n"
           "\t\t\n"
           "\t\tif ( AI_DEAD || AI_RESPAWN ) {\n"
           "\t\t\tsetState( \"state_Killed\" );\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Choose a role, which is used to decide on a goal. Curses rhyming strikes again! \n"
           "\t\t// *todo* this should be removed in favour of prioritising goals in choosegoal\n"
           "\t\tif ( checkSelf() ) { // TinMan: Bot too beat up to be thinking abount anything\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Idle][checkSelf: not happy]\" ); // TinMan *debug*\n"
           "\t\t\trole = SABOT_ROLE_ROAM;\n"
           "\t\t} else {\n"
           "\t\t\tif ( isCTF() ) {\n"
           "\t\t\t\tif ( role == SABOT_ROLE_ROAM ) {\n"
           "\t\t\t\t\trole = SABOT_ROLE_OFFENCE;\n"
           "\t\t\t\t}\n"
           "\t\t\t\t/*\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Idle][checkSelf: happy]\" ); // TinMan *debug*\n"
           "\t\t\t\t// TinMan: *CTF* Choose a role\n"
           "\t\t\t\tif ( sys.random( 100 ) < 95 ) {\n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Idle][SABOT_ROLE_OFFENCE]\" ); // TinMan *debug*\n"
           "\t\t\t\t\trole = SABOT_ROLE_OFFENCE;\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Idle][SABOT_ROLE_ROAM]\" ); // TinMan *debug*\n"
           "\t\t\t\t\trole = SABOT_ROLE_ROAM;\n"
           "\t\t\t\t}\n"
           "\t\t\t\t*/\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\t\n"
           "\t\tif ( !goal && AI_ONGROUND && sys.getTime() > nextGoalChoose ) {\n"
           "\t\t\tnextGoalChoose = sys.getTime() + SABOT_NEXT_GOAL_CHOOSE;\n"
           "\t\t\tif ( chooseGoal() ) {\n"
           "\t\t\t\tsetNewGoal();\n"
           "\t\t\t}\n"
           "\t\t\tif ( !goal ) {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Idle][Cannot find long range goal]\" ); // TinMan *debug*\n"
           "\t\t\t\tstopMove();\n"
           "\t\t\t\t//waitFrame(); // TinMan: Catch a breather.\n"
           "\t\t\t\t// TinMan: *todo* set up some kind of wander goal/state?\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t//waitFrame(); // TinMan: *todo* just hiding a problem at the moment, there isn't any real reason for a waitframe here\n"
           "\t\t\n"
           "\t\tif ( goal ) {\n"
           "\t\t\tif ( goalType == SABOT_GOAL_MOVE ) {\n"
           "\t\t\t\tsetState( \"state_MoveToGoal\" );\n"
           "\t\t\t} else if ( goalType == SABOT_GOAL_FOLLOW ) {\n"
           "\t\t\t\tsetState( \"state_Follow\" );\n"
           "\t\t\t} else if ( goalType == SABOT_GOAL_HOLD ) {\n"
           "\t\t\t\tsetState( \"state_Hold\" );\n"
           "\t\t\t}\telse if ( goalType == SABOT_GOAL_ATTACK ) {\n"
           "\t\t\t\tsetState( \"state_Combat\" );\n"
           "\t\t\t} else if ( goalType == SABOT_GOAL_NONE ) {\n"
           "\t\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Idle][!No goalType!]\" ); // TinMan *debug*\n"
           "\t\t\t} else {\n"
           "\t\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Idle][!Unknown goalType!]\" ); // TinMan *debug*\n"
           "\t\t\t}\n"
           "\t\t} else { // TinMan: no goal, just look for trouble *todo* something else \n"
           "\t\t\t// TinMan: in case outside aas, push point and move towards\n"
           "\t\t\tvector bodyOrigin, pushPosition, moveDir;\n"
           "\t\t\tbodyOrigin = body.getOrigin();\n"
           "\t\t\tpushPosition = pushPointIntoAAS( bodyOrigin );\n"
           "\t\t\tif ( pushPosition != bodyOrigin ) {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Idle][pushpos != bodyOrigin]\" ); // TinMan *debug*\n"
           "\t\t\t\tmoveDir = pushPosition - bodyOrigin;\n"
           "\t\t\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\t/*\n"
           "\t\t\t// TinMan: Just wander\n"
           "\t\t\tsetMoveWander();\n"
           "\t\t\tvector movePosition = moveAction();\n"
           "\t\t\tvector aimDir = movePosition - body.getOrigin();\n"
           "\t\t\tsetAimDirection( aimDir );\n"
           "\t\t\t\n"
           "\t\t\tcheckBlocked();\n"
           "\t\t\t*/\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: *todo* create a wander state for !goal - flip to idle after certian time to see if new goal\n"
           "\t\t\tif ( !reactToEnemy ) {\n"
           "\t\t\t\tif ( nextEnemyLook() || AI_PAIN || ENEMY_VISIBLE ) {\n"
           "\t\t\t\t\tif ( ENEMY_VISIBLE ) {\n"
           "\t\t\t\t\t\treactToEnemy = sys.getTime() + react_to_enemy; // TinMan: Set react timer.\n"
           "\t\t\t\t\t} else {\n"
           "\t\t\t\t\t\tnewEnemy = lookForEnemies( true );\n"
           "\t\t\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\t\t\treactToEnemy = sys.getTime() + react_to_enemy; // TinMan: Set react timer.\n"
           "\t\t\t\t\t\t} else {\n"
           "\t\t\t\t\t\t\t// TinMan: Shh, I hear something.\n"
           "\t\t\t\t\t\t\tnewEnemy = listenForEnemies();\n"
           "\t\t\t\t\t\t\tif ( !newEnemy && AI_PAIN ) { // TinMan: *cheaphack* work around due to fack heardsound is being shoehorned into something it's not desiged to handle - multiple players\n"
           "\t\t\t\t\t\t\t\tnewEnemy = lookForEnemies( false );\n"
           "\t\t\t\t\t\t\t}\n"
           "\t\t\t\t\t\t\tif ( newEnemy ) {\n"
           "\t\t\t\t\t\t\t\treactToEnemy = sys.getTime() + react_to_enemy_sound; // TinMan: Set react timer.\n"
           "\t\t\t\t\t\t\t}\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t} else if ( reactToEnemy < sys.getTime() ) { // TinMan: ok we're allowed to react to the enemy we saw ages ago due to our ninja bot skillz\n"
           "\t\t\t\tsetEnemy( newEnemy );\n"
           "\t\t\t\tsetState( \"state_Combat\" );\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::state_MoveToGoal\n"
           "TinMan: Only interested in moving here, ie grabbing item.\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::state_MoveToGoal() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_MoveToGoal]\" ); // TinMan *debug*\n"
           "\tvector movePosition, secondaryPosition;\n"
           "\tvector aimPosition, aimDir;\n"
           "\tfloat aimTarget;\n"
           "\tfloat nextGoalLook;\n"
           "\tfloat weaponRangeBuffer;\n"
           "\tfloat enemyLostTime;\n"
           "\tfloat nextAimTime;\n"
           "\tfloat reactToEnemy;\n"
           "\tfloat reactFire, fire;\n"
           "\tfloat lastVisibleEnemyDist;\n"
           "\tvector lastVisibleEnemyPos;\n"
           "\tentity enemy, newEnemy;\n"
           "\n"
           "\tweaponRangeBuffer = sys.random( 16 ) + 16; // TinMan: *todo* rethink\n"
           "\n"
           "\tif ( goal ) {\n"
           "\t\tif ( moveType == SABOT_MOVETYPE_ENTITY ) {\n"
           "\t\t\tsetMoveToEntity( goal );\n"
           "\t\t} else {\n"
           "\t\t\t//debugPrint( \"state_MoveToGoal\", \"goalPosition: \" + goalPosition + \"][goal: \" + goal.getName() );\n"
           "\t\t\t//sys.debugBounds( '1 1 1', goalPosition + '-1 -1 -1', goalPosition + '1 1 1' , 1 ); // TinMan: *debug*\n"
           "\t\t\tsetMoveToPosition( goalPosition );\n"
           "\t\t}\n"
           "\t}\n"
           "\t\n"
           "\teachFrame {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_MoveToGoal][goal: \" + goal.getName() + \"]\" ); // TinMan *debug*\n"
           "\t\t//debugPrint( \"state_MoveToGoal\", goalPriority );\n"
           "\t\t//debugVis( \"state_MoveToGoal\", goal.getName() );\n"
           "\t\t\n"
           "\t\tif ( AI_DEAD || AI_RESPAWN ) {\n"
           "\t\t\tsetState( \"state_Killed\" );\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: *todo* split\n"
           "\t\t// TinMan: Look for new goals. The shinier the better.\n"
           "\t\tif ( sys.getTime() > nextGoalLook ) {\n"
           "\t\t\tnextGoalLook = sys.getTime() + SABOT_NEXT_GOAL_LOOK;\n"
           "\t\t\tlookForGoal( true ); // TinMan: Will set newGoal. More important than it might seem, here is the ultimate decision whether to discard current goal (via a higher priority), which may be something set by chooseGoal, and something as important as capping flag.\n"
           "\t\t\t// TinMan: If pretty new thing better than current plaything.\n"
           "\t\t\tif ( newGoal ) {\n"
           "\t\t\t\tif ( newGoal != goal ) {\n"
           "\t\t\t\t\tif ( newGoalPriority > goalPriority ) {\n"
           "\t\t\t\t\t\tsetNewGoal();\n"
           "\t\t\t\t\t\tbreak;\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Lookin for trouble with a big T.\n"
           "\t\tif ( !reactToEnemy ) {\n"
           "\t\t\tif ( nextEnemyLook() || AI_PAIN || ENEMY_VISIBLE ) {\n"
           "\t\t\t\tif ( ENEMY_VISIBLE ) {\n"
           "\t\t\t\t\treactToEnemy = sys.getTime() + react_to_enemy; // TinMan: Current enemy back in view. Set react timer.\n"
           "\t\t\t\t\tnewEnemy = getEnemy(); // TinMan: *todo* seems a bit of a cludge, but whatever\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\tnewEnemy = lookForEnemies( true );\n"
           "\t\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\t\treactToEnemy = sys.getTime() + react_to_enemy; // TinMan: Set react timer.\n"
           "\t\t\t\t\t} else {\n"
           "\t\t\t\t\t\t// TinMan: Shh, I hear something.\n"
           "\t\t\t\t\t\tnewEnemy = listenForEnemies();\n"
           "\t\t\t\t\t\tif ( !newEnemy && AI_PAIN ) { // TinMan: *cheaphack* work around due to fact heardsound is being shoehorned into something it's not desiged to handle - multiple enemies\n"
           "\t\t\t\t\t\t\tnewEnemy = lookForEnemies( false );\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t\tif ( newEnemy ) {\n"
           "\t\t\t\t\t\t\treactToEnemy = sys.getTime() + react_to_enemy_sound; // TinMan: Set react timer.\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t} else if ( reactToEnemy < sys.getTime() ) { // TinMan: ok we're allowed to react to the enemy we saw ages ago due to our ninja bot skillz\n"
           "\t\t\treactToEnemy = 0;\n"
           "\t\t\tif ( newEnemy != getEnemy() ) {\n"
           "\t\t\t\tsetEnemy( newEnemy );\n"
           "\t\t\t\tnewGoalPriority = getPlayerPriority( newEnemy );\n"
           "\t\t\t\tif ( newGoalPriority > goalPriority ) {\n"
           "\t\t\t\t\tnewGoal = newEnemy;\n"
           "\t\t\t\t\tnewGoalType = SABOT_GOAL_ATTACK;\n"
           "\t\t\t\t\tsetNewGoal();\n"
           "\t\t\t\t\tsetState( \"state_Combat\" );\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tcheckWeapon(); // TinMan: Make sure your weapon is nice and shiny\n"
           "\t\t// TinMan: *todo* end split\n"
           "\t\t\n"
           "\t\t// TinMan: Move along given path\n"
           "\t\tmovePosition = moveAction();\n"
           "\t\t\n"
           "\t\tcheckBlocked();\n"
           "\t\t\n"
           "\t\tif ( getEnemy() ) { // TinMan: *todo* look through and overhaul looking at enemy/fighting\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_MoveToGoal][lVisEnyPos: \" + lastVisibleEnemyPos + \"][lVisEnDist:\" + lastVisibleEnemyDist + \"]\" ); // TinMan: *debug*\n"
           "\t\t\tif ( !ENEMY_DEAD ) {\n"
           "\t\t\t\tlastVisibleEnemyPos = getEnemyPos();\n"
           "\t\t\t\tlastVisibleEnemyPos_z += viewHeight; // TinMan: cheap hack pos off ground since we'll be aiming at it when enemy dead\n"
           "\t\t\t\tlastVisibleEnemyDist = enemyRange();\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: Aim at enemy\n"
           "\t\t\tif ( nextAimTime < sys.getTime() ) { // TinMan: Roughen up aiming a bit\n"
           "\t\t\t\tnextAimTime = sys.getTime() + SABOT_NEXT_AIM;\n"
           "\t\t\t\tif ( ENEMY_VISIBLE ) {\n"
           "\t\t\t\t\tenemy = getEnemy();\t\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t\taimTarget = getIntKey( \"target_\" + currentWeapon );\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t\taimDir = getAimDir( getEnemy(), aimTarget ); // TinMan: new choose a point on enemy, and predict shot\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t\taimDir = addAimVariation( aimDir ); // TinMan: Screw up aim cause I'm mean.\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t\tsetAimDirection( aimDir ); // TinMan: Finally set our target to aim to.\n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][aimPosition = \" + aimPosition_x + \" \" + aimPosition_y + \" \" +aimPosition_z + \"]\" ); // TinMan: *debug*\n"
           "\t\t\t\t} else { // TinMan: Aim at teh dedders\n"
           "\t\t\t\t\tif ( /* AI_ONGROUND && */ movePosition != body.getOrigin() ) {\n"
           "\t\t\t\t\t\taimDir = lastVisibleEnemyPos - getViewPosition();\n"
           "\t\t\t\t\t\tsetAimDirection( aimDir );\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: Check shot is within weapon range. AND SMITE HIM!\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][CurrentWeapon: \" + currentWeapon + \"][Weaponrange]\" ); // TinMan: *debug*\n"
           "\t\t\tif ( /* *off* *test* ( lastVisibleEnemyDist > weaponRange_y ) && */ ( lastVisibleEnemyDist < weaponRange_z ) )\t{\n"
           "\t\t\t\t// TinMan: See if any enemies in shot.\n"
           "\t\t\t\tif ( !reactFire ) { // TinMan: Allready going to fire\n"
           "\t\t\t\t\tif ( checkShot( false ) ) { // TinMan: See if enemy in straight bounds trace.\n"
           "\t\t\t\t\t\treactFire = sys.getTime() + react_fire;\n"
           "\t\t\t\t\t} else if ( checkShot( true ) ) { // TinMan: See if enemy in straight point trace.\n"
           "\t\t\t\t\t\treactFire = sys.getTime() + react_fire;\n"
           "\t\t\t\t\t} else if ( checkAimedShot( aimDir, lastVisibleEnemyDist ) ) { // TinMan: See if we are aimed at position and shot will make it.\n"
           "\t\t\t\t\t\treactFire = sys.getTime() + react_fire;\n"
           "\t\t\t\t\t} else {\n"
           "\t\t\t\t\t\treactFire = 0;\n"
           "\t\t\t\t\t\tfire = false;\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\telse { // TinMan: Aw, out of weapon range.\n"
           "\t\t\t\treactFire = 0;\n"
           "\t\t\t\tfire = false;\n"
           "\t\t\t}\n"
           "\t\n"
           "\t\t\tif ( reactFire != 0 ) {\n"
           "\t\t\t\tif ( reactFire < sys.getTime() ) {\n"
           "\t\t\t\t\tfire = true; // TinMan: Ratatat tat, boom, fwoosh!\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\tif ( fire && ( enemyLostTime < 0.2 || ENEMY_DEAD ) ) { // TinMan: *cheaphack* The delayed fire is working out quite nicely at the moment except leads to the bot shooting into walls too much.\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_MoveToGoal][firing!]\" ); // TinMan: *debug*\n"
           "\t\t\t\tAI_FIRE = true;\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\t// TinMan: Lookee where we damn be going.\n"
           "\t\t\tif ( /* AI_ONGROUND && */ movePosition != body.getOrigin() ) { // TinMan: *cheaphack* stop bot from looking down when movepos = body.org\n"
           "\t\t\t\taimDir = movePosition - body.getOrigin();\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_MoveToGoal][aimdir: \" + aimDir + \"]\" ); // TinMan: *debug*\n"
           "\t\t\t\tsetAimDirection( aimDir );\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Wherizy?\n"
           "\t\tif ( !ENEMY_VISIBLE ) {\n"
           "\t\t\tif ( enemyLostTime == 0 ) {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_MoveToGoal][start lost timer]\" ); // TinMan: *debug*\n"
           "\t\t\t\tenemyLostTime = RandomDelay( SABOT_ENEMY_LOST_TIME, SABOT_ENEMY_LOST_TIME + 0.5 );\n"
           "\t\t\t} else if ( enemyLostTime < sys.getTime() ) {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_MoveToGoal][lost]\" ); // TinMan: *debug*\n"
           "\t\t\t\t//setState( \"state_Chase\" );\n"
           "\t\t\t\tclearEnemy();\n"
           "\t\t\t}\n"
           "\t\t} else if ( ENEMY_VISIBLE ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_MoveToGoal][reset lost timer]\" ); // TinMan: *debug*\n"
           "\t\t\tenemyLostTime = 0; // TinMan: Can see enemy again, so stop timer\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: See if we should still go for goal.\n"
           "\t\tif ( checkGoal() ) {\n"
           "\t\t\tclearGoal();\n"
           "\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tif ( AI_MOVE_DONE ) {\n"
           "\t\t\t//debugPrint( \"state_MoveToGoal\", \"AI_MOVE_DONE][\" + goal.getName() + \":\" + goalPriority ); // TinMan: *debug*\n"
           "\t\t\tclearGoal();\n"
           "\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t}\n"
           "\t\tif ( AI_DEST_UNREACHABLE && AI_ONGROUND ) { // TinMan: *todo* Hmm, disabling this is probably a \"bad thing\"\n"
           "\t\t\tdebugPrint( \"state_MoveToGoal\", \"UNREACHABLE][\" + goal.getName() + \":\" + goalPriority ); // TinMan: *debug*\n"
           "\t\t\tclearGoal();\n"
           "\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t//goalPriority = getItemPriority( goal ); // TinMan: Update goal priority\n"
           "\t\t\n"
           "\t} // TinMan: End eachFrame/state\n"
           "\t\n"
           "\t// TinMan: *cheaphack* Because of the reaction delay between seen enemy and set enemy I need to catch it from falling through the crack here. But it just shows what a shambles the reaction system is.\n"
           "\tif ( newEnemy ) {\n"
           "\t\tsetEnemy( newEnemy );\n"
           "\t}\n"
           "\t\n"
           "\t//debugPrint( \"state_MoveToGoal\", \"Exit state\" ); // TinMan: *debug*\n"
           "\t// TinMan: Exit state\n"
           "\tsetState( \"state_Idle\" );\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::state_Combat\n"
           "TinMan: Direct combat with enemy. Strike him down!\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::state_Combat() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Combat]\" ); // TinMan: *debug*\n"
           "\t\n"
           "\tfloat aimTarget;\n"
           "\tfloat weaponRangeBuffer;\n"
           "\tfloat nextAimTime;\n"
           "\tfloat nextGoalLook;\n"
           "\tfloat enemyLostTime;\n"
           "\tfloat fire, forwards, back, left, right;\n"
           "\tfloat nextStrafeTime;\n"
           "\tfloat moveFlags;\n"
           "\tfloat reactToEnemy, reactFire;\n"
           "\tfloat dist;\n"
           "\tfloat lastVisibleEnemyDist;\n"
           "\tfloat checkTime;\n"
           "\tvector lastVisibleEnemyPos;\n"
           "\tvector aimDir, aimPosition;\n"
           "\tentity enemy, newEnemy;\n"
           "\t\n"
           "\tif ( !getEnemy() ) {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Combat][!enemy]\" ); // TinMan: *debug*\n"
           "\t\tclearGoal();\n"
           "\t\tsetState( \"state_Idle\" );\n"
           "\t}\n"
           "\t\n"
           "\treactToEnemy = false;\n"
           "\tenemyLostTime = 0;\n"
           "\t\n"
           "\tenemy = getEnemy();\n"
           "\n"
           "\tsetMoveToEnemy();\n"
           "\t// TinMan: Flip out straight away if you can't do move. *todo* move to attack position instead\n"
           "\t/*\n"
           "\tif ( AI_DEST_UNREACHABLE ) {\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][Start:Cannot move to enemy!]\" ); // TinMan: *debug*\n"
           "\t\tsetState( \"state_Idle\" );\n"
           "\t}\n"
           "\t*/\n"
           "\n"
           "\teachFrame {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Combat]\" ); // TinMan: *debug*\n"
           "\t\t//debugVis( \"state_Combat\", goal.getName() );\n"
           "\t\t\n"
           "\t\tif ( AI_DEAD || AI_RESPAWN ) {\n"
           "\t\t\tsetState( \"state_Killed\" );\n"
           "\t\t}\n"
           "\n"
           "\t\t\n"
           "\t\tweaponRangeBuffer = sys.random( 16 ) + 16; // TinMan: *todo* rethink\n"
           "\t\t\n"
           "\t\t// TinMan: *todo* split\n"
           "\t\t// TinMan: Look for new goals. The shinier the better.\n"
           "\t\tif ( sys.getTime() > nextGoalLook ) {\n"
           "\t\t\tnextGoalLook = sys.getTime() + SABOT_NEXT_GOAL_LOOK;\n"
           "\t\t\tlookForGoal( true ); // TinMan: Will set newGoal. More important than it might seem, here is the ultimate decision whether to discard current goal (via a higher priority), which may be something set by chooseGoal, and something as important as capping flag.\n"
           "\t\t\t// TinMan: If pretty new thing better than current plaything.\n"
           "\t\t\tif ( newGoal ) {\n"
           "\t\t\t\tif ( newGoal != goal ) {\n"
           "\t\t\t\t\tif ( newGoalPriority > goalPriority ) {\n"
           "\t\t\t\t\t\tsetNewGoal();\n"
           "\t\t\t\t\t\tbreak;\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Lookin for trouble with a big T.\n"
           "\t\tif ( !reactToEnemy ) {\n"
           "\t\t\tif ( nextEnemyLook() ) {\n"
           "\t\t\t\tif ( ENEMY_VISIBLE ) {\n"
           "\t\t\t\t\treactToEnemy = sys.getTime() + react_to_enemy; // TinMan: Current enemy back in view. Set react timer.\n"
           "\t\t\t\t\tnewEnemy = getEnemy(); // TinMan: *todo* seems a bit of a cludge, but whatever\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\tnewEnemy = lookForEnemies( true );\n"
           "\t\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\t\treactToEnemy = sys.getTime() + react_to_enemy; // TinMan: Set react timer.\n"
           "\t\t\t\t\t} else {\n"
           "\t\t\t\t\t\t// TinMan: Shh, I hear something.\n"
           "\t\t\t\t\t\tnewEnemy = listenForEnemies();\n"
           "\t\t\t\t\t\tif ( !newEnemy && AI_PAIN ) { // TinMan: *cheaphack* work around due to fact heardsound is being shoehorned into something it's not desiged to handle - multiple enemies\n"
           "\t\t\t\t\t\t\tnewEnemy = lookForEnemies( false );\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t\tif ( newEnemy ) {\n"
           "\t\t\t\t\t\t\treactToEnemy = sys.getTime() + react_to_enemy_sound; // TinMan: Set react timer.\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t} else if ( reactToEnemy < sys.getTime() ) { // TinMan: ok we're allowed to react to the enemy we saw ages ago due to our ninja bot skillz\n"
           "\t\t\treactToEnemy = 0;\n"
           "\t\t\tif ( newEnemy != getEnemy() ) {\n"
           "\t\t\t\tsetEnemy( newEnemy );\n"
           "\t\t\t\tnewGoalPriority = getPlayerPriority( newEnemy );\n"
           "\t\t\t\tif ( newGoalPriority > goalPriority ) {\n"
           "\t\t\t\t\tnewGoal = newEnemy;\n"
           "\t\t\t\t\tnewGoalType = SABOT_GOAL_ATTACK;\n"
           "\t\t\t\t\tsetNewGoal();\n"
           "\t\t\t\t\tsetState( \"state_Combat\" );\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tif ( getEnemy() ) {\n"
           "\t\t\tgoalPriority = getPlayerPriority( getEnemy() ); // TinMan: Update goal/enemy priority\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Check to see if enemy died, and set some reaction time\n"
           "\t\tif ( ENEMY_DEAD || !getEnemy() ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"[state_Combat][no enemy]\" ); // TinMan *debug*\n"
           "\t\t\tif ( timerEnd == -1 ) {\n"
           "\t\t\t\tsetMoveToPosition( lastVisibleEnemyPos );\n"
           "\t\t\t\tsetTimer( 0.3 );\n"
           "\t\t\t} else if ( getTimer() ) {\n"
           "\t\t\t\tclearTimer();\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"[state_Combat][no enemy]\" ); // TinMan *debug*\n"
           "\t\t\t\tclearGoal();\n"
           "\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tlastVisibleEnemyPos = getEnemyPos();\n"
           "\t\t\tlastVisibleEnemyPos_z += viewHeight; // TinMan: cheap hack pos off ground since we'll be aiming at it when enemy dead\n"
           "\t\t\tlastVisibleEnemyDist = enemyRange();\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Combat][lVisEnyPos: \" + lastVisibleEnemyPos + \"][lVisEnDist:\" + lastVisibleEnemyDist + \"]\" ); // TinMan: *debug*\n"
           "\t\t\n"
           "\t\t/* if ( getEnemy() ) {\n"
           "\t\t\tentity en = getEnemy();\n"
           "\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][lastvisenemyDist: \" + lastVisibleEnemyDist + \"][enemydist: \" + sys.vecLength( body.getOrigin() - en.getOrigin() ) + \"]\" ); // TinMan: *debug*\n"
           "\t\t} */\n"
           "\t\t\n"
           "\t\t// TinMan: The enemy might move to an unreachable spot, wall edge, or be midair, so we need to reset move *todo* Ideally we want to do a movetoattackposition\n"
           "\t\tif ( ( AI_DEST_UNREACHABLE || AI_MOVE_DONE ) && AI_ONGROUND ) {\n"
           "\t\t\t//debugVis( \"state_Combat\", \"DEST_UNREACH || MOVE_DONE\" );\n"
           "\t\t\tif ( ENEMY_DEAD ) { // TinMan: *cheaphack*\n"
           "\t\t\t\tclearGoal();\n"
           "\t\t\t\tbreak; // TinMan: Exit state\t\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\tif ( checkTime < sys.getTime() ) {\n"
           "\t\t\t\tif ( getEnemy() ) {\n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][reset move to enemy!]\" ); // TinMan: *debug*\n"
           "\t\t\t\t\tcheckTime = sys.getTime() + 0.3;\n"
           "\t\t\t\t\tif ( AI_MOVE_DONE ) { // TinMan: at last reachable enemy pos\n"
           "\t\t\t\t\t\tlocateEnemy(); // TinMan: force update\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t\tsetMoveToEnemy();\n"
           "\t\t\t\t\t//setMoveToAttackPosition( getEnemy() );\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t/* TinMan: *todo* NGS rejigger\n"
           "\t\t// TinMan: See if we even want to be fighting - if enemy too badass or too beatup\n"
           "\t\tif ( checkSelf() ) { \n"
           "\t\t\t//if ( sys.random( 100 ) < 40 ) { // TinMan: *todo* demagic, set a limit/timer\n"
           "\t\t\t\t//if ( body.distanceTo( getEnemy() ) > 128 ) {\n"
           "\t\t\t\t\twaitFrame();\n"
           "\t\t\t\t\tsetState( \"state_Retreat\" );\n"
           "\t\t\t\t//}\n"
           "\t\t\t//}\n"
           "\t\t}\n"
           "\t\t*/\n"
           "\n"
           "\t\t// TinMan: Aim at enemy\n"
           "\t\tif ( nextAimTime < sys.getTime() ) { // TinMan: Roughen up aiming a bit\n"
           "\t\t\tnextAimTime = sys.getTime() + SABOT_NEXT_AIM;\n"
           "\t\t\tif ( !ENEMY_DEAD ) {\n"
           "\t\t\t\taimTarget = getIntKey( \"target_\" + currentWeapon );\n"
           "\n"
           "\t\t\t\taimDir = getAimDir( getEnemy(), aimTarget ); // TinMan: new choose a point on enemy, and predict shot\n"
           "\t\t\t\t\n"
           "\t\t\t\taimDir = addAimVariation( aimDir ); // TinMan: Screw up aim cause I'm mean.\n"
           "\t\t\t\t\t\t\t\t\n"
           "\t\t\t\tsetAimDirection( aimDir ); // TinMan: Finally set our target to aim to.\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][aimDir = \" + aimDir_x + \" \" + aimDir_y + \" \" +aimDir_z + \"]\" ); // TinMan: *debug*\n"
           "\t\t\t} else { // TinMan: Aim at teh dedders\n"
           "\t\t\t\taimDir = lastVisibleEnemyPos - getViewPosition();\n"
           "\t\t\t\tsetAimDirection( aimDir );\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\n"
           "\t\t// TinMan: Check shot is within weapon range. AND SMITE HIM!\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][CurrentWeapon: \" + currentWeapon + \"][Weaponrange]\" ); // TinMan: *debug*\n"
           "\t\tif ( /* *off* *test* ( lastVisibleEnemyDist > weaponRange_y ) && */ ( lastVisibleEnemyDist < weaponRange_z ) )\t{\n"
           "\t\t\t// TinMan: See if any enemies in shot.\n"
           "\t\t\tif ( !reactFire ) { // TinMan: Allready going to fire\n"
           "\t\t\t\tif ( checkShot( false ) ) { // TinMan: See if enemy in straight bounds trace.\n"
           "\t\t\t\t\treactFire = sys.getTime() + react_fire;\n"
           "\t\t\t\t} else if ( checkShot( true ) ) { // TinMan: See if enemy in straight point trace.\n"
           "\t\t\t\t\treactFire = sys.getTime() + react_fire;\n"
           "\t\t\t\t} else if ( checkAimedShot( aimDir, lastVisibleEnemyDist ) ) { // TinMan: See if we are aimed at position and shot will make it.\n"
           "\t\t\t\t\treactFire = sys.getTime() + react_fire;\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\treactFire = 0;\n"
           "\t\t\t\t\tfire = false;\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\telse { // TinMan: Aw, out of weapon range.\n"
           "\t\t\treactFire = 0;\n"
           "\t\t\tfire = false;\n"
           "\t\t}\n"
           "\n"
           "\t\tif ( reactFire != 0 ) {\n"
           "\t\t\tif ( reactFire < sys.getTime() ) {\n"
           "\t\t\t\tfire = true; // TinMan: Ratatat tat, boom, fwoosh!\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tif ( fire && ( enemyLostTime < 0.2 || ENEMY_DEAD ) ) { // TinMan: *cheaphack* The delayed fire is working out quite nicely at the moment except leads to the bot shooting into walls too much. *todo* we should really be stopping firing after a delay like the starting fire does.\n"
           "\t\t\tAI_FIRE = true;\n"
           "\t\t}\n"
           "\n"
           "\t\t// TinMan: Move closer/ retreat/ strafe.. to get to weapon sweet spot\n"
           "\t\tif ( lastVisibleEnemyDist > ( weaponRange_x + weaponRangeBuffer ) ) { // TinMan *todo* rejigger to lastenpos\n"
           "\t\t\t// TinMan: Closer than weaponRange\n"
           "\t\t\t//if ( ENEMY_VISIBLE ) {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][Moving to sweet spot: \" + weaponRange_x + \"]\" ); // TinMan: *debug*\n"
           "\t\t\t\t//if ( travelDistanceToPoint( lastVisibleEnemyPos ) < 600 || lastVisibleEnemyDist >= weaponRange_z ) { // TinMan: *todo* remove travdist check once better solution implemented\n"
           "\t\t\t\t\t// TinMan: *todo* old skoolas *rem*\n"
           "\t\t\t\t\t//if ( checkMoveForward() ) {\n"
           "\t\t\t\t\t//\tmoveForward();\n"
           "\t\t\t\t\t//}\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t\tmoveAction();\n"
           "\t\t\t\t//}\n"
           "\t\t\t//}\n"
           "\t\t} else if ( lastVisibleEnemyDist < ( weaponRange_x - weaponRangeBuffer ) ) { // TinMan: EnemyRange Further than weaponRange\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][Moving backwards to sweet spot]\" ); // TinMan: *debug*\n"
           "\t\t\t//AI_FORWARD = false;\n"
           "\t\t\tif ( checkMoveBack() ) {\n"
           "\t\t\t\tmoveBackward();\n"
           "\t\t\t}\n"
           "\t\t} /* else {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][At sweet spot]\" ); // TinMan: *debug*\n"
           "\t\t\tdebugVis( \"state_Combat\", \"at sweet pos\" );\n"
           "\t\t} */\n"
           "\t\t\n"
           "\t\tif ( nextStrafeTime < sys.getTime() ) { // TinMan: Randomly change strafe\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][Strafe]\" ); // TinMan: *debug*\n"
           "\t\t\tnextStrafeTime = RandomDelay( SABOT_STRAFE_MIN, SABOT_STRAFE_MAX );\n"
           "\t\n"
           "\t\t\tleft = false;\n"
           "\t\t\tright = false;\n"
           "\t\t\tleft = checkStrafeLeft();\n"
           "\t\t\tright = checkStrafeRight();\n"
           "\t\t\t \t\n"
           "\t\t\tif ( left && right ) {\n"
           "\t\t\t\tright == !AI_RIGHT; // TinMan: went right last time\n"
           "\t\t\t \tleft == !AI_LEFT;\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\tif ( left && right ) {\n"
           "\t\t\t\tif ( sys.random( 100 ) < 50 ) {\n"
           "\t\t\t\t\tright = false;\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\tleft = false;\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tif ( ENEMY_VISIBLE ) {\t\t\n"
           "\t\t\tif ( right ) {\n"
           "\t\t\t\tmoveRight();\n"
           "\t\t\t} else if ( left ) {\n"
           "\t\t\t\tmoveLeft();\n"
           "\t\t\t} // else {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Combat][can't strafe]\" ); // TinMan: *debug*\n"
           "\t\t\t//} \n"
           "\t\t}\n"
           "\n"
           "\t\t// TinMan: *cheaphack* stop bashing into stuff\n"
           "\t\tif ( AI_RIGHT && !checkStrafeRight() ) {\n"
           "\t\t\tAI_RIGHT = false;\n"
           "\t\t\t//nextStrafeTime = sys.getTime() + 0.05;\n"
           "\t\t}\n"
           "\t\tif ( AI_LEFT && !checkStrafeLeft() ) {\n"
           "\t\t\tAI_LEFT = false;\t\t\n"
           "\t\t\t//nextStrafeTime = sys.getTime() + 0.05;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t//if ( AI_FORWARD && !checkMoveForward() ) {\n"
           "\t\t\t// AI_FORWARD = false;\n"
           "\t\t//}\n"
           "\n"
           "\t\tif ( AI_BACKWARD && !checkMoveBack() ) {\n"
           "\t\t\tAI_BACKWARD = false;\n"
           "\t\t}\n"
           "\n"
           "\t\t// TinMan: Wherizy?\n"
           "\t\tif ( !ENEMY_VISIBLE ) {\n"
           "\t\t\tif ( enemyLostTime == 0 ) {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][start lost timer]\" ); // TinMan: *debug*\n"
           "\t\t\t\tenemyLostTime = RandomDelay( SABOT_ENEMY_LOST_TIME, SABOT_ENEMY_LOST_TIME + 0.5 );\n"
           "\t\t\t} else if ( enemyLostTime < sys.getTime() ) {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][chase]\" ); // TinMan: *debug*\n"
           "\t\t\t\tsetState( \"state_Chase\" );\n"
           "\t\t\t}\n"
           "\t\t} else if ( ENEMY_VISIBLE ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][reset lost timer]\" ); // TinMan: *debug*\n"
           "\t\t\tenemyLostTime = 0; // TinMan: Can see enemy again, so stop timer\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tcheckBlocked();\n"
           "\t\t\n"
           "\t\t//sys.debugBounds( '1 1 1', lastVisibleEnemyPos + '-1 -1 -1', lastVisibleEnemyPos + '1 1 1' , 0.01 ); // TinMan: *debug*\n"
           "\n"
           "\t\tcheckWeapon();\n"
           "\t\t\n"
           "\t\t//debugVis( \"state_Combat\", \"enemyDist:\" + int( lastVisibleEnemyDist ) );\n"
           "\t\t\n"
           "\t} // TinMan: End eachFrame/state\n"
           "\t\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][Exit state]\" ); // TinMan: *debug*\n"
           "\t\n"
           "\t// TinMan: Exit state\n"
           "\tif ( newEnemy ) { // TinMan: *cheaphack* Fix the loosing enemy due to reactiontime and state change *todo* rethink\n"
           "\t\tsetEnemy( newEnemy );\n"
           "\t}\n"
           "\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Combat][Exit state]\" ); // TinMan: *debug*\n"
           "\tsetState( \"state_Idle\" );\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::state_Chase\n"
           "TinMan: Move to restablish combat. Hunt him down!\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::state_Chase() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Chase]\" ); // TinMan: *debug*\n"
           "\tvector movePosition, aimDir, aimPosition;\n"
           "\tfloat nextGoalLook;\n"
           "\tfloat reactToEnemy;\n"
           "\tentity newEnemy;\n"
           "\t\n"
           "\tif ( !getEnemy() ) {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Chase][!enemy]\" ); // TinMan: *debug*\n"
           "\t\tclearGoal();\n"
           "\t\tsetState( \"state_Idle\" );\n"
           "\t}\n"
           "\n"
           "\t// TinMan: Gentlemen, start your engines.\n"
           "\t//if ( canReachEntity( getEnemy() ) ) {\n"
           "\tsetMoveToEnemy();\n"
           "\t//} else {\n"
           "\t\t//setMoveToAttackPosition( getEnemy() );\n"
           "\t\t//\n"
           "\t\t/*\n"
           "\t\tif ( AI_DEST_UNREACHABLE ) {\n"
           "\t\t\t// sys.println( \"[\" + int( sys.getTime() ) + \"][state_Chase][Cannot reach enemy or attack position]\" ); // TinMan: *debug*\n"
           "\t\t\tclearEnemy();\n"
           "\t\t\tsetState( \"state_Idle\" );\n"
           "\t\t}\n"
           "\t\t*/\n"
           "\t\t// sys.println( \"[\" + int( sys.getTime() ) + \"][state_Chase][Moving to attack position]\" ); // TinMan: *debug*\n"
           "\t//}\n"
           "\t// TinMan: Flip out straight away if you can't do move.\n"
           "\t/*if ( AI_MOVE_DONE || AI_DEST_UNREACHABLE ) {\n"
           "\t\tsetState( \"state_Idle\" );\t\t\n"
           "\t}*/\n"
           "\t\n"
           "\treactToEnemy = false;\n"
           "\n"
           "\tsetTimer( SABOT_CHASE_TIME ); // TinMan: Start chase timer.\n"
           "\n"
           "\teachFrame {\t\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Chase]\" ); // TinMan: *debug*\n"
           "\t\t//debugVis( \"state_Chase\", goal.getName() );\n"
           "\t\t\n"
           "\t\tif ( AI_DEAD || AI_RESPAWN ) {\n"
           "\t\t\tsetState( \"state_Killed\" );\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Check to see if enemy died\n"
           "\t\tif ( ENEMY_DEAD || !getEnemy() ) {\n"
           "\t\t\tclearGoal();\n"
           "\t\t\tbreak;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Move along given path\n"
           "\t\tmovePosition = moveAction();\n"
           "\t\t\n"
           "\t\t// TinMan: Lookee where we damn be going.\n"
           "\t\t//movePosition = getMovePosition();\n"
           "\t\tif ( /* AI_ONGROUND && */ movePosition != body.getOrigin() ) {\n"
           "\t\t\taimDir = movePosition - body.getOrigin();\n"
           "\t\t\tsetAimDirection( aimDir );\n"
           "\t\t}\n"
           "\t\t\t\t\n"
           "\t\tcheckBlocked();\n"
           "\n"
           "\t\t// TinMan: Look out for new badasses trying to kill you.\n"
           "\t\tif ( !reactToEnemy ) {\n"
           "\t\t\tif ( nextEnemyLook() || AI_PAIN || ENEMY_VISIBLE ) {\n"
           "\t\t\t\tif ( ENEMY_VISIBLE ) {\n"
           "\t\t\t\t\treactToEnemy = sys.getTime() + react_to_enemy; // TinMan: Current enemy back in view. Set react timer.\n"
           "\t\t\t\t\tnewEnemy = getEnemy(); // TinMan: *todo* seems a bit of a cludge, but whatever\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\tnewEnemy = lookForEnemies( true );\n"
           "\t\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\t\treactToEnemy = sys.getTime() + react_to_enemy; // TinMan: Set react timer.\n"
           "\t\t\t\t\t} else {\n"
           "\t\t\t\t\t\t// TinMan: Shh, I hear something.\n"
           "\t\t\t\t\t\tnewEnemy = listenForEnemies();\n"
           "\t\t\t\t\t\tif ( !newEnemy && AI_PAIN ) { // TinMan: *cheaphack* work around due to fact heardsound is being shoehorned into something it's not desiged to handle - multiple enemies\n"
           "\t\t\t\t\t\t\tnewEnemy = lookForEnemies( false );\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t\tif ( newEnemy ) {\n"
           "\t\t\t\t\t\t\treactToEnemy = sys.getTime() + react_to_enemy_sound; // TinMan: Set react timer.\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t} else if ( reactToEnemy < sys.getTime() ) { // TinMan: ok we're allowed to react to the enemy we saw ages ago due to our ninja bot skillz\n"
           "\t\t\treactToEnemy = 0;\n"
           "\t\t\t//if ( newEnemy != getEnemy() ) {\n"
           "\t\t\t\tsetEnemy( newEnemy );\n"
           "\t\t\t\tnewGoalPriority = getPlayerPriority( newEnemy );\n"
           "\t\t\t\t//if ( newGoalPriority > goalPriority ) { // TinMan: *test* always combat\n"
           "\t\t\t\t\tnewGoal = newEnemy;\n"
           "\t\t\t\t\tnewGoalType = SABOT_GOAL_ATTACK;\n"
           "\t\t\t\t\tsetNewGoal();\n"
           "\t\t\t\t\tsetState( \"state_Combat\" );\t\n"
           "\t\t\t\t//}\n"
           "\t\t\t//}\n"
           "\t\t}\n"
           "\t\n"
           "\t\tcheckWeapon();\n"
           "\t\t\n"
           "\t\t/*\n"
           "\t\t// TinMan: Get back into the fightening\n"
           "\t\tif ( ENEMY_VISIBLE ) {\n"
           "\t\t\tif ( reactToEnemy && reactToEnemy < sys.getTime() ) {\n"
           "\t\t\t\tgoalType = SABOT_GOAL_ATTACK;\n"
           "\t\t\t\tsetState( \"state_Combat\" );\n"
           "\t\t\t}\n"
           "\t\t} */\n"
           "\t\t\t\n"
           "\t\t// TinMan: At last seen enemy pos and can't see enemy *todo* rethink\n"
           "\t\tif ( AI_MOVE_DONE || AI_DEST_UNREACHABLE ) {\n"
           "\t\t\tfloat checkTime, lostTime;\n"
           "\t\t\tif ( lostTime && lostTime < sys.getTime() && !ENEMY_VISIBLE ) {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Chase][lostTime Up]\" ); // TinMan: *debug*\n"
           "\t\t\t\tclearEnemy();\n"
           "\t\t\t\tbreak;\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\tif ( checkTime < sys.getTime() ) {\n"
           "\t\t\t\tif ( getEnemy() ) {\n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Chase][reset move to enemy!]\" ); // TinMan: *debug*\n"
           "\t\t\t\t\tcheckTime = sys.getTime() + 0.3;\n"
           "\t\t\t\t\tif ( AI_MOVE_DONE ) { // TinMan: Cheat a bit, move towards current enemy pos\n"
           "\t\t\t\t\t\tlocateEnemy();\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t\tsetMoveToEnemy();\n"
           "\t\t\t\t\tif ( AI_MOVE_DONE || AI_DEST_UNREACHABLE ) { // TinMan: Still can't reach enemy\n"
           "\t\t\t\t\t\tif ( !lostTime ) {\n"
           "\t\t\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Chase][lostTime start]\" ); // TinMan: *debug*\n"
           "\t\t\t\t\t\t\tlostTime = sys.getTime() + 1; // TinMan: *todo* demagic\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t\t//setMoveToAttackPosition( getEnemy() );\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Chase][reset lostime]\" ); // TinMan: *debug*\n"
           "\t\t\tlostTime = 0;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Only chase the enemy for a certain amount of time, if it's up you've lost him.\n"
           "\t\tif ( getTimer() ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Chase][ChaseTime Up]\" ); // TinMan: *debug*\n"
           "\t\t\tclearTimer();\n"
           "\t\t\t//if ( !ENEMY_VISIBLE ) {\n"
           "\t\t\t//\tclearEnemy();\n"
           "\t\t\t//}\n"
           "\t\t\tclearGoal();\n"
           "\t\t\tbreak;\n"
           "\t\t}\n"
           "\t} // TinMan: End eachFrame/state\n"
           "\t\n"
           "\t// TinMan: *cheaphack* Because of the reaction delay between seen enemy and set enemy I need to catch it from falling through the crack here. But it just shows what a shambles the reaction system is.\n"
           "\tif ( newEnemy ) {\n"
           "\t\tsetEnemy( newEnemy );\n"
           "\t}\n"
           "\t\n"
           "\t//debugPrint( \"state_Chase\", \"Exit state\" ); // TinMan: *debug*\n"
           "\t// TinMan: Exit state\n"
           "\tsetState( \"state_Idle\" );\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::state_Retreat\n"
           "TinMan: Trying to escape enemy. Run Forest! Run!\n"
           "*todo* currently unused\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::state_Retreat() {\n"
           "\t// sys.println( \"[\" + int( sys.getTime() ) + \"][state_Retreat]\" ); // TinMan: *debug*\n"
           "\tfloat nextGoalLook;\n"
           "\tfloat reactToEnemy;\n"
           "\tfloat enemyLostTime;\n"
           "\tvector movePosition;\n"
           "\tvector aimDir;\n"
           "\tentity newEnemy;\n"
           "\t\n"
           "\tif ( !getEnemy() ) {\n"
           "\t\tsetState( \"state_Idle\" );\n"
           "\t} \n"
           "\t\n"
           "\tsetMoveToCover();\n"
           "\tif ( AI_DEST_UNREACHABLE || AI_MOVE_DONE ) {\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][state_Retreat][Cannot move to cover]\" ); // TinMan: *debug*\n"
           "\t\t/*setMoveOutOfRange( getEnemy(), 400 ); // TinMan: *todo* no magic\n"
           "\t\tif ( AI_DEST_UNREACHABLE || AI_MOVE_DONE ) {\n"
           "\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][state_Retreat][Cannot move out of range]\" ); // TinMan: *debug*\n"
           "\t\t}\telse {\n"
           "\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][state_Retreat][Moving out of range]\" ); // TinMan: *debug*\n"
           "\t\t}\n"
           "\t\t*/\n"
           "\t} /*else {\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][state_Retreat][Moving to cover]\" ); // TinMan: *debug*\n"
           "\t} */\n"
           "\n"
           "\teachFrame {\n"
           "\t\tif ( AI_DEAD || AI_RESPAWN ) {\n"
           "\t\t\tsetState( \"state_Killed\" );\n"
           "\t\t}\n"
           "\n"
           "\t\t// TinMan: Check to see if enemy died\t\n"
           "\t\tif ( ENEMY_DEAD || !getEnemy() ) {\n"
           "\t\t\tbreak;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tif ( AI_MOVE_DONE || AI_DEST_UNREACHABLE ) {\n"
           "\t\t\t//clearEnemy();\n"
           "\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Don't want to be running all our lives\n"
           "\t\tif ( !ENEMY_VISIBLE ) {\n"
           "\t\t\tif ( enemyLostTime == 0 ) {\n"
           "\t\t\t\tenemyLostTime = sys.getTime() + 12; // TinMan: *todo* demagic\n"
           "\t\t\t} else if ( enemyLostTime < sys.getTime() ) {\n"
           "\t\t\t\tclearEnemy();\n"
           "\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tif ( AI_PAIN && ENEMY_VISIBLE ) { // TinMan: *todo* set reaction timer\n"
           "\t\t\t\tsetState( \"state_CombatRetreat\" );\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Move along given path\n"
           "\t\tmovePosition = moveAction();\n"
           "\t\t\n"
           "\t\t// TinMan: Lookee where we damn be going.\n"
           "\t\t//movePosition = getMovePosition();\n"
           "\t\tif ( /* AI_ONGROUND && */ movePosition != body.getOrigin() ) {\n"
           "\t\t\taimDir = movePosition - body.getOrigin();\n"
           "\t\t\tsetAimDirection( aimDir );\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tcheckBlocked();\n"
           "\t\t\n"
           "\t\t// TinMan: Look out for new badasses trying to kill you.\n"
           "\t\tif ( !reactToEnemy ) {\n"
           "\t\t\tif ( nextEnemyLook() || AI_PAIN ) {\n"
           "\t\t\t\tnewEnemy = lookForEnemies( true );\n"
           "\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\tif ( body.distanceTo( newEnemy ) < enemyRange() ) { // TinMan: Closer than the chump I'm hunting.\n"
           "\t\t\t\t\t\treactToEnemy = sys.getTime() + react_to_enemy; // TinMan: Set react timer.\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\t// TinMan: Shh, I hear something.\n"
           "\t\t\t\t\tnewEnemy = listenForEnemies();\n"
           "\t\t\t\t\tif ( !newEnemy && AI_PAIN ) { // TinMan: *cheaphack* work around due to fack heardsound is being shoehorned into something it's not desiged to handle - multiple players\n"
           "\t\t\t\t\t\tnewEnemy = lookForEnemies( false );\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t\tif ( newEnemy ) {\n"
           "\t\t\t\t\t\tif ( body.distanceTo( newEnemy ) < enemyRange() ) { // TinMan: Closer than the chump I'm hunting.\n"
           "\t\t\t\t\t\t\treactToEnemy = sys.getTime() + react_to_enemy_sound; // TinMan: Set react timer.\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tif ( reactToEnemy < sys.getTime() ) {\n"
           "\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\t\t\n"
           "\t\tcheckWeapon();\n"
           "\t} // TinMan: End eachFrame/state\n"
           "\t\n"
           "\t// TinMan: *cheaphack* Because of the reaction delay between seen enemy and set enemy I need to catch it from falling through the crack here. But it just shows what a shambles the reaction system is.\n"
           "\tif ( newEnemy ) {\n"
           "\t\tsetEnemy( newEnemy );\n"
           "\t}\n"
           "\t\n"
           "\t//debugPrint( \"state_Retreat\", \"Exit state\" ); // TinMan: *debug*\n"
           "\t// TinMan: Exit state\n"
           "\tsetState( \"state_Idle\" );\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::state_Hold\n"
           "TinMan: Hold position - Aka camp.\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::state_Hold() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Hold]\" ); // TinMan *debug*\n"
           "\tvector movePosition;\n"
           "\tentity newEnemy;\n"
           "\tfloat reactToEnemy;\n"
           "\tfloat nextGoalLook;\n"
           "\n"
           "\treactToEnemy = 0;\n"
           "\n"
           "\tstopMove(); // TinMan: *note* All states should handle movement to that goal, if it doesn't do a move command at start then stopMove previous movement.\n"
           "\t\n"
           "\tsetTimer( SABOT_HOLD_TIME ); // TinMan: Start timer if we don't want to wait forever\n"
           "\t\n"
           "\teachFrame {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Hold][\" + goal.getName() + \"]\" ); // TinMan *debug*\n"
           "\t\tif ( AI_DEAD || AI_RESPAWN ) {\n"
           "\t\t\tsetState( \"state_Killed\" );\n"
           "\t\t}\n"
           "\n"
           "\t\t\n"
           "\t\t// TinMan: Look for new goals. The shinier the better.\n"
           "\t\tif ( sys.getTime() > nextGoalLook ) {\n"
           "\t\t\tnextGoalLook = sys.getTime() + SABOT_NEXT_GOAL_LOOK;\n"
           "\t\t\tlookForGoal( true ); // TinMan: Will set newGoal. More important than it might seem, here is the ultimate decision whether to discard current goal (via a higher priority), which may be something set by chooseGoal, and something as important as capping flag.\n"
           "\t\t\t// TinMan: If pretty new thing better than current plaything.\n"
           "\t\t\tif ( newGoal ) {\n"
           "\t\t\t\tif ( newGoal != goal ) {\n"
           "\t\t\t\t\tif ( newGoalPriority > goalPriority ) {\n"
           "\t\t\t\t\t\tsetNewGoal();\n"
           "\t\t\t\t\t\tbreak;\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Lookin for trouble with a big T.\n"
           "\t\tif ( !reactToEnemy ) {\n"
           "\t\t\tif ( nextEnemyLook() || AI_PAIN || ENEMY_VISIBLE ) {\n"
           "\t\t\t\tif ( ENEMY_VISIBLE ) {\n"
           "\t\t\t\t\treactToEnemy = sys.getTime() + react_to_enemy; // TinMan: Current enemy back in view. Set react timer.\n"
           "\t\t\t\t\tnewEnemy = getEnemy(); // TinMan: *todo* seems a bit of a cludge, but whatever\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\tnewEnemy = lookForEnemies( true );\n"
           "\t\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\t\treactToEnemy = sys.getTime() + react_to_enemy; // TinMan: Set react timer.\n"
           "\t\t\t\t\t} else {\n"
           "\t\t\t\t\t\t// TinMan: Shh, I hear something.\n"
           "\t\t\t\t\t\tnewEnemy = listenForEnemies();\n"
           "\t\t\t\t\t\tif ( !newEnemy && AI_PAIN ) { // TinMan: *cheaphack* work around due to fact heardsound is being shoehorned into something it's not desiged to handle - multiple enemies\n"
           "\t\t\t\t\t\t\tnewEnemy = lookForEnemies( false );\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t\tif ( newEnemy ) {\n"
           "\t\t\t\t\t\t\treactToEnemy = sys.getTime() + react_to_enemy_sound; // TinMan: Set react timer.\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t} else if ( reactToEnemy < sys.getTime() ) { // TinMan: ok we're allowed to react to the enemy we saw ages ago due to our ninja bot skillz\n"
           "\t\t\tsetEnemy( newEnemy );\n"
           "\t\t\treactToEnemy = 0;\n"
           "\t\t\tnewGoalPriority = getPlayerPriority( newEnemy );\n"
           "\t\t\t//if ( newGoalPriority > goalPriority ) { // TinMan: A baddy is always more important than holding\n"
           "\t\t\t\tnewGoal = newEnemy;\n"
           "\t\t\t\tnewGoalType = SABOT_GOAL_ATTACK;\n"
           "\t\t\t\tsetNewGoal();\n"
           "\t\t\t\tsetState( \"state_Combat\" );\t\n"
           "\t\t\t//}\n"
           "\t\t}\n"
           "\t\n"
           "\t\t// TinMan: What are we waiting for?\t\t\n"
           "\t\tif ( isCTF() ) {\n"
           "\t\t\tif ( goal == ourFlag ) {\n"
           "\t\t\t\tif ( getFlagStatus( team ) == FLAGSTATUS_INBASE ) {\n"
           "\t\t\t\t\tif ( body.distanceToPoint( goal.getOrigin() ) > 32 ) {\n"
           "\t\t\t\t\t\tgoalType = SABOT_GOAL_MOVE;\n"
           "\t\t\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t} else if ( goal == theirFlag ) {\n"
           "\t\t\t\tif ( getFlagStatus( 1 - team ) == FLAGSTATUS_INBASE ) {\n"
           "\t\t\t\t\tif ( body.distanceToPoint( goal.getOrigin() ) > 32 ) {\n"
           "\t\t\t\t\t\tgoalType = SABOT_GOAL_MOVE;\n"
           "\t\t\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\t\t\t\t\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: *cheaphack* look somewhere usefull (hopefully), better would be to do a quick predict towards theircap and look there.\n"
           "\t\t\tvector lookDir, capPos;\n"
           "\t\t\tif ( goal == ourFlag ) {\n"
           "\t\t\t\tcapPos = theirCap;\n"
           "\t\t\t} else if ( goal == theirFlag ) {\n"
           "\t\t\t\tcapPos = ourCap;\n"
           "\t\t\t}\n"
           "\t\t\tlookDir = capPos - body.getOrigin();\n"
           "\t\t\tlookDir_z = 0;\n"
           "\t\t\tsetAimDirection( lookDir );\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: We only hold for a certain amount of time in ctf\n"
           "\t\t\tif ( getTimer() ) {\n"
           "\t\t\t\t// sys.println( \"[\" + int( sys.getTime() ) + \"][state_Hold][HoldTime Up]\" ); // TinMan: *debug*\n"
           "\t\t\t\tclearTimer();\n"
           "\t\t\t\tclearGoal();\n"
           "\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t/* TinMan: *todo* rejigger\n"
           "\t\t// TinMan: Look for other items to grab\n"
           "\t\t*/\n"
           "\t\n"
           "\t\t// TinMan: Move to hold position if too far away *todo* hardly triggers, nessesary?\n"
           "\t\tif ( body.distanceToPoint( goalPosition ) > 128 ) {\n"
           "\t\t\t// sys.println( \"[\" + int( sys.getTime() ) + \"][\" + getName() + \"][state_Hold][too far away from goal: move]\" ); // TinMan *debug*\n"
           "\t\t\tgoalType = SABOT_GOAL_MOVE; // TinMan: Once the bot reaches the hold goal via movetogoal, the choosegoal will probably set goal back to hold. *todo* really need a stack\n"
           "\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t//setState( \"state_MoveToGoal\" );\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tcheckWeapon(); // TinMan: Make sure your weapon is nice and shiny\n"
           "\t} // TinMan: End eachFrame/state\n"
           "\t\n"
           "\t// TinMan: *cheaphack* Because of the reaction delay between seen enemy and set enemy I need to catch it from falling through the crack here. But it just shows what a shambles the reaction system is.\n"
           "\tif ( newEnemy ) {\n"
           "\t\tsetEnemy( newEnemy );\n"
           "\t}\n"
           "\t\n"
           "\t//debugPrint( \"state_Hold\", \"Exit state\" ); // TinMan: *debug*\n"
           "\t// TinMan: Exit state\n"
           "\tsetState( \"state_Idle\" );\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::state_Follow\n"
           "TinMan: Follow teammate.\n"
           "*todo* currently unused\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::state_Follow() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Follow]\" ); // TinMan *debug*\n"
           "\tvector movePosition;\n"
           "\tvector aimDir;\n"
           "\tfloat nextGoalLook;\n"
           "\tentity leader;\n"
           "\tentity newEnemy;\n"
           "\tfloat reactToEnemy;\n"
           "\n"
           "\treactToEnemy = 0;\n"
           "\t\n"
           "\tif ( !goal ) {\n"
           "\t\tsetState( \"state_Idle\" );\n"
           "\t}\n"
           "\t\n"
           "\tleader = goal;\n"
           "\t\n"
           "\tsetMoveToPosition( goal.getOrigin() );\n"
           "\n"
           "\teachFrame {\n"
           "\t\tif ( AI_DEAD || AI_RESPAWN ) {\n"
           "\t\t\tsetState( \"state_Killed\" );\n"
           "\t\t}\n"
           "\n"
           "\t\t\n"
           "\t\tif ( checkLeader( leader ) || !leader ) { // TinMan: See if we should still go for it\n"
           "\t\t\tsetState( \"state_Idle\" );\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Lookin for trouble with a big T.\n"
           "\t\tif ( !reactToEnemy ) {\n"
           "\t\t\tif ( nextEnemyLook() || AI_PAIN || ENEMY_VISIBLE ) {\n"
           "\t\t\t\tif ( ENEMY_VISIBLE ) {\n"
           "\t\t\t\t\treactToEnemy = sys.getTime() + react_to_enemy; // TinMan: Current enemy back in view. Set react timer.\n"
           "\t\t\t\t\tnewEnemy = getEnemy(); // TinMan: *todo* seems a bit of a cludge, but whatever\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\tnewEnemy = lookForEnemies( true );\n"
           "\t\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\t\treactToEnemy = sys.getTime() + react_to_enemy; // TinMan: Set react timer.\n"
           "\t\t\t\t\t} else {\n"
           "\t\t\t\t\t\t// TinMan: Shh, I hear something.\n"
           "\t\t\t\t\t\tnewEnemy = listenForEnemies();\n"
           "\t\t\t\t\t\tif ( !newEnemy && AI_PAIN ) { // TinMan: *cheaphack* work around due to fact heardsound is being shoehorned into something it's not desiged to handle - multiple enemies\n"
           "\t\t\t\t\t\t\tnewEnemy = lookForEnemies( false );\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t\tif ( newEnemy ) {\n"
           "\t\t\t\t\t\t\treactToEnemy = sys.getTime() + react_to_enemy_sound; // TinMan: Set react timer.\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t} else if ( reactToEnemy < sys.getTime() ) { // TinMan: ok we're allowed to react to the enemy we saw ages ago due to our ninja bot skillz\n"
           "\t\t\tsetEnemy( newEnemy );\n"
           "\t\t\treactToEnemy = 0;\n"
           "\t\t\tnewGoalPriority = getPlayerPriority( newEnemy );\n"
           "\t\t\tif ( newGoalPriority > goalPriority ) {\n"
           "\t\t\t\tnewGoal = newEnemy;\n"
           "\t\t\t\tnewGoalType = SABOT_GOAL_ATTACK;\n"
           "\t\t\t\tsetNewGoal();\n"
           "\t\t\t\tsetState( \"state_Combat\" );\t\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t/* *todo* rejigger\n"
           "\t\t// TinMan: Look for other items to grab on the way\n"
           "\t\t*/\n"
           "\t\t\n"
           "\t\tsetMoveToPosition( leader.getOrigin() ); // TinMan: Diferent from other states, our goal, the leader is on the move\n"
           "\t\t\n"
           "\t\t// TinMan: The actual following\n"
           "\t\tif  ( body.distanceTo( leader ) < SABOT_FOLLOWDIST_MIN ) {\n"
           "\t\t\t//setAimPosition( getAIAimTargets( leader, true ) );\n"
           "\t\t\tstopMove();\n"
           "\t\t} else if ( body.distanceTo( leader ) > SABOT_FOLLOWDIST_MAX ) {\n"
           "\t\t\t// TinMan: Move along given path\n"
           "\t\t\tmovePosition = moveAction();\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: Lookee where we damn be going.\n"
           "\t\t\t//movePosition = getMovePosition();\n"
           "\t\t\tif ( /* AI_ONGROUND && */ movePosition != body.getOrigin() ) {\n"
           "\t\t\t\taimDir = movePosition - body.getOrigin();\n"
           "\t\t\t\tsetAimDirection( aimDir );\n"
           "\t\t\t}\t\t\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tcheckBlocked();\n"
           "\n"
           "\t\tcheckWeapon(); // TinMan: Make sure your weapon is nice and shiny\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::state_Killed\n"
           "TinMan: botAi hijacks script when bots fakeclient is AI_DEAD, sets state to this.\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::state_Killed() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][Died]\" ); // TinMan: *debug*\n"
           "\n"
           "\tstopMove();\n"
           "\t\n"
           "\twhile( AI_DEAD || AI_RESPAWN ) {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Killed][waiting]\" ); // TinMan: *debug*\n"
           "\t\t\n"
           "\t\tfloat nextFire;\n"
           "\t\tif ( sys.getTime() > nextFire ) {\n"
           "\t\t\tnextFire = sys.getTime() + 0.1;\n"
           "\t\t\tAI_FIRE = true; // TinMan: Fire so bot respawns\n"
           "\t\t}\n"
           "\t\twaitFrame();\n"
           "\t}\n"
           "\t\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][Restarting]\" ); // TinMan: *debug*\n"
           "\tsetState( \"state_Begin\" );\n"
           "}\n"
           "\n"
           "\n"
           "/***********************************************************************\n"
           "\n"
           "\tFunctions\n"
           "\n"
           "***********************************************************************/\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::setNewGoal\n"
           "TinMan: *todo* complete\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::setNewGoal() {\n"
           "\t/*if ( goal ) {\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][setNewGoal][curgoal: \" + goal.getName() + \"][curprio: \"  + goalPriority + \"]\" ); // TinMan: *debug*\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][setNewGoal][newgoal: \" + newGoal.getName() + \"][newprio: \" + newGoalPriority + \"]\" ); // TinMan: *debug*\n"
           "\t}*/\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][setNewGoal][newgoal: \" + newGoal.getName() + \"][newprio: \" + newGoalPriority + \"]\" ); // TinMan: *debug*\n"
           "\tgoalType \t\t\t= newGoalType;\n"
           "\tmoveType \t\t\t= newMoveType;\n"
           "\tgoal \t\t\t\t\t= newGoal;\n"
           "\tgoalPosition \t= newGoalPosition;\n"
           "\tgoalPriority \t= newGoalPriority;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::clearGoal\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::clearGoal() {\n"
           "\tif ( goal ) {\n"
           "\t\toldGoal = goal;\n"
           "\t}\n"
           "\t\n"
           "\tgoalType = 0;\n"
           "\tmoveType = 0;\n"
           "\tgoal = $null_entity;\n"
           "\tgoalPosition = '0 0 0'; // TinMan: *todo* hmm how do you null a vector?\n"
           "\tgoalPriority = 0;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::clearNewGoal\n"
           "TinMan: *todo* complete\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::clearNewGoal() {\n"
           "\tnewGoalType = 0;\n"
           "\tnewMoveType = 0;\n"
           "\tnewGoal = $null_entity;\n"
           "\tnewGoalPosition = '0 0 0'; // TinMan: *todo* hmm how do you null a vector?\n"
           "\tnewGoalPriority = 0;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::moveForward\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::moveForward() {\n"
           "\tAI_FORWARD = true;\n"
           "\tAI_BACKWARD = false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::moveBackward\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::moveBackward() {\n"
           "\tAI_BACKWARD = true;\n"
           "\tAI_FORWARD = false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::moveRight\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::moveRight() {\n"
           "\tAI_RIGHT = true;\n"
           "\tAI_LEFT = false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::moveLeft\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::moveLeft() {\n"
           "\tAI_LEFT = true;\n"
           "\tAI_RIGHT = false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::moveAction\n"
           "TinMan: Folow path given by routing, check and do more complex navigation actions: Jumps, elevators \n"
           "*todo* Rough as guts, should be moved into botAi and overhauled.\n"
           "Note: pathtype is allways ored against pathtype_walk which is enum 0 so doing equality tests is fine.\n"
           "=====================\n"
           "*/\n"
           "vector bot_sabot::moveAction() {\n"
           "\tfloat pathType;\n"
           "\tvector movePosition, secondaryMovePosition, bodyOrigin, moveDir, velocity;\n"
           "\tfloat dist, moveSpeed;\n"
           "\t\n"
           "\tentity plat;\n"
           "\tfloat i, numListedEntities, radius;\n"
           "\tvector platOrigin, platStart, platBottom;\n"
           "\tvector waitPos;\n"
           "\tradius = 256;\n"
           "\t\n"
           "\tmovePosition = getMovePosition();\n"
           "\t\n"
           "\tif ( AI_MOVE_DONE || AI_DEST_UNREACHABLE ) {\n"
           "\t\treturn movePosition;\n"
           "\t}\n"
           "\t\n"
           "\t// TinMan: *todo* not even attempting air control at the moment, just go with the flow.\n"
           "\t/* if ( !AI_ONGROUND ) {\n"
           "\t\treturn movePosition;\n"
           "\t} */\n"
           "\t\n"
           "\tpathType = getPathType();\n"
           "\t\n"
           "\tvelocity = body.getLinearVelocity();\n"
           "\tbodyOrigin = body.getOrigin();\n"
           "\t\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_MoveToGoal][velocity: \" + sys.vecLength( velocity ) + \"]\" ); // TinMan *debug*\n"
           "\t\n"
           "\t// TinMan: *todo* *test* don't strafe on complicated paths\n"
           "\t/* if ( pathType != PATHTYPE_WALK ) {\n"
           "\t\tAI_RIGHT = false;\n"
           "\t\tAI_LEFT = false;\n"
           "\t}\n"
           "\t*/\n"
           "\t\n"
           "\t//sys.debugBounds( '1 1 0', movePosition + '-1 -1 -1', movePosition + '1 1 1' , 0.01 ); // TinMan: *debug*\n"
           "\t\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_MoveToGoal][PATHTYPE: \" + getPathType() + \"]\" ); // TinMan *debug*\n"
           "\tif ( pathType == PATHTYPE_WALK ) {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_MoveToGoal][PATHTYPE_WALK]\" ); // TinMan *debug*\n"
           "\t\t\t\n"
           "\t\t// TinMan: Do actual movement\n"
           "\t\tmoveDir = movePosition - bodyOrigin;\n"
           "\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\n"
           "\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t// AI_FORWARD = true;\n"
           "\t\t\n"
           "\t\t/*\n"
           "\t\tif ( !AI_ONGROUND ) {\n"
           "\t\t AI_JUMP = false;\n"
           "\t\t} else if ( sys.vecLength( velocity ) > 319 && body.distanceToPoint( movePosition ) > 128 ) {\n"
           "\t\t\tif ( sys.random( 100 ) < 50 ) {\n"
           "\t\t\t\tAI_RIGHT = false;\n"
           "\t\t\t} else {\n"
           "\t\t\t\tAI_LEFT = false;\n"
           "\t\t\t}\n"
           "\t\t\tAI_JUMP = true;\n"
           "\t\t}\n"
           "\t\t*/\n"
           "\t\t\n"
           "\t\tvector ang = body.getViewAngles();\n"
           "\t\t\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_MoveToGoal][moveposition =\" + movePosition +  \"]\" ); // TinMan *debug*\n"
           "\t\t//moveForward();\n"
           "\t\t\n"
           "\t\t//checkBlocked();\n"
           "\t//} else if ( getPathType() & PATHTYPE_WALKOFFLEDGE ) {\n"
           "\t\t\n"
           "\t} else if ( pathType & PATHTYPE_BARRIERJUMP ) {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][PATHTYPE_BARRIERJUMP]\" ); // TinMan *debug*\n"
           "\t\t//sys.debugBounds( '1 0 0', getSecondaryMovePosition() + '-1 -1 -1', getSecondaryMovePosition() + '1 1 1' , 0.01 ); // TinMan: *debug* show bound secondarypos\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][LinearVelocity:\" + body.getLinearVelocity() + \"][vecLength:\" + sys.vecLength( body.getLinearVelocity() ) + \"]\" ); // TinMan *debug*\n"
           "\t\tif ( body.distanceToPoint( movePosition ) < 8 ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][close to moveposition]\" ); // TinMan *debug*\n"
           "\t\t\t\t\n"
           "\t\t\t// TinMan: Ping a vector from self through jump end (which will be directly above jump start position)\n"
           "\t\t\t//secondaryMovePosition = getSecondaryMovePosition();\n"
           "\n"
           "\t\t\t//moveDir = movePosition - bodyOrigin;\n"
           "\t\t\t//moveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\t//movePosition = moveDir * 2048;\n"
           "\t\t\t//movePosition_z = bodyOrigin_z + viewHeight;\n"
           "\t\t\t//sys.debugBounds( '0 1 0', movePosition + '-1 -1 -1', movePosition + '1 1 1' , 0.01 ); // TinMan: *debug* show bound secondarypos\n"
           "\t\t\t//setAimPosition( movePosition );\n"
           "\t\t\t\t\n"
           "\t\t\t//moveForward();\n"
           "\t\t\tAI_JUMP = true;\n"
           "\t\t\t//AI_JUMP = !AI_JUMP;\n"
           "\t\t} else if ( AI_ONGROUND ) { // TinMan: Move to jump position *todo* need propper check to indicate we aren't interested in reach start but reach end.\n"
           "\t\t\t// TinMan: Do actual movement\n"
           "\t\t\tmoveDir = movePosition - bodyOrigin;\n"
           "\t\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\t\n"
           "\t\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t\t//moveForward();\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][vertical vel: \" + velocity_z + \"]\" ); // TinMan *debug*\n"
           "\t\t\n"
           "\t\t// TinMan: Going down\n"
           "\t\tif ( velocity_z < 250 /*&& !AI_ONGROUND*/ ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][falling]\" ); // TinMan *debug*\n"
           "\t\t\t//moveForward();\n"
           "\t\t\t\t\n"
           "\t\t\t// TinMan: While it's more propper to use secondarypos, since in this case the reach end is right above reach start there isn't much of a difference, movepos even seems to be working a little better, haven't looked into why.\n"
           "\t\t\t//secondaryMovePosition = getSecondaryMovePosition();\n"
           "\t\t\t//moveDir = secondaryMovePosition - bodyOrigin;\n"
           "\t\t\tmoveDir = movePosition - bodyOrigin;\n"
           "\t\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\t\t\n"
           "\t\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tmovePosition = bodyOrigin; // TinMan: *cheaphack* set movepos to origin so he looks ahead\n"
           "\t\n"
           "\t} else { // TinMan: Unknown pathtype\n"
           "\t\t// TinMan: Have a bash at it anyway\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][Unhandled pathtype: \" + getPathType() + \"]\" ); // TinMan *debug*\n"
           "\t\t\n"
           "\t\t// TinMan: Do actual movement\n"
           "\t\tmoveDir = movePosition - bodyOrigin;\n"
           "\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t\n"
           "\t\t//checkBlocked();\n"
           "\t}\n"
           "\t\n"
           "\treturn movePosition;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::setTimer\n"
           "TinMan: I am the very model of a modern major general\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::setTimer( float endTime ) {\n"
           "\t//timerAmount = time;\n"
           "\t//timerStart = sys.getTime();\n"
           "\ttimerEnd = sys.getTime() + endTime;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::getTimer\n"
           "TinMan: the bell, the bells\n"
           "=====================\n"
           "*/\n"
           "float bot_sabot::getTimer() {\n"
           "\tif ( timerEnd == -1 ) { // TinMan: Timer not set\n"
           "\t\t//return -1;\n"
           "\t\treturn false;\n"
           "\t} else if ( timerEnd < sys.getTime() ) { // TinMan: Timer over\n"
           "\t\t// TinMan: *todo* return Elapsed time\n"
           "\t\t//clearTimer(); // TinMan: Reset timer now it's over, since sometimes you'll be checking if theres a timer set `*todo* rethink this\n"
           "\t\treturn true; \n"
           "\t} else { // TinMan: Timer still going\n"
           "\t\t// TinMan: *todo* return Elapsed time\n"
           "\t\treturn false; \n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::clearTimer\n"
           "TinMan: car button cloth\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::clearTimer() {\n"
           "\ttimerEnd = -1;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::nextEnemyLook\n"
           "TinMan: Timer\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot::nextEnemyLook() {\n"
           "\tif ( sys.getTime() > nextEnemyLookTime ) {\n"
           "\t\tnextEnemyLookTime = sys.getTime() + SABOT_NEXT_ENEMY_LOOK;\n"
           "\t\treturn true;\n"
           "\t}\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/***********************************************************************\n"
           "\n"
           "\tChecks\n"
           "\n"
           "***********************************************************************/\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::checkGoal\n"
           "TinMan: See if we still want this goal, bumps off goal if it's old and mankey, or if we just want to rechoose goal.\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot::checkGoal() {\n"
           "\tvector origin, goalOrigin;\n"
           "\tfloat goalDist;\n"
           "\n"
           "\tif ( moveType == SABOT_MOVETYPE_ENTITY ) {\n"
           "\t\tif ( !goal ) {\n"
           "\t\t\treturn true;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tgoalDist = body.distanceTo( goal );\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][checkGoal][dist: \" + goalDist + \"]\" ); // TinMan *debug*\n"
           "\n"
           "\t\tif ( goalDist < 128 ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][checkGoal][close, checking]\" ); // TinMan *debug*\n"
           "\t\t\n"
           "\t\t\tif ( goal.isHidden() ) {\n"
           "\t\t\t\treturn true;\n"
           "\t\t\t} else if ( body.touches( goal ) ) {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][checkGoal][touched goal]\" ); // TinMan *debug*\n"
           "\t\t\t\treturn true;\n"
           "\t\t\t} else if ( goalDist < 32 ) {\n"
           "\t\t\t\treturn true;\n"
           "\t\t\t}\t\n"
           "\t\t}\n"
           "\t} else { // TinMan: SABOT_MOVETYPE_POSITION\n"
           "\t\tgoalDist = body.distanceToPoint( goalPosition );\n"
           "\t\tif ( goalDist < 32 ) {\n"
           "\t\t\treturn true;\n"
           "\t\t}\t\n"
           "\t}\n"
           "\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::gotFlag\n"
           "TinMan: *cheaphack* a fix untill single goal/priority is sorted\n"
           "*todo* expand into more general flag checking?\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot::gotFlag() {\n"
           "\tif ( getFlagCarrier( team ) == body ) {\n"
           "\t\t// TinMan: Did we get flag somehow? If so dump goal and go to idle where chooseGoal will sort it out.\n"
           "\t\tif ( goal != ourFlag ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_hold][!have flag!]\" ); // TinMan *debug*\n"
           "\t\t\treturn true;\n"
           "\t\t}\n"
           "\t}\n"
           "\t\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::updateTeam\n"
           "TinMan: Make sure team stuff is updated. kill red. kill red. kill red.\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::updateTeam() {\n"
           "\tif ( getTeam( body ) == team ) {\n"
           "\t\treturn;\n"
           "\t}\n"
           "\t\n"
           "\tteam \t\t\t\t= getTeam( body );\n"
           "\t\n"
           "\tif ( isCTF() ) {\t\n"
           "\t\tourFlag \t\t= getFlag( team );\n"
           "\t\ttheirFlag \t= getFlag( 1 - team );\n"
           "\t\t\n"
           "\t\t// TinMan: While having flags as the capture points is simpler, the d3ctf way of having them seperate was more versatile, and wasier for bots\n"
           "\t\t//ourCap \t\t\t= getCapturePoint( team );\n"
           "\t\t//theirCap \t\t= getCapturePoint( 1 - team );\n"
           "\t\t\n"
           "\t\tourCap\t\t\t= ourFlag.getVectorKey( \"origin\" ); // TinMan: since we cant rely on flag being at home base on spawn we'll have to rely on grabbing the original origin key, a better solution would to be to extend ctf funcs.\n"
           "\t\ttheirCap\t\t= theirFlag.getVectorKey( \"origin\" );\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::checkSelf\n"
           "TinMan: See if you are happy with your weapon/hp/armor. Returns true if not happy happy joy joy.\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot::checkSelf() {\n"
           "\tfloat weaponPriority;\n"
           "\n"
           "\tweaponPriority = getFloatKey( \"priority_\" + currentWeapon ); // TinMan: Grab priority from def\n"
           "\t\n"
           "\tif ( weaponPriority <= 3 && getActorHealth( body ) + getArmor( body ) < 40 ) { // TinMan: better weapon than pistol *todo* demagic happystrenght\n"
           "\t\treturn true;\n"
           "\t}\n"
           "\t\n"
           "\tif ( weaponPriority < 40 && getActorHealth( body ) + getArmor( body ) <= 20 && !AI_PAIN ) { // TinMan: Weapon < chaingun and very beat up, if your allready getting hurt you're probably going to die anyway\n"
           "\t\treturn true;\n"
           "\t}\n"
           "\t\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::checkLeader\n"
           "TinMan: \n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot::checkLeader( entity thisLeader ) {\n"
           "\tif ( !thisLeader ) {\n"
           "\t\treturn true;\n"
           "\t}\n"
           "\n"
           "\tif ( getActorHealth( thisLeader ) <= 0 ) {\n"
           "\t\treturn true;\n"
           "\t}\n"
           "\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::checkWeapon\n"
           "TinMan: Make sure your weapon is in order\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot::checkWeapon() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][goal: \" + goal.getName() + \"][prio: \" + goalPriority + \"]\" ); // TinMan *debug* *todo* *rem*\n"
           "\tstring weaponName;\n"
           "\tfloat rate;\n"
           "\t\n"
           "\tif ( getEnemy() ) {\n"
           "\t\tchooseWeapon( enemyRange() );\n"
           "\t} else {\n"
           "\t\tchooseWeapon( -1 );\t\n"
           "\t}\n"
           "\t\n"
           "\t//nextBestWeapon(); // TinMan: *oldski* *rem*\n"
           "\t\n"
           "\t// TinMan: Unless you can be sure weapon only changes in above function (eg no auto switch or empty weapon switch ) you'll have to check and update weapon stuff here\n"
           "\tweaponName = body.getCurrentWeapon();\n"
           "\tif ( weaponName != currentWeapon ) {\n"
           "\t\tcurrentWeapon = weaponName;\t\n"
           "\t\tweaponRange = getVectorKey( \"range_\" + currentWeapon ); // TinMan: Grab ranges from def\n"
           "\t\trate = getFloatKey( \"aim_rate\" );\n"
           "\t\trate += getFloatKey( \"aim_rate_\" + currentWeapon );\n"
           "\t\t// sys.println( \"[\" + int( sys.getTime() ) + \"][aimrate: \" + rate + \"]\" ); // TinMan *debug*\n"
           "\t\tsetAimRate( rate );\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][checkweapon][currentWeapon: \" + currentWeapon + \"][weaponrange: \" + weaponRange + \"]\" ); // TinMan *debug*\n"
           "\t}\n"
           "\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::checkStrafeLeft\n"
           "TinMan: Crude as hell, but will do for now\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot::checkStrafeLeft() {\n"
           "\tvector\tpos, ang, dir, tracePosition, pushPosition;\n"
           "\tfloat maxRange, frac, traceDistance;\n"
           "\t//entity\ttraceEntity;\n"
           "\n"
           "\tmaxRange = SABOT_CHECK_MOVE_DISTANCE; // TinMan: Max a bounds trace can do is 4096.\n"
           "\n"
           "\tpos = getViewPosition();\n"
           "\tang = body.getViewAngles();\n"
           "\n"
           "\tang_x = 0;\n"
           "\tang_z = 0;\n"
           "\tang_y += 90;\n"
           "\tdir = sys.angToForward( ang ); // TinMan: Convert angles (pitch yaw roll), to forward vector (x y z).\n"
           "\n"
           "\tfrac = sys.tracePoint( pos, pos + ( dir * maxRange ), CONTENTS_OPAQUE | MASK_SHOT_RENDERMODEL, body );\n"
           "\n"
           "\n"
           "\t//float debugTime = 0.01;\n"
           "\t/*\n"
           "\ttraceDistance = frac * maxRange; // TinMan: Convert the fraction of trace completed to game units\n"
           "\n"
           "\tsys.debugLine( '0 1 1', pos, pos + ( dir * maxRange ), debugTime ); // TinMan: *debug* full trace\n"
           "\tsys.debugBounds( '1 0 0', pos + '-1 -1 -1', pos + '1 1 1' , debugTime ); // TinMan: *debug* show bound at eyes\n"
           "\n"
           "\tsys.debugLine( '0 1 0', pos, tracePosition,\tdebugTime ); // TinMan: *debug* trace\n"
           "\tsys.debugBounds( '1 1 0', tracePosition + '-2 -2 -2', tracePosition + '2 2 2' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\t*/\n"
           "\n"
           "\tif ( frac != 1 ) {\n"
           "\t\treturn false;\n"
           "\t}\n"
           "\t\t\n"
           "\ttracePosition = sys.getTraceEndPos(); // TinMan: Get where trace hit\n"
           "\tpushPosition = pushPointIntoAAS( tracePosition );\n"
           "\t\n"
           "\t// TinMan: Do cheap canhit enemy from here\n"
           "\tentity enemy = getEnemy();\n"
           "\tif ( enemy ) {\n"
           "\t\t//sys.debugLine( '0 1 0', tracePosition, tracePosition + ( getAIAimTargets( enemy ) - tracePosition ) * 2048,\tdebugTime ); // TinMan: *debug* trace\n"
           "\t\tfrac = sys.tracePoint( tracePosition, tracePosition + ( getAIAimTargets( enemy, 2 ) - tracePosition ) * 2048, CONTENTS_OPAQUE | MASK_SHOT_RENDERMODEL, body );// TinMan: can you see enemy from this new position?\n"
           "\t\tif ( sys.getTraceEntity() != enemy ) {\n"
           "\t\t\t//tracePosition = sys.getTraceEndPos();\n"
           "\t\t\t//sys.debugBounds( '1 0 0', tracePosition + '-2 -2 -2', tracePosition + '2 2 2' , debugTime ); // TinMan: *debug*\n"
           "\t\t\t//sys.println( \"[\" + sys.getTime() + \"][checkStrafeLeft][cannot see enemy from strafe pos]\" ); // TinMan: *debug*\n"
           "\t\t\treturn false;\n"
           "\t\t}\n"
           "\t}\n"
           "\t\n"
           "\t\n"
           "\t//sys.debugBounds( '1 1 0', pushPosition + '-2 -2 -2', pushPosition + '2 2 2' , debugTime ); // TinMan: *debug*\n"
           "\tif ( !testMoveToPosition( pushPosition ) ) {\n"
           "\t\t// sys.println( \"[\" + sys.getTime() + \"][checkStrafeLeft][cannot moveto strafe pos]\" ); // TinMan: *debug*\n"
           "\t\treturn false; \t\n"
           "\t}\t\t\n"
           "\n"
           "\treturn true;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::checkStrafeRight\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot::checkStrafeRight() {\n"
           "\tvector\tpos, ang, dir, tracePosition, pushPosition;\n"
           "\tfloat maxRange, frac, traceDistance;\n"
           "\t//entity\ttraceEntity;\n"
           "\n"
           "\tmaxRange = SABOT_CHECK_MOVE_DISTANCE; // TinMan: Max a bounds trace can do is 4096.\n"
           "\n"
           "\tpos = getViewPosition();\n"
           "\tang = body.getViewAngles();\n"
           "\n"
           "\tang_x = 0;\n"
           "\tang_z = 0;\n"
           "\tang_y -= 90;\n"
           "\tdir = sys.angToForward( ang ); // TinMan: Convert angles (pitch yaw roll), to forward vector (x y z).\n"
           "\n"
           "\tfrac = sys.tracePoint( pos, pos + ( dir * maxRange ), CONTENTS_OPAQUE | MASK_SHOT_RENDERMODEL, body );\n"
           "\n"
           "\t//float debugTime = 0.01;\n"
           "\t/*\n"
           "\ttraceDistance = frac * maxRange; // TinMan: Convert the fraction of trace completed to game units\n"
           "\ttracePosition = sys.getTraceEndPos(); // TinMan: Get where trace hit\n"
           "\n"
           "\tsys.debugLine( '0 1 1', pos, pos + ( dir * maxRange ), debugTime ); // TinMan: *debug* full trace\n"
           "\tsys.debugBounds( '1 0 0', pos + '-1 -1 -1', pos + '1 1 1' , debugTime ); // TinMan: *debug* show bound at eyes\n"
           "\n"
           "\tsys.debugLine( '0 1 0', pos, tracePosition,\tdebugTime ); // TinMan: *debug* trace\n"
           "\tsys.debugBounds( '1 1 0', tracePosition + '-2 -2 -2', tracePosition + '2 2 2' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\t*/\n"
           "\n"
           "\tif ( frac != 1 ) {\n"
           "\t\treturn false;\n"
           "\t}\n"
           "\t\t\n"
           "\ttracePosition = sys.getTraceEndPos(); // TinMan: Get where trace hit\n"
           "\tpushPosition = pushPointIntoAAS( tracePosition );\n"
           "\t\n"
           "\t// TinMan: Do cheap canhit enemy from here\n"
           "\tentity enemy = getEnemy();\n"
           "\tif ( enemy ) {\n"
           "\t\t//sys.debugLine( '0 1 0', tracePosition, tracePosition + ( getAIAimTargets( enemy ) - tracePosition ) * 2048,\tdebugTime ); // TinMan: *debug* trace\n"
           "\t\tfrac = sys.tracePoint( tracePosition, tracePosition + ( getAIAimTargets( enemy, 2 ) - tracePosition ) * 2048, CONTENTS_OPAQUE | MASK_SHOT_RENDERMODEL, body );// TinMan: can you see enemy from this new position?\n"
           "\t\tif ( sys.getTraceEntity() != enemy ) {\n"
           "\t\t\t//tracePosition = sys.getTraceEndPos();\n"
           "\t\t\t//sys.debugBounds( '1 0 0', tracePosition + '-2 -2 -2', tracePosition + '2 2 2' , debugTime ); // TinMan: *debug*\n"
           "\t\t\t//sys.println( \"[\" + sys.getTime() + \"][checkStrafeLeft][cannot see enemy from strafe pos]\" ); // TinMan: *debug*\n"
           "\t\t\treturn false;\n"
           "\t\t}\n"
           "\t}\n"
           "\t\n"
           "\t\n"
           "\t//sys.debugBounds( '1 1 0', pushPosition + '-2 -2 -2', pushPosition + '2 2 2' , debugTime ); // TinMan: *debug*\n"
           "\tif ( !testMoveToPosition( pushPosition ) ) {\n"
           "\t\t// sys.println( \"[\" + sys.getTime() + \"][checkStrafeLeft][cannot moveto strafe pos]\" ); // TinMan: *debug*\n"
           "\t\treturn false; \t\n"
           "\t}\t\t\n"
           "\n"
           "\treturn true;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::checkMoveForward\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot::checkMoveForward() {\n"
           "\tvector\tpos, ang, dir, tracePosition;\n"
           "\tfloat maxRange, frac, traceDistance;\n"
           "\tentity\ttraceEntity;\n"
           "\n"
           "\tmaxRange = SABOT_CHECK_MOVE_DISTANCE; // TinMan: Max a bounds trace can do is 4096.\n"
           "\n"
           "\t//pos = getViewPosition();\n"
           "\tpos = body.getOrigin();\n"
           "\tang = body.getViewAngles();\n"
           "\n"
           "\tang_x = 0;\n"
           "\tang_z = 0;\n"
           "\tdir = sys.angToForward( ang ); // TinMan: Convert angles (pitch yaw roll), to forward vector (x y z).\n"
           "\n"
           "\tfrac = sys.tracePoint( pos, pos + ( dir * maxRange ), CONTENTS_OPAQUE | MASK_SHOT_RENDERMODEL, body );\n"
           "\n"
           "\ttraceDistance = frac * maxRange; // TinMan: Convert the fraction of trace completed to game units\n"
           "\ttracePosition = sys.getTraceEndPos(); // TinMan: Get where trace hit\n"
           "\n"
           "\t/*\n"
           "\tfloat debugTime = 0.01;\n"
           "\tsys.debugLine( '0 1 1', pos, pos + ( dir * maxRange ), debugTime ); // TinMan: *debug* full trace\n"
           "\tsys.debugBounds( '1 0 0', pos + '-1 -1 -1', pos + '1 1 1' , debugTime ); // TinMan: *debug* show bound at eyes\n"
           "\t*/\n"
           "\n"
           "\t/*\n"
           "\tsys.debugLine( '0 1 0', pos, tracePosition,\tdebugTime ); // TinMan: *debug* trace\n"
           "\tsys.debugBounds( '1 1 0', tracePosition + '-2 -2 -2', tracePosition + '2 2 2' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\t*/\n"
           "\n"
           "\tif ( frac == 1 ) {\n"
           "\t\treturn false;\n"
           "\t}\n"
           "\t\t\n"
           "\ttracePosition = sys.getTraceEndPos(); // TinMan: Get where trace hit\n"
           "\ttracePosition = pushPointIntoAAS( tracePosition );\n"
           "\t//sys.debugBounds( '1 1 0', tracePosition + '-2 -2 -2', tracePosition + '2 2 2' , debugTime ); // TinMan: *debug*\n"
           "\tif ( !testMoveToPosition( tracePosition ) ) {\n"
           "\t\treturn false; \t\n"
           "\t}\n"
           "\t\n"
           "\treturn true;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::checkMoveBack\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot::checkMoveBack() {\n"
           "\tvector\tpos, ang, dir, tracePosition;\n"
           "\tfloat maxRange, frac, traceDistance;\n"
           "\t//entity\ttraceEntity;\n"
           "\n"
           "\tmaxRange = SABOT_CHECK_MOVE_DISTANCE; // TinMan: Max a bounds trace can do is 4096.\n"
           "\n"
           "\tpos = getViewPosition();\n"
           "\tang = body.getViewAngles();\n"
           "\n"
           "\tang_x = 0;\n"
           "\tang_z = 0;\n"
           "\tang_y += 180;\n"
           "\tdir = sys.angToForward( ang ); // TinMan: Convert angles (pitch yaw roll), to forward vector (x y z).\n"
           "\n"
           "\tfrac = sys.tracePoint( pos, pos + ( dir * maxRange ), CONTENTS_OPAQUE | MASK_SHOT_RENDERMODEL, body );\n"
           "\n"
           "\t/*\n"
           "\ttraceDistance = frac * maxRange; // TinMan: Convert the fraction of trace completed to game units\n"
           "\ttracePosition = sys.getTraceEndPos(); // TinMan: Get where trace hit\n"
           "\n"
           "\tfloat debugTime = 0.01;\n"
           "\tsys.debugLine( '0 1 1', pos, pos + ( dir * maxRange ), debugTime ); // TinMan: *debug* full trace\n"
           "\tsys.debugBounds( '1 0 0', pos + '-1 -1 -1', pos + '1 1 1' , debugTime ); // TinMan: *debug* show bound at eyes\n"
           "\n"
           "\tsys.debugLine( '0 1 0', pos, tracePosition,\tdebugTime ); // TinMan: *debug* trace\n"
           "\tsys.debugBounds( '1 1 0', tracePosition + '-2 -2 -2', tracePosition + '2 2 2' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\t*/\n"
           "\n"
           "\tif ( frac == 1 ) {\n"
           "\t\treturn false;\n"
           "\t}\n"
           "\t\t\n"
           "\ttracePosition = sys.getTraceEndPos(); // TinMan: Get where trace hit\n"
           "\ttracePosition = pushPointIntoAAS( tracePosition );\n"
           "\t//sys.debugBounds( '1 1 0', tracePosition + '-2 -2 -2', tracePosition + '2 2 2' , debugTime ); // TinMan: *debug*\n"
           "\tif ( !testMoveToPosition( tracePosition ) ) {\n"
           "\t\treturn false; \t\n"
           "\t}\n"
           "\t\n"
           "\treturn true;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::checkMoves\n"
           "TinMan: Do simple trace check in each direction and return results as flags. *todo* can't seem to do a propper negative test, doesn't matter anyway these functions are just hacks untill I delve a bit deeper into pathing.\n"
           "=====================\n"
           "*/\n"
           "float bot_sabot::checkMoves() {\n"
           "\tvector\tpos, ang, dir, tracePosition;\n"
           "\tfloat maxRange, frac, traceDistance;\n"
           "\tfloat i, moveFlags;\n"
           "\t//entity\ttraceEntity;\n"
           "\n"
           "\tmoveFlags = 0;\n"
           "\n"
           "\tmaxRange = SABOT_CHECK_MOVE_DISTANCE; // TinMan: Max a bounds trace can do is 4096.\n"
           "\n"
           "\tpos = getViewPosition();\n"
           "\tang = body.getViewAngles();\n"
           "\n"
           "\tang_x = 0;\n"
           "\tang_z = 0;\n"
           "\n"
           "\t//float debugTime = 0.01;\n"
           "\t//sys.debugBounds( '1 0 0', pos + '-1 -1 -1', pos + '1 1 1' , debugTime ); // TinMan: *debug* show bound at eyes\n"
           "\n"
           "\t// TinMan: Test fwd,right,back,left.\n"
           "\tfor( i = 1; i < 10; i = i * 2 ) {\n"
           "\t\tdir = sys.angToForward( ang ); // TinMan: Convert angles (pitch yaw roll), to forward vector (x y z).\n"
           "\n"
           "\t\tfrac = sys.tracePoint( pos, pos + ( dir * maxRange ), CONTENTS_OPAQUE | MASK_SHOT_RENDERMODEL, body );\n"
           "\n"
           "\t\ttraceDistance = frac * maxRange; // TinMan: Convert the fraction of trace completed to game units\n"
           "\t\ttracePosition = sys.getTraceEndPos(); // TinMan: Get where trace hit\n"
           "\n"
           "\t\t/*\n"
           "\t\tsys.debugLine( '0 1 1', pos, pos + ( dir * maxRange ), debugTime ); // TinMan: *debug* full trace\n"
           "\n"
           "\t\tsys.debugLine( '0 1 0', pos, tracePosition,\tdebugTime ); // TinMan: *debug* trace\n"
           "\t\tsys.debugBounds( '1 1 0', tracePosition + '-2 -2 -2', tracePosition + '2 2 2' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\t\t*/\n"
           "\n"
           "\t\tif ( frac == 1 ) {\n"
           "\t\t\tmoveFlags |= i;\n"
           "\t\t}\n"
           "\n"
           "\t\tang_y += 90;\n"
           "\t}\n"
           "\n"
           "\treturn moveFlags;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_vladimir::checkBlocked\n"
           "TinMan: Deals with being blocked while moving to destination. \n"
           "*todo* save obstacle pos and check if it's moved, if it hasn't return true so we can choose new path\n"
           "*todo* this is currenly the only func that traps in a loop, rethink if you want this.\n"
           "*todo* as of q4 blocked_by_monster etc not working\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot::checkBlocked() {\n"
           "\t//sys.println( \"[\" + sys.getTime() + \"][checkBlocked()]\" ); // TinMan: *debug*\n"
           "\tentity obstacle;\n"
           "\tvector obstacle_pos;\n"
           "\tvector delta;\n"
           "\tfloat dist;\n"
           "\tfloat endTime;\n"
           "\tvector movePosition;\n"
           "\tvector aimDir;\n"
           "\t\n"
           "\tfloat numListedEnemies;\n"
           "\tentity enemy;\n"
           "\t\n"
           "\t/* if ( ENEMY_VISIBLE ) { // TinMan: *cheaphack*\n"
           "\t\treturn false;\n"
           "\t} */\n"
           "\t\n"
           "\t/*if ( moveStatus() > MOVE_STATUS_DONE ) {\n"
           "\t\tsys.println( \"[\" + sys.getTime() + \"][checkBlocked()][Movestatus:\" + moveStatus() + \"]\" ); // TinMan: *debug*\n"
           "\t}\t*/\n"
           "\t\n"
           "\t// TinMan: *cheaphack* see if we're not moving by comparing against previous. !! Interferes with new routing (stopping for elev etc)\n"
           "\tif ( moveStatus() == MOVE_STATUS_MOVING ) {\n"
           "\t\t//sys.println( \"[\" + sys.getTime() + \"][checkBlocked()][Movestatus:\" + moveStatus() + \"]\" ); // TinMan: *debug*\n"
           "\t\tvector currentPosition;\n"
           "\t\t\n"
           "\t\tcurrentPosition = body.getOrigin();\n"
           "\t\t\n"
           "\t\tif ( lastPositionTime < sys.getTime() ) {\n"
           "\t\t\tlastPositionTime = sys.getTime() + 0.3;\n"
           "\t\t\t// TinMan: Compare current position with previous to get movement vector.\n"
           "\t\t\tdelta = currentPosition  - lastPosition;\n"
           "\t\t\tdelta_z = 0;\n"
           "\t\t\tdist = sys.vecLength( delta );\n"
           "\t\t\t\n"
           "\t\t\tlastPosition = currentPosition;\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: Haven't moved enough?\n"
           "\t\t\tif ( dist <= 2 ) {\n"
           "\t\t\t\t//sys.println( \"[\" + sys.getTime() + \"][checkBlocked][blocked by something]\" ); // TinMan: *debug*\n"
           "\t\t\t\tsaveMove();\n"
           "\t\t\t\tsetMoveWander();\n"
           "\t\t\t\tendTime = RandomDelay( 0.6, 0.7 );\n"
           "\t\t\t\twhile( sys.getTime() < endTime || dist > 16 ) {\n"
           "\t\t\t\t\tdelta = currentPosition  - lastPosition;\n"
           "\t\t\t\t\tdelta_z = 0;\n"
           "\t\t\t\t\tdist = sys.vecLength( delta ); // TinMan: set dist wandered\t\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t\t// TinMan: Do actual movement\n"
           "\t\t\t\t\tmovePosition = moveAction();\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t\t// TinMan: Lookee where we damn be going.\n"
           "\t\t\t\t\t//movePosition_z = movePosition_z + viewHeight;\n"
           "\t\t\t\t\t//setAimPosition( movePosition );\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t\t// TinMan: Check for enemies\n"
           "\t\t\t\t\tif ( findEnemies( true ) ) {\n"
           "\t\t\t\t\t\tbreak;\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t\tenemy = heardSound( false );\n"
           "\t\t\t\t\tif ( canSeeEntity( enemy, false ) ) {\n"
           "\t\t\t\t\t\tbreak;\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t\tif ( ENEMY_VISIBLE ) {\n"
           "\t\t\t\t\t\tbreak;\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t\twaitFrame();\n"
           "\t\t\t\t}\n"
           "\t\t\t\trestoreMove();\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t}\n"
           "\t\n"
           "\t/*\n"
           "\t// TinMan: *todo* Hmm doesn't seem to really trigger much at all\n"
           "\tif ( AI_BLOCKED ) {\n"
           "\t\tsys.println( \"[\" + sys.getTime() + \"][checkBlocked()][AI_BLOCKED]\" ); // TinMan: *debug*\n"
           "\t\tsaveMove();\n"
           "\t\tsetMoveWander();\n"
           "\t\tendTime = sys.getTime() + 0.8;\n"
           "\t\twhile( sys.getTime() < endTime ) {\n"
           "\t\t\t// TinMan: Lookee where we damn be going.\n"
           "\t\t\tmovePosition = getMovePosition();\n"
           "\t\t\tmovePosition_z = movePosition_z + viewHeight;\n"
           "\t\t\tsetAimPosition( movePosition );\n"
           "\t\t\t\t\t\n"
           "\t\t\t// TinMan: Do actual movement\n"
           "\t\t\tmoveForward();\n"
           "\t\t\t\t\n"
           "\t\t\t// TinMan: Check for enemies\n"
           "\t\t\tif ( findEnemies( true ) ) {\n"
           "\t\t\t\tbreak;\n"
           "\t\t\t}\n"
           "\t\t\tenemy = heardSound( false );\n"
           "\t\t\tif ( canSeeEntity( enemy, false ) ) {\n"
           "\t\t\t\tbreak;\n"
           "\t\t\t}\n"
           "\t\t\twaitFrame();\n"
           "\t\t}\n"
           "\t\trestoreMove();\n"
           "\t} else*/ if ( moveStatus() == MOVE_STATUS_BLOCKED_BY_MONSTER ) { // TinMan: *todo* as of q4 not set\n"
           "\t\t//sys.println( \"[\" + sys.getTime() + \"][checkblocked][blocked by monster]\" ); // TinMan: *debug*\n"
           "\t\tobstacle = getObstacle();\n"
           "\t\tobstacle_pos = obstacle.getOrigin(); // TinMan: This wil come in handy later.\n"
           "\t\n"
           "\t\tsaveMove();\n"
           "\t\tsetMoveWander();\n"
           "\t\tendTime = sys.getTime() + 0.8;\n"
           "\t\twhile( sys.getTime() < endTime ) {\n"
           "\t\t\t// TinMan: Do actual movement\n"
           "\t\t\tmovePosition = moveAction();\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: Lookee where we damn be going.\n"
           "\t\t\t//movePosition = getMovePosition();\n"
           "\t\t\tif ( /* AI_ONGROUND && */ movePosition != body.getOrigin() ) {\n"
           "\t\t\t\taimDir = movePosition - body.getOrigin();\n"
           "\t\t\t\tsetAimDirection( aimDir );\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: Compare current position with previous to get movement vector.\n"
           "\t\t\tdelta = obstacle_pos - obstacle.getOrigin();\n"
           "\t\t\tdelta_z = 0;\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: Check for enemies\n"
           "\t\t\tif ( findEnemies( true ) ) {\n"
           "\t\t\t\tbreak;\n"
           "\t\t\t}\n"
           "\t\t\tenemy = heardSound( false );\n"
           "\t\t\tif ( canSeeEntity( enemy, false ) ) {\n"
           "\t\t\t\tbreak;\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: Yay it moved enough.\n"
           "\t\t\tif ( sys.vecLength( delta ) >= 4 ) {\n"
           "\t\t\t\t//sys.println( \"[\" + sys.getTime() + \"][\" + me + \"][checkBlocked][obstacle moved]\" ); // TinMan: *debug*\n"
           "\t\t\t\tbreak;\n"
           "\t\t\t}\n"
           "\t\t\twaitFrame();\n"
           "\t\t}\n"
           "\t\trestoreMove();\n"
           "\t}\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::checkShot\n"
           "TinMan: Find what we would hit if we fired. Bounds shot from eyes along viewangles. Itchy itch trigger finger.\n"
           "When bounds are used to decide whether to fire gives nice simulation of player pulling trigger when enemy near crosshair.\n"
           "*todo* axis align bounding box if possible.\n"
           "*todo* false if trace dist < min weapon range? checkaimedshot would override. also would have to make sure bot weaponswitches to something that can.\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot::checkShot( boolean simple ) {\n"
           "\tvector\tpos, ang, dir, tracePosition;\n"
           "\tfloat maxRange, frac, traceDistance;\n"
           "\tentity\ttraceEntity;\n"
           "\tfloat gameType;\n"
           "\tfloat boundSize, halfBound;\n"
           "\tvector boundMins, boundMaxs;\n"
           "\n"
           "\tmaxRange = 4090; // TinMan: Max a bounds trace can do is 4096.\n"
           "\t\n"
           "\t/*\n"
           "\tboundSize = 8;\n"
           "\thalfBound = boundSize / 2;\n"
           "\t\n"
           "\tboundMins_x = -halfBound;\n"
           "\tboundMins_y = -halfBound;\n"
           "\tboundMins_z = -halfBound;\n"
           "\tboundMaxs_x = halfBound;\n"
           "\tboundMaxs_y = halfBound;\n"
           "\tboundMaxs_z = halfBound;\n"
           "\t*/\n"
           "\n"
           "\tpos = getViewPosition();\n"
           "\tdir = sys.angToForward( body.getViewAngles() ); // TinMan: Convert angles (pitch yaw roll), to forward vector (x y z).\n"
           "\n"
           "\tif ( simple ) {\n"
           "\t\tfrac = sys.tracePoint( pos, pos + ( dir * maxRange ), MASK_SOLID|CONTENTS_BODY, body );  //  CONTENTS_OPAQUE | MASK_SHOT_RENDERMODEL\n"
           "\t} else { // TinMan: Bounds trace\n"
           "\t\tfrac = sys.trace( pos, pos + ( dir * maxRange ), '-4 -4 -4', '4 4 4', MASK_SOLID|CONTENTS_BODY, body );\n"
           "\t}\n"
           "\ttraceEntity = sys.getTraceEntity(); // TinMan: Get what was hit by trace\n"
           "\n"
           "\ttraceDistance = frac * maxRange; // TinMan: Convert the fraction of trace completed to game units\n"
           "\t// TinMan: Hmm, do straight maths, or call function ( which returns value allready calculated when trace func was called. )\n"
           "\t//tracePosition = pos + ( dir * traceDistance ); // TinMan: Get where trace hit\n"
           "\ttracePosition = sys.getTraceEndPos(); // TinMan: Get where trace hit\n"
           "/*\n"
           "\tfloat debugTime = 0.01;\n"
           "\t//sys.debugLine( '0 1 1', pos, pos + ( dir * maxRange ), debugTime ); // TinMan: *debug* full trace\n"
           "\tsys.debugBounds( '1 0 0', pos + '-1 -1 -1', pos + '1 1 1' , debugTime ); // TinMan: *debug* show bound at eyes\n"
           "\n"
           "\tsys.debugLine( '0 1 0', pos, tracePosition,\tdebugTime ); // TinMan: *debug* trace\n"
           "\n"
           "\tsys.debugBounds( '1 1 0', tracePosition + '-4 -4 -4', tracePosition + '4 4 4' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\t//sys.debugBounds( '0 0.5 1', traceEntity.getOrigin() + traceEntity.getMins(), traceEntity.getOrigin() + traceEntity.getMaxs(), debugTime ); // TinMan: *debug* hilite hit ent\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][Trace Hit: \" + traceEntity.getName() + \"]\" ); // TinMan: *debug*\n"
           "\n"
           "\tsys.debugBounds( '1 0 1', getAimPosition() + '-4 -4 -4', getAimPosition() + '4 4 4', debugTime ); // TinMan: *debug* show bound at aimPos\n"
           "\t//sys.debugBounds( '1 1 0', body.getOrigin() + getMins() + '-2 -2 -2', body.getOrigin() + getMaxs() + '2 2 2' , debugTime ); // TinMan: *debug* aimPos reset\n"
           "\n"
           "\t//sys.debugLine( '0 1 0', body.getOrigin(), body.getOrigin() + getLinearVelocity(),\tdebugTime ); // TinMan: *debug* trace velocity\n"
           "*/\n"
           "\n"
           "\t// TinMan: Oh my god I think we hit something. Charles, I think we hit something!\n"
           "\tif ( traceEntity ) {\n"
           "\t\tstring type = getClassType( traceEntity );\n"
           "\t\tif ( type == \"idPlayer\" ) {\n"
           "\t\t\t// TinMan: Friendly fire check. I swear his orange hunting jacket look just like a prize buck officer!\n"
           "\t\t\tif ( isTeamGame() ) {\n"
           "\t\t\t\tif ( getTeam( traceEntity ) != getTeam( body ) ) {\n"
           "\t\t\t\t\treturn true;\n"
           "\t\t\t\t}\n"
           "\t\t\t} else {\n"
           "\t\t\t\treturn true;\n"
           "\t\t\t}\n"
           "\t\t} else if ( traceDistance < 64 && type == \"idBrittleFracture\"  ) { // TinMan: Breakable glass *todo* this will hurt if the bot got rockets.\n"
           "\t\t\treturn true;\n"
           "\t\t} /* else if ( traceDistance > 128 && type == \"idExplodingBarrel\"  ) { // TinMan: *todo* a wider cansee check for barrels to shoot when enemy is near.\n"
           "\t\t\treturn true;\n"
           "\t\t} */\n"
           "\t}\n"
           "\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::checkAimedShot\n"
           "TinMan: See if bot is aimed at given position and if a shot would make it. *todo* test with diff aimrates, add FF check\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot::checkAimedShot( vector aimDir, float range ) {\n"
           "\tvector viewDir, tracePosition, eyePosition;\n"
           "\tfloat ang;\n"
           "\tfloat frac, maxRange;\n"
           "\t\n"
           "\tfloat aim_ang_delta = getFloatKey( \"aim_ang_delta\" ); // TinMan: *todo* global?\n"
           "\n"
           "\tmaxRange = 4090; // TinMan: Max a bounds trace can do is 4096.\n"
           "\n"
           "\teyePosition = getViewPosition();\n"
           "\tviewDir = sys.angToForward( body.getViewAngles() );\t// TinMan: Vector of where bot is looking\n"
           "\n"
           "\tang = sys.DotProduct( sys.vecNormalize( viewDir ), sys.vecNormalize( aimDir ) );\n"
           "\tang = acos( ang ); // TinMan: Angle between viewDir and aimDir\n"
           "\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][checkAimedShot][viewDir<>aimDir Ang:\" + ang + \"]\" ); // TinMan: *debug*\n"
           "\tif ( ang < aim_ang_delta ) { // TinMan: Minimal angle between the two so must be looking at aimed spot. Frankenstein says: I like nice mice.\n"
           "\t\t// TinMan: Figure out if bots shot will make it to the intended range\n"
           "\t\tfrac = sys.tracePoint( eyePosition, eyePosition + aimDir * maxRange, MASK_SOLID|CONTENTS_BODY, body );  //  CONTENTS_OPAQUE | MASK_SHOT_RENDERMODEL\n"
           "\n"
           "\t\t//traceDistance = frac * maxRange; // TinMan: Convert the fraction of trace completed to game units\n"
           "\t\ttracePosition = sys.getTraceEndPos(); // TinMan: Get where trace hit\n"
           "\n"
           "/*\n"
           "\t\tfloat debugTime = 0.01;\n"
           "\t\tvector pos = eyePosition;\n"
           "\t\tsys.debugBounds( '1 0 0', pos + '-1 -1 -1', pos + '1 1 1' , debugTime ); // TinMan: *debug* show bound at eyes\n"
           "\n"
           "\t\tsys.debugLine( '0 1 0', pos, tracePosition,\tdebugTime ); // TinMan: *debug* trace\n"
           "\t\tsys.debugBounds( '1 1 0', tracePosition + '-2 -2 -2', tracePosition + '2 2 2' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\n"
           "\t\tsys.debugLine( '1 0 0', pos, pos + aimDir,\tdebugTime ); // TinMan: *debug* trace\n"
           "//\t\tsys.debugBounds( '1 0 0', aimPosition + '-2 -2 -2', aimPosition + '2 2 2' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "entity trent = sys.getTraceEntity();\n"
           "*/\n"
           "\n"
           "\t\t// TinMan: Nope, tracce shorter than range. Something in the way of shot.\n"
           "\t\tif ( body.distanceToPoint( tracePosition ) + 32 < range ) { // TinMan: traceDistance should have buffer since it will be shorter than aimPosition due to the trace hitting the model, of course my buffer is rough and inaccurate.\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][checkAimedShot][aimDir blocked][traceRange: \" + body.distanceToPoint( tracePosition ) + \"][range: \" + range + \"][Hit: \" + trent.getName() + \"]\" ); // TinMan: *debug*\n"
           "\t\t\treturn false;\n"
           "\t\t} else {\n"
           "\t\t\treturn true;\n"
           "\t\t}\n"
           "\t}\n"
           "\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::chooseWeapon\n"
           "TinMan: Chose weapon based on range.\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::chooseWeapon( float range ) {\n"
           "\tfloat w;\n"
           "\tstring weap, bestWeapon;\n"
           "\tfloat maxWeapons, weaponPriority, bestPriority;\n"
           "\t\n"
           "\tvector weapRange;\n"
           "\t\n"
           "\t// TinMan: *cheaphack* limit weapon switching *todo* test'n'tweak\n"
           "\tif ( sys.getTime() < lastWeaponSwitch ) {\n"
           "\t\t\treturn;\n"
           "\t}\n"
           "\tlastWeaponSwitch = sys.getTime() + 0.1;\n"
           "\t\n"
           "\tmaxWeapons = 32;\t\n"
           "\n"
           "\tfor ( w = 0; w < maxWeapons; w++ ) {\n"
           "\t\tweap = body.getKey( \"def_weapon\" + w );\n"
           "\t\tif ( !weap ) {\n"
           "\t\t\tbreak;\n"
           "\t\t}\n"
           "\t\t\t\t\n"
           "\t\t//sys.println( \"[\" + sys.getTime() + \"][chooseWeapon][weapon[\" + w + \"]: \" + weap + \"]\" ); // TinMan: *debug*\n"
           "\t\tif ( hasWeapon( weap ) && hasAmmoForWeapon( weap ) ) { // TinMan: *todo* at least a certain ammount?\n"
           "\t\t\t//sys.println( \"[\" + sys.getTime() + \"][chooseWeapon][hasWeapon: \" + weap + \"]\" ); // TinMan: *debug*\n"
           "\t\t\t\n"
           "\t\t\tif ( range != -1 ) { // TinMan: Bypass range\n"
           "\t\t\t\tweapRange = getVectorKey( \"range_\" + weap ); // TinMan: Grab ranges from def\n"
           "\t\t\t\tif ( range < weapRange_y || range > weapRange_z ) { // TinMan: Weapon out of min max ranges of current enemy dist.\n"
           "\t\t\t\t\t//sys.println( \"[\" + sys.getTime() + \"][chooseWeapon][\" + weap + \" range: \" + weapRange + \"][out of range: \" + range + \"]\" ); // TinMan: *debug*\n"
           "\t\t\t\t\tcontinue; // TinMan: weapon not good for range, chose next weapon\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\tweaponPriority = getFloatKey( \"priority_\" + weap ); // TinMan: Grab priority from def *todo* ismultiplayer _mp\n"
           "\t\t\t//sys.println( \"[\" + sys.getTime() + \"][chooseWeapon][weapon: \" + weap + \"][priority: \" + weaponPriority + \"]\" ); // TinMan: *debug*\t\t\t\n"
           "\t\t\t\n"
           "\t\t\tif ( weaponPriority > bestPriority ) {\n"
           "\t\t\t\tbestPriority = weaponPriority;\n"
           "\t\t\t\tbestWeapon = weap;\t\n"
           "\t\t\t\t//sys.println( \"[\" + sys.getTime() + \"][chooseWeapon][bestWeapon: \" + bestWeapon + \"]\" ); // TinMan: *debug*\t\t\t\n"
           "\t\t\t}\n"
           "\t\t}\t\n"
           "\t}\n"
           "\t\n"
           "\t//sys.println( \"[\" + sys.getTime() + \"][chooseWeapon][bestWeapon: \" + bestWeapon + \"]\" ); // TinMan: *debug*\n"
           "\tif ( !bestWeapon ) {\n"
           "\t\treturn;\n"
           "\t}\n"
           "\t\n"
           "\tif ( bestWeapon != currentWeapon ) {\n"
           "\t\tbody.selectWeapon( bestWeapon );\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::predictTargetPosition\n"
           "Frankenstein says: I got my eyes from the corpse of the mikeBot.\n"
           "TinMan: Lead target\n"
           "*todo* sort out loop, it's a mess\n"
           "*todo* throw out, has been replaced by getaimdir\n"
           "=====================\n"
           "*/\n"
           "vector bot_sabot::predictTargetPosition( vector targetPosition, vector myPosition, vector targetVelocity ) {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][predictTargetPosition]\" ); // TinMan *debug*\n"
           "\tfloat travelTime = 0.0; // time for projectile to reach target\n"
           "\tfloat timeEstimate; \t\t// estimated time for projectile arrival\n"
           "\tfloat predictError; \t\t// error in target location\n"
           "\tfloat loopCount;\n"
           "\tvector targetLocation = targetPosition; // = targetVelocity;\n"
           "\n"
           "\tfloat debugTime = 0.01;\n"
           "\n"
           "\tfloat predictLoopMaximum = 10;\n"
           "\tfloat predictErrorTollerance = 0.1;\n"
           "\n"
           "\tpredictError = 100;\n"
           "\n"
           "\tfloat projectileSpeed = 0;\n"
           "\tprojectileSpeed = getIntKey( \"projectile_\" + currentWeapon ); // TinMan: How speedy are the shooty shooty kill kills?\n"
           "\t\n"
           "\tif ( projectileSpeed == -1 ) { // TinMan: no predict\n"
           "\t\treturn myPosition - targetLocation;\t\n"
           "\t}\n"
           "\t\n"
           "\t// TinMan: *todo* maybe a bug here, gettin div by zeros, I think this is the only place I'm doing division. That would mean projectileSpeed is 0. Sort it out.\n"
           "\tif ( projectileSpeed == 0 ) {\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][predictTargetPosition][!!projectileSpeed == 0]\" ); // TinMan *debug*\n"
           "\t\tprojectileSpeed = 1;\n"
           "\t}\n"
           "\n"
           "\tfor ( loopCount = 0; loopCount < predictLoopMaximum; loopCount++ ) {\n"
           "\t\ttargetLocation = travelTime * targetVelocity + targetLocation; // TinMan: This will shift each loop as traveTime is changed\n"
           "\t\t//sys.debugBounds( '1 0.5 0.5', targetLocation + '-2 -2 -2', targetLocation + '2 2 2' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][predictTargetPosition][\" + loopCount + \"]\" ); // TinMan *debug*\n"
           "\t\ttimeEstimate = sys.vecLength( myPosition - targetLocation ) / projectileSpeed; // TinMan: Estimate of how long it will take projectile to reach targetLocation\n"
           "\t\tpredictError = timeEstimate - travelTime;\n"
           "\t\ttravelTime = timeEstimate;\n"
           "\t\tif ( predictError < predictErrorTollerance ) {\n"
           "\t\t\tbreak;\n"
           "\t\t}\n"
           "\t}\n"
           "\n"
           "\t//sys.debugLine( '0 1 1', pos, pos + ( dir * maxRange ), debugTime ); // TinMan: *debug* full trace\n"
           "\t/* sys.debugLine( '1 0 0', myPosition, targetLocation,\tdebugTime ); // TinMan: *debug* trace from self to predicted position\n"
           "\tsys.debugLine( '0 1 0', targetPosition, targetPosition + targetVelocity,\tdebugTime ); // TinMan: *debug* trace from  target along predicted direction\n"
           "\tsys.debugLine( '1 0 1', myPosition, targetPosition,\tdebugTime );\n"
           "\tsys.debugBounds( '0.5 1 0.2', targetPosition + '-1 -1 -1', targetPosition + '1 1 1' , debugTime );\n"
           "\tsys.debugBounds( '1 0.5 0.5', targetLocation + '-2 -2 -2', targetLocation + '2 2 2' , debugTime );\n"
           "\t*/\n"
           "\n"
           "\treturn targetLocation;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::addAimVariation\n"
           "TinMan: Add variation to aiming so it's not so damn good. I call this the drunkeness factor.\n"
           "*todo* just a cheaphack needs rethinking.\n"
           "=====================\n"
           "*/\n"
           "vector bot_sabot::addAimVariation( vector aimDir ) {\n"
           "\tfloat t, attackAccuracy;\n"
           "\tvector viewAng;\n"
           "\t\t\t\n"
           "\tattackAccuracy  = getFloatKey( \"aim_accuracy\" );\n"
           "\tattackAccuracy += getFloatKey( \"aim_accuracy_\" + currentWeapon  );\n"
           "\t\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][addAimVariation][attackAccuracy: \" + attackAccuracy + \"]\" ); // TinMan *debug*\n"
           "\t\n"
           "\tif ( attackAccuracy == 0 ) { // TinMan: No aim variation. uberbot.\n"
           "\t\treturn aimDir;\n"
           "\t}\n"
           "\n"
           "\tt = sys.getTime() * 50;\n"
           "\tviewAng = sys.VecToAngles( aimDir );\n"
           "\tviewAng_x += sys.sin( t * 5 ) * attackAccuracy;\n"
           "\tviewAng_y\t+= sys.sin( t * 6 ) * attackAccuracy;\n"
           "\n"
           "\tviewAng = sys.angToForward( viewAng );\n"
           "\t\n"
           "\t// TinMan: Convert angles back to position\n"
           "\t//viewAng = eyePosition + viewAng * sys.vecLength( aimDir );\n"
           "\n"
           "\t/*\n"
           "\t// TinMan: *debug*\n"
           "\tfloat maxRange = 2048; // TinMan: Max a bounds trace can do is 4096.\n"
           "\tvector viewDir = sys.angToForward( body.getViewAngles() ); // TinMan: Convert angles (pitch yaw roll), to forward vector (x y z).\n"
           "\n"
           "\tfloat frac = sys.tracePoint( eyePosition, eyePosition + viewDir * maxRange, MASK_SOLID|CONTENTS_BODY, body );  //  CONTENTS_OPAQUE | MASK_SHOT_RENDERMODEL\n"
           "\n"
           "\tvector tracePosition = sys.getTraceEndPos(); // TinMan: Get where trace hit\n"
           "\n"
           "\tfloat debugTime = 0.01;\n"
           "\tsys.debugBounds( '1 0 0',  eyePosition + '-1 -1 -1',  eyePosition + '1 1 1' , debugTime ); // TinMan: *debug* show bound at eyes\n"
           "\tsys.debugLine( '0 1 0',  eyePosition, tracePosition,\tdebugTime ); // TinMan: *debug* trace\n"
           "\tsys.debugBounds( '1 1 0', tracePosition + '-2 -2 -2', tracePosition + '2 2 2' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\n"
           "\tsys.debugBounds( '1 0 0', aimPosition + '-2 -2 -2', aimPosition + '2 2 2' , debugTime ); // TinMan: *debug*\n"
           "\t*/\n"
           "\t\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][addAimVariation][before: \" + aimDir + \"][after: \" + viewAng + \"]\" ); // TinMan *debug*\n"
           "\n"
           "\treturn viewAng;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::getItemPriority\n"
           "TinMan: Find out what the priority of this entity is. How shiny shiny.\n"
           "=====================\n"
           "*/\n"
           "float bot_sabot::getItemPriority( entity item ) {\n"
           "\tfloat priority;\n"
           "\tstring itemName, prefix, classType;\n"
           "\tfloat\titemType;\n"
           "\tfloat len;\n"
           "\tfloat health, maxHealth, armor, maxArmor, ammo;\n"
           "\n"
           "\titemName = getClassName( item ); // TinMan: Get the name of the item\n"
           "\t// TinMan: Strip mp suffix\n"
           "\tlen = sys.strLength( itemName ) - 3;\n"
           "\tif ( sys.strSkip( itemName, len ) == \"_mp\" ) {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][getItemPriority][itemName: \" + sys.strLeft( itemName, len ) + \"]\" ); // TinMan *debug*\n"
           "\t\titemName = sys.strLeft( itemName, len );\n"
           "\t}\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][getItemPriority][itemName: \" + itemName + \"]\" ); // TinMan *debug*\n"
           "\t\n"
           "\tclassType = getClassType( item );\n"
           "\tif ( classType == \"idMoveableItem\" ) {\n"
           "\t\titemName = sys.strSkip( itemName, sys.strLength( \"moveable_item_\" ) ); // TinMan: Nasty\n"
           "\t\titemName = \"weapon_\" + itemName; // TinMan: Also cheap *todo* better, this obviously doesn't handle other movables, why did id soft name them moveable_item_machinegun etc instead of moveable_weapon_machinegun. Waaaaaaa!\n"
           "\t}\n"
           "\t\n"
           "\t// TinMan: Grab priority from def *todo* oldski *rem*\n"
           "\tpriority = getFloatKey( \"priority_\" + itemName ); \n"
           "\tif ( !priority ) {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][getItemPriority][No Priority for: \" + itemName + \"]\" ); // TinMan *debug*\n"
           "\t\treturn 0;\n"
           "\t}\n"
           "\n"
           "\t// TinMan: see if we've allready stored the itemtype\t\n"
           "\titemType = item.getFloatKey( \"itemType\" );\n"
           "\tif ( itemType == -1 ) {\n"
           "\t\t//debugPrint( \"getItemPriority\", \"Not an item: \" + itemName );\n"
           "\t\treturn 0;\n"
           "\t}\n"
           "\t\n"
           "\tif ( !itemType ) {\n"
           "\t\t// TinMan: Lets us diferentiate between items\n"
           "\t\tprefix = sys.strLeft( itemName, 4 );\n"
           "\t\tif ( prefix == \"ammo\" ) {\n"
           "\t\t\titemType = SABOT_ITEMTYPE_AMMO;\n"
           "\t\t} else if ( prefix == \"weap\" ) {\n"
           "\t\t\titemType = SABOT_ITEMTYPE_WEAPON;\n"
           "\t\t} else if ( prefix == \"item\" ) {\n"
           "\t\t\tprefix = sys.strLeft( itemName, 10 ); // TinMan: item_medkit, item_armor\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][getItemPriority][prefix: \" + prefix + \"]\" ); // TinMan *debug*\n"
           "\t\t\tif ( prefix == \"item_healt\" ) {\n"
           "\t\t\t\titemType = SABOT_ITEMTYPE_HEALTH;\n"
           "\t\t\t} else if ( prefix == \"item_armor\" ) {\n"
           "\t\t\t\titemType = SABOT_ITEMTYPE_ARMOR;\n"
           "\t\t\t} else {\n"
           "\t\t\t\titemType = SABOT_ITEMTYPE_ITEM;\n"
           "\t\t\t}\n"
           "\t\t} else if ( prefix == \"powe\" ) {\n"
           "\t\t\titemType = SABOT_ITEMTYPE_POWERUP;\n"
           "\t\t} else if ( prefix == \"mp_c\" || prefix == \"domi\" ) { // TinMan: mp_ctf_ *todo* domination\n"
           "\t\t\titemType = SABOT_ITEMTYPE_TEAM;\n"
           "\t\t} else {\n"
           "\t\t\t//itemType = SABOT_ITEMTYPE_NONE;\n"
           "\t\t\titemType == -1;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\titem.setKey( \"itemType\", itemType ); // TinMan: Store it so we don't have to do it again.\n"
           "\t}\n"
           "\n"
           "\tif ( itemType == SABOT_ITEMTYPE_AMMO ) {\n"
           "\t\tpriority = getFloatKey( \"priority_goal_ammo\" ); // TinMan: Get base priority\n"
           "\t\tpriority += getFloatKey( \"priority_\" + itemName ); // TinMan: Add specific priority\n"
           "\t\t//len = sys.strLength( itemName ) - 6; // TinMan: Strip off suffix ( _small, _large = 6 chars )\n"
           "\t\t//itemName = sys.strLeft( itemName, len );\n"
           "\t\tammo = hasAmmo( itemName );\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][getItemPriority][bot has: \" + ammo + \": \" + itemName + \"]\" ); // TinMan *debug*\n"
           "\t\tif ( ammo >= body.getFloatKey( \"max_\" + itemName ) ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][getItemPriority][bot has full: \" + itemName + \"]\" ); // TinMan *debug*\n"
           "\t\t\tpriority = 0;\n"
           "\t\t} else if ( ammo < 10 ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][getItemPriority][bot has no: \" + itemName + \"]\" ); // TinMan *debug*\n"
           "\t\t\tpriority += 5;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: *todo*\n"
           "\t\t//ammo current current weapon 20, 25?\n"
           "\t\t//\tand low ammo 40 (higher than default enemy\n"
           "\t\t\n"
           "\t} else if ( itemType == SABOT_ITEMTYPE_WEAPON ) {\n"
           "\t\t\n"
           "\t\t/*\n"
           "\t\tpriority = getFloatKey( \"priority_goal_weapon\" ); // TinMan: Get base priority\n"
           "\t\tpriority += getFloatKey( \"priority_\" + itemName ); // TinMan: Add specific priority\n"
           "\t\tif ( !hasWeapon( itemName ) ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][getItemPriority][bot doesn't have: \" + itemName + \"]\" ); // TinMan *debug*\n"
           "\t\t\tpriority += 5;\n"
           "\t\t}\n"
           "\t\tif ( getFloatKey( \"priority_\" + itemName ) > getFloatKey( \"priority_\" + currentWeapon ) ) { // TinMan: It's a better weapon than current\n"
           "\t\t\tpriority += 5;\n"
           "\t\t}\n"
           "\t\t*/\n"
           "\t\t\n"
           "\t\t// TinMan: *todo* and very low ammo + 10\n"
           "\t\t// TinMan: *todo* it's a dropped weapon +5\n"
           "\t\t\n"
           "\n"
           "\t\tif ( !hasWeapon( itemName ) || !hasAmmoForWeapon( itemName ) ) {\n"
           "\t\t\tpriority += getFloatKey( \"priority_goal_weapon\" ); // TinMan: Get base priority\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tpriority += getFloatKey( \"priority_\" + itemName ); // TinMan: Add specific priority\t\t\n"
           "\t\tif ( getFloatKey( \"priority_\" + itemName ) > getFloatKey( \"priority_\" + currentWeapon ) ) { // TinMan: It's a better weapon than current\n"
           "\t\t\tpriority += 5;\n"
           "\t\t}\n"
           "\n"
           "\t\t\n"
           "\t} else if ( itemType == SABOT_ITEMTYPE_HEALTH ) {\n"
           "\t\tpriority = getFloatKey( \"priority_goal_health\" ); // TinMan: Get base priority\n"
           "\t\tpriority += getFloatKey( \"priority_\" + itemName ); // TinMan: Add specific priority\t\n"
           "\t\t\n"
           "\t\thealth = getActorHealth( body );\n"
           "\t\tmaxHealth = body.getFloatKey( \"maxhealth\" );\n"
           "\t\t\n"
           "\t\t// sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][getItemPriority][Health: \" + health + \"][Maxhealth: \" + maxHealth + \"]\" ); // TinMan *debug*\n"
           "\t\t\n"
           "\t\tif ( health < maxHealth ) {\n"
           "\t\t\tif ( health < 40 ) {\n"
           "\t\t\t\tpriority += 10;\n"
           "\t\t\t\t//priority = 45;\n"
           "\t\t\t}\n"
           "\t\t\tif ( health < 20 ) {\n"
           "\t\t\t\tpriority += 10;\n"
           "\t\t\t\t//priority = 55;\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tif ( item.getFloatKey( \"inv_bonushealth\" ) > 50 ) { // TinMan: Handle stuff that can boost ya past max, ie mega\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][getItemPriority][Health: \" + health + \"][Maxhealth: \" + maxHealth + \"]\" ); // TinMan *debug*\n"
           "\t\t\t\tpriority += 10;\n"
           "\t\t\t} else {\n"
           "\t\t\t\tpriority = 0;\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t} else if ( itemType == SABOT_ITEMTYPE_ARMOR ) {\n"
           "\t\tif ( itemName != \"item_armor_shard\" ) {\n"
           "\t\t\tpriority = getFloatKey( \"priority_goal_armor\" ); // TinMan: Get base priority\n"
           "\t\t}\n"
           "\t\tpriority += getFloatKey( \"priority_\" + itemName ); // TinMan: Add specific priority\t\n"
           "\t\tarmor = getArmor( body );\n"
           "\t\tmaxArmor = body.getFloatKey( \"maxarmor\" );\n"
           "\t\t\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][getItemPriority][Armor: \" + armor + \"][Maxarmor: \" + maxArmor + \"]\" ); // TinMan *debug*\n"
           "\t\t\n"
           "\t\tif ( armor < maxArmor ) {\n"
           "\t\t\tif ( armor < 40 ) {\n"
           "\t\t\t\tpriority += 5;\n"
           "\t\t\t}\n"
           "\t\t\tif ( armor < 20 ) {\n"
           "\t\t\t\tpriority += 5;\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tpriority = 0;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t} else if ( itemType == SABOT_ITEMTYPE_POWERUP ) { // TinMan: *todo* don't get powerup if allready have one\n"
           "\t\tpriority = getFloatKey( \"priority_goal_powerup\" ); // TinMan: Get base priority\n"
           "\t\tpriority += getFloatKey( \"priority_\" + itemName ); // TinMan: Add specific priority\n"
           "\t\t\n"
           "\t\tif ( powerUpActive() ) { // TinMan: allready have a powerup *todo* can you drop powerups? if so we might wan't to decide which is better\n"
           "\t\t\tpriority = 0;\t\n"
           "\t\t}\t\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][getItemPriority][Powerup: \" + itemName + \"][prio: \" + priority + \"]\" ); // TinMan *debug*\n"
           "\t} else if ( itemType == SABOT_ITEMTYPE_TEAM ) { // TinMan: *todo* could change priorities on flags depending on team and role\n"
           "\t\tpriority = getFloatKey( \"priority_goal_team\" ); // TinMan: Get base priority\n"
           "\t\tpriority += getFloatKey( \"priority_\" + itemName ); // TinMan: Add specific priority\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][getItemPriority][Team: \" + itemName + \"][prio: \" + priority + \"]\" ); // TinMan *debug*\n"
           "\t\t\n"
           "\t\t// mp_ctf_marine_flag\n"
           "\t\t// mp_ctf_strogg_flag\n"
           "\t\tif ( gameType == GAME_DOMINATION ) {\n"
           "\t\t\tif ( item.getFloatKey( \"team\" ) == team ) {\n"
           "\t\t\t\tpriority = 0;\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t} else {\n"
           "\t\tsys.warning( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][getItemPriority][Unknown itemtype: \" + itemName + \"][prio: \" + priority + \"]\" ); // TinMan *debug*\n"
           "\t}\n"
           "\t\n"
           "\tif ( priority ) { // TinMan: *todo* *test\n"
           "\t\tif ( body.distanceTo( item ) < 128 ) {\n"
           "\t\t\tpriority += 20;\n"
           "\t\t}\n"
           "\t}\n"
           "\t\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][getItemPriority][\" + itemName + \" Priority: \" + priority + \"]\" ); // TinMan *debug*\n"
           "\t/* if ( priority ) {\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][getItemPriority][\" + itemName + \" Priority: \" + priority + \"]\" ); // TinMan *debug*\n"
           "\t} */\n"
           "\t\n"
           "\treturn priority;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::getPlayerPriority\n"
           "TinMan: How much do we want to kill this badass\n"
           "=====================\n"
           "*/\n"
           "float bot_sabot::getPlayerPriority( entity badass ) {\n"
           "\tfloat priority, weaponPriority;\n"
           "\tstring playerWeapon;\n"
           "\tentity enemy;\n"
           "\t\t\n"
           "\tplayerWeapon = badass.getCurrentWeapon();\n"
           "\tweaponPriority = getFloatKey( \"priority_\" + playerWeapon ); // TinMan: Grab priority from def\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][getPlayerPriority][weapon: \" + playerWeapon + \"][\" + weaponPriority + \"]\" ); // TinMan *debug*\n"
           "\n"
           "\tpriority = getFloatKey( \"priority_goal_enemy\" ); // TinMan: Get base priority\n"
           "\t\n"
           "\t//priority += 10 - weaponPriority; // TinMan: weaker weapon = higher priority\n"
           "\t\n"
           "\t//if ( getFloatKey( \"priority_\" + currentWeapon ) > weaponPriority ) {\n"
           "\t //priority += 5;\n"
           "\t//}\n"
           "\t//if ( getFloatKey( \"priority_\" + currentWeapon ) < weaponPriority ) {\n"
           "\t\t//priority -= 5;\n"
           "\t//}\n"
           "\t\n"
           "\t// TinMan: enemy gots my flag, kill im!\n"
           "\tif ( isCTF() ) {\n"
           "\t\tif ( getFlagCarrier( 1 - team ) == badass ) {\n"
           "\t\t\tpriority += 20;\n"
           "\t\t}\n"
           "\t}\n"
           "\t\n"
           "\tfloat dist = body.distanceTo( badass );\n"
           "\tif ( dist < 128 ) { // TinMan: *todo* no magic\n"
           "\t\tpriority += 20;\t\n"
           "\t}\n"
           "\t\n"
           "\tenemy = getEnemy();\n"
           "\tif ( enemy ) {\n"
           "\t\tif ( badass != enemy ) {\n"
           "\t\t\tif ( body.distanceTo( badass ) < body.distanceTo( enemy ) - 128 ) { // TinMan: omigosh this guy is closer *todo* tweak fudge factor\n"
           "\t\t\t\tpriority += 10;\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\t// TinMan: *todo* see where this is being used? yup current enemy is slipping in as newenemy because of cheapo handling of enemy coming back into view\n"
           "\t\t\tpriority += 5;// TinMan: *cheaphack* ^\n"
           "\t\t\t//sys.warning( \"[\" + int( sys.getTime() ) + \"][getPlayerPriority][wtf badass = enemy]\" ); // TinMan *debug*\n"
           "\t\t}\n"
           "\t}\n"
           "\t\n"
           "\tentity obsticle = getObstacle();\n"
           "\tif ( badass == getObstacle() ) {// TinMan: if player blocking our path then that's a problem. *cheaphack* *todo* rethink\n"
           "\t\tpriority += 20;\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][getPlayerPriority][blockin me foo!][\" + badass.getName() + \" Priority: \" + priority + \"]\" ); // TinMan *debug*\n"
           "\t}\n"
           "\n"
           "/*\n"
           "\tsys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][getPlayerPriority][\" + badass.getName() + \" Priority: \" + priority + \"]\" ); // TinMan *debug*\n"
           "\tif ( enemy ) {\n"
           "\t\tif ( enemy != badass ) {\n"
           "\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][getPlayerPriority][\" + enemy.getName() + \" enemyPriority: \" + goalPriority + \"]\" ); // TinMan *debug*\t\n"
           "\t\t}\n"
           "\t}\n"
           "*/\n"
           "\n"
           "\t// TinMan: *todo* *test*\n"
           "\tif ( checkSelf() ) {\n"
           "\t\tpriority -= 10;\n"
           "\t}\n"
           "\t\n"
           "\tif ( getActorHealth( badass ) < 20 ) {\n"
           "\t\tpriority += 10;\n"
           "\t}\n"
           "\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][getPlayerPriority][\" + badass.getName() + \" HP: \" + getActorHealth( badass ) + \" ARM: \" + getArmor( badass ) + \" Weap: \" + weaponPriority + \" Priority: \" + priority + \"]\" ); // TinMan *debug*\n"
           "\treturn priority;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::chooseGoal\n"
           "TinMan: \n"
           "Note: This function is somewhat expensive since nearly all entities found are reachability checked in getItemPriority.\n"
           "Note: Debug output is off by one.\n"
           "=====================\n"
           "*/\n"
           "entity bot_sabot::chooseGoal() {\n"
           "\tfloat i, numListedEntities;\n"
           "\tfloat itemPriority, bestPriority;\n"
           "\tfloat dist, bestDist;\n"
           "\tfloat radius;\n"
           "\tentity item, bestGoal;\n"
           "\t\n"
           "\tclearGoal();\n"
           "\tclearNewGoal();\n"
           "\t\n"
           "\tbestGoal = $null_entity;\n"
           "\t\n"
           "\t// TinMan: *CTF* flag goals\n"
           "\tif ( isCTF() ) {\n"
           "\t\tif ( getFlagCarrier( team ) == body ) { // TinMan: w00t we gots teh falg!\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][chooseGoal][!have flag!]\" ); // TinMan *debug*\n"
           "\t\t\tbestGoal = ourFlag;\n"
           "\t\t\tnewGoalPosition = ourCap;\n"
           "\t\t\tnewMoveType = SABOT_MOVETYPE_POSITION; // TinMan: can't do entity since the flag might be taken en route\n"
           "\t\t\tif ( body.distanceToPoint( newGoalPosition ) > 64 ) {\n"
           "\t\t\t\tnewGoalType = SABOT_GOAL_MOVE;\n"
           "\t\t\t} else { // TinMan: Close enough, camp it\n"
           "\t\t\t\tnewGoalType = SABOT_GOAL_HOLD;\n"
           "\t\t\t}\n"
           "\t\t\tnewGoalPriority = getFloatKey( \"priority_goal_team\" );\n"
           "\t\t} else if ( role == SABOT_ROLE_OFFENCE ) {\n"
           "\t\t\tbestGoal = theirFlag;\n"
           "\t\t\tnewGoalPosition = theirCap;\n"
           "\t\t\tnewMoveType = SABOT_MOVETYPE_POSITION;\n"
           "\t\t\t\n"
           "\t\t\tif ( body.distanceToPoint( newGoalPosition ) > 128 ) { // TinMan: Not near goal, so move to it\n"
           "\t\t\t\tnewGoalType = SABOT_GOAL_MOVE;\n"
           "\t\t\t} else { // TinMan: Close enough\n"
           "\t\t\t\t/*\n"
           "\t\t\t\tif ( getFlagStatus( 1 - team ) == FLAGSTATUS_INBASE ) { // TinMan: It's there, grab it\n"
           "\t\t\t\t\tbestGoal = theirFlag;\n"
           "\t\t\t\t\tnewMoveType = SABOT_MOVETYPE_ENTITY;\n"
           "\t\t\t\t\tnewGoalPriority = getFloatKey( \"priority_goal_team\" );\n"
           "\t\t\t\t} else { // TinMan: Not there, camp it */\n"
           "\t\t\t\t\tnewGoalType = SABOT_GOAL_HOLD;\n"
           "\t\t\t\t// }\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\tnewGoalPosition = bestGoal.getOrigin();\n"
           "\t\t\t//newGoalPriority = getFloatKey( \"priority_goal_team\" );\n"
           "\t\t\tnewGoalPriority = getFloatKey( \"priority_goal_weapon\" ); // TinMan: On route to flag we still want to grab goodies\n"
           "\t\t}  else if ( role == SABOT_ROLE_DEFENCE ) {\n"
           "\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][chooseGoal][defence][goal: ourFlag]\" ); // TinMan *debug*\n"
           "\t\t\tbestGoal = ourFlag;\n"
           "\t\t\tnewGoalPosition = ourCap;\n"
           "\t\t\tnewMoveType = SABOT_MOVETYPE_POSITION;\n"
           "\t\t\t\n"
           "\t\t\tif ( body.distanceToPoint( newGoalPosition ) > 128 ) { // TinMan: Not near goal, so move to it\n"
           "\t\t\t\tnewGoalType = SABOT_GOAL_MOVE;\n"
           "\t\t\t} else { // TinMan: Close enough\n"
           "\t\t\t\tnewGoalType = SABOT_GOAL_HOLD;\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\tnewGoalPosition = bestGoal.getOrigin();\n"
           "\t\t\t//newGoalPriority = getFloatKey( \"priority_goal_team\" );\n"
           "\t\t\tnewGoalPriority = getFloatKey( \"priority_goal_weapon\" ); // TinMan: On route to flag we still want to grab goodies\n"
           "\t\t} \n"
           "\t\t\n"
           "\t\t// TinMan: Check if goal can be reached *todo* think about how you are going to handle unreachable goal. *todo* hmm it's ok if enemy is unreachable, he might not be later, or you still might be able to shoot him\n"
           "\t\tif ( bestGoal ) {\n"
           "\t\t\tif ( newMoveType = SABOT_MOVETYPE_POSITION ) {\n"
           "\t\t\t\tif ( !canReachPosition( bestGoal.getOrigin() ) ) {\n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][chooseGoal][can't reach goal position]\" ); // TinMan *debug*\n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][chooseGoal][newGoalPosition: \" + newGoalPosition + \"]\" ); // TinMan *debug*\n"
           "\t\t\t\t\tclearGoal();\n"
           "\t\t\t\t\tbestGoal = $null_entity;\n"
           "\t\t\t\t}\n"
           "\t\t\t} else {\n"
           "\t\t\t\tif ( !canReachEntity( bestGoal ) ) {\n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][chooseGoal][can't reach goal]\" ); // TinMan *debug*\n"
           "\t\t\t\t\tclearGoal();\n"
           "\t\t\t\t\tbestGoal = $null_entity;\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tif ( !bestGoal ) { // TinMan: Can't CTF so roam\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][chooseGoal][!!No CTF Goal!!]\" ); // TinMan *debug*\n"
           "\t\t\trole = roleDefault;\n"
           "\t\t}\n"
           "\t}\n"
           "\t\n"
           "\t// TinMan: Find an item to hunt. Want l00t!\n"
           "\tif ( role == SABOT_ROLE_ROAM ) {\n"
           "\t\tnumListedEntities = findItems();\n"
           "\t\t// sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][chooseGoal][numListedEntities: \" + numListedEntities + \"]\" ); // TinMan *debug*\n"
           "\t\tfor ( i = 0; i < numListedEntities; i++ ) {\n"
           "\t\t\titem = getEntityList( i );\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][chooseGoal][listedEntity[\" + i + \"] : \" + item.getName() +  \"]\" ); // TinMan *debug* \" : \" + getClassName( item ) +\n"
           "\t\t\t// TinMan: *todo* rethink\n"
           "\t\t\tif ( item == oldGoal ) {\n"
           "\t\t\t\tcontinue;\n"
           "\t\t\t}\n"
           "\t\t\n"
           "\t\t\tif ( item.isHidden() ) { // TinMan: *todo* Shouldnt really do a ishidden but at the moment this is stopping ping pong and adding variation\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][chooseGoal][hidden]\" ); // TinMan *debug*\n"
           "\t\t\t\tcontinue;\n"
           "\t\t\t}\n"
           "\t\t\titemPriority = getItemPriority( item );\n"
           "\t\t\tif ( !itemPriority ) {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][chooseGoal][no item priority]\" ); // TinMan *debug*\n"
           "\t\t\t\tcontinue;\n"
           "\t\t\t}\n"
           "\t\t\tif ( itemPriority > bestPriority ) {\n"
           "\t\t\t\tif ( canReachEntity( item ) ) {\n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][chooseGoal][canreach item: \" + item.getName() + \"]\" ); // TinMan *debug*\n"
           "\t\t\t\t\tbestPriority = itemPriority;\n"
           "\t\t\t\t\tbestGoal = item;\n"
           "\t\t\t\t} /* else {\n"
           "\t\t\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][chooseGoal][!canreach item]\" ); // TinMan *debug*\n"
           "\t\t\t\t} */\n"
           "\t\t\t} else if ( itemPriority == bestPriority ) { // TinMan: If item has same priority get closest, of course staright distance check is cheap and may not be the closest item due to travel time.\n"
           "\t\t\t\tdist = body.distanceTo( item );\n"
           "\t\t\t\tbestDist = body.distanceTo( bestGoal );\n"
           "\t\t\t\t//dist = travelDistanceToEntity( item ); // TinMan: expensive *todo* see how many enities reach this point, though of course the reall killed comes with far away ents\n"
           "\t\t\t\t//bestDist = travelDistanceToEntity( bestGoal );\n"
           "\t\t\t\tif ( dist < bestDist ) {\n"
           "\t\t\t\t\tif ( canReachEntity( item ) ) {\n"
           "\t\t\t\t\t\tbestGoal = item;\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\n"
           "\t\tnewGoalType = SABOT_GOAL_MOVE;\n"
           "\t\tnewMoveType = SABOT_MOVETYPE_ENTITY;\n"
           "\t\tnewGoalPriority = getFloatKey( \"priority_goal_item\" ); // TinMan: Pretty much anything will override this goal.\n"
           "\t\t\n"
           "\t\t/*if ( bestGoal ) {\n"
           "\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][chooseGoal][goal: \" + getClassName( bestGoal ) + \"][priority: \" + newGoalPriority + \"]\" ); // TinMan *debug*\n"
           "\t\t} */\n"
           "\t}\n"
           "\t\n"
           "\tif ( bestGoal ) {\n"
           "\t\tnewGoal = bestGoal;\n"
           "\t}\n"
           "\t\n"
           "\treturn bestGoal; // TinMan: This is the goodest loot\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::lookForGoal\n"
           "TinMan: Look for nice and shiny baubles to gather.\n"
           "=====================\n"
           "*/\n"
           "entity bot_sabot::lookForGoal( float useFov ) {\n"
           "\tfloat i, numListedEntities;\n"
           "\tfloat itemPriority, bestPriority;\n"
           "\tfloat dist, bestDist;\n"
           "\tfloat radius;\n"
           "\tfloat maxHeight, minHeight;\n"
           "\tentity item;\n"
           "\tvector origin, itemOrigin;\n"
           "\tstring classType;\n"
           "\n"
           "\tentity bestGoal;\n"
           "\t\n"
           "\tclearNewGoal(); // TinMan: Wipe the slate, and your nose.\n"
           "\n"
           "\tradius = 512; // *todo*: *demagic* *tweak*\n"
           "\t\n"
           "\tbestDist = radius;\n"
           "\t\n"
           "\tmaxHeight = 128;\n"
           "\tminHeight = 64;\n"
           "\t\n"
           "\torigin = body.getOrigin();\n"
           "\t\n"
           "\tnumListedEntities = findInRadius( origin, radius );\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][lookForGoal][numListedEntities: \" + numListedEntities + \"]\" ); // TinMan *debug*\n"
           "\tfor ( i = 0; i < numListedEntities; i++ ) {\n"
           "\t\titem = getEntityList( i );\n"
           "\t\t\n"
           "\t\t/*\n"
           "\t\tif ( !item ) {\n"
           "\t\t\tgameLocal.Error( \"[\" + int( sys.getTime() ) + \"][lookForGoal][NULL item]\" ); // TinMan: *debug*\n"
           "\t\t}\n"
           "\t\t*/\n"
           "\t\t\n"
           "\t\t/*\n"
           "\t\tif ( item == goal ) {\n"
           "\t\t\tcontinue;\n"
           "\t\t}\n"
           "\t\t*/\n"
           "\t\t\n"
           "\t\t// TinMan: *todo* rethink\n"
           "\t\tif ( item == oldGoal ) {\n"
           "\t\t\tcontinue;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Filter entities to the type we want\n"
           "\t\tclassType = getClassType( item );\n"
           "\t\tif ( classType != \"idItem\" && classType != \"idItemPowerup\" && classType != \"idMoveableItem\" && classType != \"rvItemCTFFlag\" ) {\n"
           "\t\t\tcontinue;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: *cheaphack* skip those too hight or low. I think I got tunnel vision *todo* rethink.\n"
           "\t\titemOrigin = item.getOrigin();\n"
           "\t\tif ( itemOrigin_z > origin_z + maxHeight || itemOrigin_z < origin_z - minHeight ) {\n"
           "\t\t\tcontinue;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\titemPriority = getItemPriority( item ); // TinMan: Sort out health and armour, stuff that he can't pick up when he's full, the glutton.\n"
           "\t\t\n"
           "\t\tif ( !itemPriority ) {\n"
           "\t\t\tcontinue;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tif ( itemPriority < goalPriority ) {\n"
           "\t\t\t\tcontinue;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][lookForGoal][listedEntity[\" + i + \"]:\" + item.getName() + \"][Prioriy: \" + itemPriority + \"]\" ); // TinMan *debug* \" \n"
           "\t\t//if ( canSeePosition( item.getOrigin(), true ) && item.isHidden() ) { // TinMan: If we can see it's not there. *todo* is this working at all?\n"
           "\t\tif ( item.isHidden() ) {\n"
           "\t\t\tcontinue;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tif ( classType == \"idMoveableItem\" && !canSeeEntity( item, false ) ) { // TinMan: we don't know where moveables are like static items\n"
           "\t\t\tcontinue;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tif ( !ENEMY_DEAD && !canSeeEntity( item, false ) ) { // TinMan: *cheaphack, only go for item you can see when fighting\n"
           "\t\t\tcontinue;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tif ( isCTF() ) {\n"
           "\t\t\tif ( item == theirFlag ) {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][\" + getClassName( item ) +  \"][thierflag]\" ); // TinMan *debug* \" \n"
           "\t\t\t\tif ( getFlagStatus( 1 - team ) == FLAGSTATUS_TAKEN ) { // TinMan: Whee dawgy there goes that enemy flag\n"
           "\t\t\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][\" + getClassName( item ) +  \"][thierflag: taken]\" ); // TinMan *debug* \" \n"
           "\t\t\t\t\tif ( getFlagCarrier( team ) != body ) { // TinMan: A buddy has it. For great justice.\n"
           "\t\t\t\t\t\tcontinue;\n"
           "\t\t\t\t\t} /* else {\n"
           "\t\t\t\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][\" + getClassName( item ) +  \"][thierflag]\" ); // TinMan *debug* \" \n"
           "\t\t\t\t\t} */\n"
           "\t\t\t\t} else if ( getFlagStatus( 1 - team ) == FLAGSTATUS_STRAY ) { // TinMan: must sight test stray flags becuase we don't know where they are\n"
           "\t\t\t\t\tif ( !canSeeEntity( item, false ) ) {\n"
           "\t\t\t\t\t\tcontinue;\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][\" + getClassName( item ) +  \"][thierflag]\" ); // TinMan *debug* \" \n"
           "\t\t\t} else if ( item == ourFlag ) {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][\" + getClassName( item ) +  \"][ourflag]\" ); // TinMan *debug* \" \n"
           "\t\t\t\tif ( getFlagStatus( team ) != FLAGSTATUS_STRAY || !canSeeEntity( item, false ) ) { // TinMan: Only time we want our flag is if it's stray.\n"
           "\t\t\t\t\tcontinue;\n"
           "\t\t\t\t}\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][\" + getClassName( item ) +  \"][ourflag]\" ); // TinMan *debug* \" \n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tif ( dist < 128 ) { // TinMan: *cheaphack* Very close *todo* move to getitmempriority\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][lookForGoal][very close:\"  + getClassName( item ) +  \"]\" ); // TinMan: *debug*\n"
           "\t\t\titemPriority += 10;\n"
           "\t\t}\n"
           "\t\t//dist = body.distanceTo( item ); // TinMan: Simple\n"
           "\t\tdist = travelDistanceToEntity( item ); // TinMan: expensive, but heaps better ( side benefit of route being cached for canreach and actual move )\n"
           "\t\t//if ( dist < bestDist ) {\n"
           "\t\tif ( bestPriority < itemPriority ) {\n"
           "\t\t\tif ( canReachEntity( item ) ) {\n"
           "\n"
           "\t\t\t\t/* if ( goal ) {\n"
           "\t\t\t\t\tif ( travelDistanceBetweenEntities( goal, item ) > travelDistanceToEntity( goal ) + 256 ) { // TinMan: *todo* *test*\n"
           "\t\t\t\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][lookForGoal][traveldist too high:\"  + getClassName( item ) +  \"]\" ); // TinMan: *debug*\n"
           "\t\t\t\t\t\tcontinue;\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t\t*/\n"
           "\t\t\t\tbestDist = dist;\n"
           "\t\t\t\tbestGoal = item;\n"
           "\t\t\t\tbestPriority = itemPriority;\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\n"
           "\t\t/* if ( bestGoal ) {\n"
           "\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][\" + i + \": \" + getClassName( item ) +  \"][dist: \" + int( dist ) + \"][priority: \" + bestPriority +  \"]\" ); // TinMan *debug* \" \n"
           "\t\t} */\n"
           "\t}\n"
           "\t\n"
           "\t/*\n"
           "\tif ( bestGoal ) {\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][lookForGoal][bestGoal: \" + bestGoal.getName() + \" of [\" + numListedEntities + \"]]\" ); // TinMan *debug*\n"
           "\t}\n"
           "\t*/\n"
           "\t\n"
           "\t// TinMan: This is the goodest loot\n"
           "\tif ( bestGoal ) {\n"
           "\t\tnewGoal = bestGoal;\n"
           "\t\tnewGoalPriority = bestPriority;\n"
           "\t\tnewGoalType = SABOT_GOAL_MOVE;\n"
           "\t\tnewMoveType = SABOT_MOVETYPE_ENTITY;\n"
           "\t}\n"
           "\n"
           "\treturn bestGoal;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::lookForEnemies\n"
           "TinMan: Searches for enemies. You must know where the hurty men are.\n"
           "=====================\n"
           "*/\n"
           "entity bot_sabot::lookForEnemies( float useFov ) {\n"
           "\tfloat i, numListedEnemies;\n"
           "\tentity thisEnemy, bestEnemy;\n"
           "\tfloat priority, bestPriority, dist, bestDist;\n"
           "\t\n"
           "\tbestDist = 999999;\n"
           "\t\n"
           "\tnumListedEnemies = findEnemies( useFov );\n"
           "\tfor ( i = 0; i < numListedEnemies; i++ ) {\n"
           "\t\tthisEnemy = getEntityList( i );\n"
           "\t\t\n"
           "\t\tpriority = getPlayerPriority( thisEnemy );\n"
           "\t\t\n"
           "\t\tif ( priority > bestPriority ) {\n"
           "\t\t\tbestPriority = priority;\n"
           "\t\t\tbestEnemy = thisEnemy;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t/*\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][lookForEnemy][listedEnemy[\" + i + \"] : \" + thisEnemy.getName() +  \"]\" ); // TinMan: *debug*\n"
           "\t\tdist = body.distanceTo( thisEnemy );\n"
           "\t\tif ( dist < ( bestDist ) ) { // TinMan: *cheaphack*\n"
           "\t\t\tif ( thisEnemy != getEnemy() ) {\n"
           "\t\t\t\tbestDist = dist;\n"
           "\t\t\t\tbestEnemy = thisEnemy;\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t*/\n"
           "\t}\n"
           "\n"
           "\t/* if ( bestEnemy ) {\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][lookForEnemy][bestEnemy: \" + bestEnemy.getName() + \" of [\" + i + \"]]\" ); // TinMan *debug*\n"
           "\t} */\n"
           "\n"
           "\treturn bestEnemy; // TinMan: He be the badest of the bad\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::listenForEnemies\n"
           "TinMan: I think I hear something in the basement dear. heardSound is only really geared towards single player ai with one player causing a ruckus.\n"
           "=====================\n"
           "*/\n"
           "entity bot_sabot::listenForEnemies() {\n"
           "\tentity newEnemy;\n"
           "\t\n"
           "\t/*\n"
           "\tif ( heardSound( false ) ) {\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][listenForEnemies][heardsound]\" ); // TinMan: *debug*\n"
           "\t}\n"
           "\t*/\n"
           "\n"
           "\tnewEnemy = heardSound( false );\n"
           "\tif ( newEnemy == getEnemy() || !canSeeEntity( newEnemy, false ) ) { // TinMan: Visible but not in fov *todo* hmm\n"
           "\t\tnewEnemy = $null_entity;\n"
           "\t}\n"
           "\n"
           "\treturn newEnemy;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::isCTF\n"
           "TinMan:\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot::isCTF() {\n"
           "\tif ( gameType == GAME_CTF || gameType == GAME_ARENA_CTF ) {\n"
           "\t\treturn true;\n"
           "\t}\n"
           "\treturn false;\n"
           "}\n"
           "\n";
}

/*******************************************************************************
SABot - Stupid Angry Bot - release alpha 9
"I obey these words, written in my head. I think they are spelled wrong."

bot_sabot_main.script
***********************************************************************/
idStr botAi::GetBotMainScript(void)
{
    idStr source = GetBotDefScript() +
                   "// TinMan: Path types, sync with game code\n"
                   "#define\tPATHTYPE_WALK\t\t\t\t\t\t0\n"
                   "#define\tPATHTYPE_WALKOFFLEDGE\t\t1\n"
                   "#define\tPATHTYPE_BARRIERJUMP\t\t2\n"
                   "#define\tPATHTYPE_JUMP\t\t\t\t\t\t3\n"
                   "#define\tPATHTYPE_ELEVATOR\t\t\t\t4\n"
                   "\n"
                   "// TinMan: Game types, sync with game code\n"
                   "#define\tGAME_SP \t\t\t\t\t0\n"
                   "#define\tGAME_DM \t\t\t\t\t1\n"
                   "#define\tGAME_TOURNEY\t\t\t2\n"
                   "#define\tGAME_TDM \t\t\t\t\t3\n"
                   "#define\tGAME_CTF\t\t\t\t\t4\n"
                   "#define\tGAME_1F_CTF\t\t\t\t5\n"
                   "#define\tGAME_ARENA_CTF\t\t6\n"
                   "#define\tGAME_ARENA_1F_CTF\t7\n"
                   "// TinMan: *todo* think about a better way to handle gametypes\n"
                   "#define\tGAME_DOMINATION\t\t8\n"
                   "\n"
                   "// TinMan: *CTF* \n"
                   "#define\tFLAGSTATUS_INBASE \t\t\t\t0\n"
                   "#define\tFLAGSTATUS_STRAY\t \t\t\t\t1\n"
                   "#define\tFLAGSTATUS_TAKEN  \t\t\t\t2\n"
                   "#define\tFLAGSTATUS_TAKEN_STROGG\t\t3\n"
                   "#define\tFLAGSTATUS_TAKEN_MARINE\t\t4\n"
                   "\n"
                   "//#include \"scripts/bot_sabot_events.script\"\n"
                   "//#include \"scripts/bot_sabot_ai.script\" // TinMan: My precious\n";

    source.Append("\n");
    source.Append(GetBotEventsScript());
    source.Append("\n");
    source.Append(GetBotSabotScript());

    return source;
}

idStr botAi::GetBotDefScript(void)
{
    // from scripts/doom_defs.script
    return "\n"
           "#define true 1\n"
           "#define false 0\n"
           "#define CONTENTS_SOLID 1 // an eye is never valid in a solid\n"
           "#define CONTENTS_BODY 256 // used for actors\n"
           "#define CONTENTS_OPAQUE 2 // blocks visibility (for ai)\n"
           "#define CONTENTS_RENDERMODEL 2048 // used for render models for collision \n"
           "#define MASK_SOLID (CONTENTS_SOLID)\n"
           "#define MASK_SHOT_RENDERMODEL (CONTENTS_SOLID|CONTENTS_RENDERMODEL)\n"
           "// RAVEN BEGIN\n"
           "// abahr: added sys. so we can call this from non object functions\n"
           "#define eachFrame for( 0; 1; sys.waitFrame() )\n"
           "// RAVEN END\n"
           "\n"
            ;
}