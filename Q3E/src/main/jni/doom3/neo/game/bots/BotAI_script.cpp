
/***********************************************************************
Doom3Bots - Open bot framework for Doom 3
release 1 - "Beware of TinMans horrifying code"

bot_base
Base for bot scripts
***********************************************************************/
idStr botAi::GetBotBaseScript(void)
{
    return "object bot_base {\n"
           "\t// TinMan: Movement control - script/bot->gamecode/fakeclient - Reset each frame\n"
           "\tboolean\t\tAI_FORWARD;\n"
           "\tboolean\t\tAI_BACKWARD;\n"
           "\tboolean\t\tAI_STRAFE_LEFT;\n"
           "\tboolean\t\tAI_STRAFE_RIGHT;\n"
           "\tboolean\t\tAI_JUMP;\n"
           "\tboolean\t\tAI_CROUCH;\n"
           "\t\n"
           "\t// TinMan: Movement control - script/bot->gamecode/fakeclient\n"
           "\tboolean\t\tAI_RUN;\n"
           "\t\n"
           "\t// TinMan: Fire control - script/bot->gamecode/fakeclient - Reset each frame\n"
           "\tboolean\t\tAI_WEAPON_FIRE;\n"
           "\t\n"
           "\t// TinMan: Body status - gamecode/fakeclient->script/bot\n"
           "\tboolean\t\tAI_DEAD;\n"
           "\tboolean\t\tAI_PAIN;\n"
           "\tboolean\t\tAI_ONGROUND;\n"
           "\tboolean\t\tAI_TELEPORT;\n"
           "\n"
           "\t// TinMan: Currently unused\t\n"
           "\tboolean\t\tAI_ATTACK_HELD;\n"
           "\tboolean\t\tAI_WEAPON_FIRED;\n"
           "\tboolean\t\tAI_ONLADDER;\n"
           "\tboolean\t\tAI_HARDLANDING;\n"
           "\tboolean\t\tAI_SOFTLANDING;\n"
           "\tboolean\t\tAI_RELOAD;\n"
           "\tboolean\t\tAI_TURN_LEFT;\n"
           "\tboolean\t\tAI_TURN_RIGHT;\n"
           "\t\n"
           "\t// TinMan: Enemy status - gamecode->script\n"
           "\tboolean\t\tAI_ENEMY_VISIBLE;\n"
           "\tboolean\t\tAI_ENEMY_IN_FOV;\n"
           "\tboolean\t\tAI_ENEMY_DEAD;\n"
           "\t\n"
           "\t// TinMan: Movement status - gamecode->script\n"
           "\tboolean\t\tAI_MOVE_DONE;\n"
           "\tboolean\t\tAI_DEST_UNREACHABLE;\n"
           "\tboolean\t\tAI_ENEMY_REACHABLE;\n"
           "\tboolean\t\tAI_BLOCKED;\n"
           "\tboolean\t\tAI_OBSTACLE_IN_PATH;\n"
           "\t\n"
           "\t// TinMan: Currently unused\n"
           "\tboolean\t\tAI_PUSHED;\n"
           "\t\n"
           "\t// TinMan: *todo* shoddy, pull out for q4\n"
           "\tboolean\t\tBOT_COMMAND;\n"
           "\tfloat \t\tBOT_COMMAND_TYPE;\n"
           "\tstring \t\tBOT_COMMAND_ENTITY;\n"
           "\tvector\t\tBOT_COMMAND_VECTOR;\n"
           "\t\t\n"
           "\t\n"
           "\t// TinMan: Globalistics\n"
           "\tstring\t\tme;\n"
           "\tstring\t\tname;\n"
           "\t\n"
           "\tentity\t\tbody;\n"
           "\n"
           "\tweapon_base weapon;\n"
           "\tstring\t\tcurrentWeapon;\n"
           "\t\n"
           "\t// TinMan: States\n"
           "\tvoid \t\t\tstate_Begin();\n"
           "\tvoid \t\t\tstate_Killed();\n"
           "\t\n"
           "\t// TinMan: Functions\n"
           "\tvoid \t\t\tmoveForward();\n"
           "\tvoid \t\t\tmoveBackward();\n"
           "\tvoid \t\t\tmoveRight();\n"
           "\tvoid \t\t\tmoveLeft();\n"
           "};\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_base::init\n"
           "=====================\n"
           "*/\n"
           "void bot_base::init() {\n"
           "\tme\t\t= getName();\n"
           "\tname \t=\tgetKey( \"npc_name\" );\n"
           "\t\n"
           "\tbody \t= getBody(); // TinMan: Grab fakeclient entity.\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_base::destroy\n"
           "TinMan: Clean up stuff for when script is killed.\n"
           "=====================\n"
           "*/\n"
           "void bot_base::destroy() {\n"
           "\twaitFrame();\n"
           "}\n"
           "\n"
           "/***********************************************************************\n"
           "\n"
           "\tStates - Main AI\n"
           "\n"
           "***********************************************************************/\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_base::state_Begin\n"
           "TinMan: Basic setup. Wakey wakey, rise 'n' shine.\n"
           "=====================\n"
           "*/\n"
           "void bot_base::state_Begin() {\n"
           "\twaitFrame();\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_base::state_Idle\n"
           "TinMan: Default fallback state\n"
           "=====================\n"
           "*/\n"
           "void bot_base::state_Idle() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Idle]\" ); // TinMan *debug*\n"
           "\twaitFrame();\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::state_Killed\n"
           "TinMan: botAi hijacks script when bots fakeclient is AI_DEAD, sets state to this.\n"
           "=====================\n"
           "*/\n"
           "void bot_base::state_Killed() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + name + \"][Died]\" ); // TinMan: *debug*\n"
           "\tstopMove();\n"
           "\t\n"
           "\twhile( AI_DEAD ) {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + name + \"][state_Killed][waiting]\" ); // TinMan: *debug*\n"
           "\t\t\n"
           "\t\tfloat nextFire;\n"
           "\t\tif ( sys.getTime() > nextFire ) {\n"
           "\t\t\tnextFire = sys.getTime() + 0.1;\n"
           "\t\t\tAI_WEAPON_FIRE = true; // TinMan: Fire so bot respawns\n"
           "\t\t}\n"
           "\t\twaitFrame();\n"
           "\t}\n"
           "\t\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + name + \"][Restarting]\" ); // TinMan: *debug*\n"
           "\tsetState( \"state_Begin\" );\n"
           "}\n"
           "\n"
           "/***********************************************************************\n"
           "\n"
           "\tFunctions\n"
           "\n"
           "***********************************************************************/\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_base::moveForward\n"
           "=====================\n"
           "*/\n"
           "void bot_base::moveForward() {\n"
           "\tAI_FORWARD = true;\n"
           "\tAI_BACKWARD = false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_base::moveBackward\n"
           "=====================\n"
           "*/\n"
           "void bot_base::moveBackward() {\n"
           "\tAI_BACKWARD = true;\n"
           "\tAI_FORWARD = false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_base::moveRight\n"
           "=====================\n"
           "*/\n"
           "void bot_base::moveRight() {\n"
           "\tAI_STRAFE_RIGHT = true;\n"
           "\tAI_STRAFE_LEFT = false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_base::moveLeft\n"
           "=====================\n"
           "*/\n"
           "void bot_base::moveLeft() {\n"
           "\tAI_STRAFE_LEFT = true;\n"
           "\tAI_STRAFE_RIGHT = false;\n"
           "}\n";
}

/***********************************************************************
Bot tastic framework - release numeral uno - I don't know will there ever be an official release?

bot_events.script
Events for Bot script. Obviously.
***********************************************************************/
idStr botAi::GetBotEventsScript(void)
{
    return "\n"
           "scriptEvent entity\t\tgetBody(); // TinMan: Return fake client entity.\n"
           "\n"
           "scriptEvent float\t\t\tgetGameType();\n"
           "\n"
           "scriptEvent float \t\thasWeapon( string weaponName );\n"
           "scriptEvent float \t\thasAmmoForWeapon( string weaponName );\n"
           "scriptEvent float \t\thasAmmo( string ammoName );\n"
           "\n"
           "scriptEvent\tvoid\t\t\tsetAimPosition( vector aimPosition ); // TinMan: Set where you want bot to aim, viewAngles move to this position over aimRate.\n"
           "scriptEvent\tvector\t\tgetAimPosition(); // TinMan: Get where bot is moving our aim to. If you want where bot is aiming use getViewAngles.\n"
           "scriptEvent\tvoid\t\t\tsetAimDirection( vector dir );\n"
           "scriptEvent\tvector\t\tgetMovePosition(); // TinMan: Next point on path set by a setMove.\n"
           "scriptEvent\tvector\t\tgetSecondaryMovePosition(); // TinMan: Position on path to do something, eg jump.\n"
           "scriptEvent\tfloat\t\t\tgetPathType(); // TinMan: Type of path, eg PATHTYPE_BARRIERJUMP.\n"
           "scriptEvent\tvoid\t\t\tsetMoveDirection( vector dir, float speed ); // TinMan: Set direction and speed for bot to (strafe)move in, 400 being da max. hmm, needs sprucing up with an unfunny and unrelated comment.\n"
           "\n"
           "scriptEvent\tfloat\t\t\tcanSeeEntity( entity ent, float useFov );\n"
           "scriptEvent\tfloat\t\t\tcanSeePosition( vector pos, float useFov );\n"
           "\n"
           "scriptEvent vector \t\tgetEyePosition();\n"
           "scriptEvent vector \t\tgetViewPosition();\n"
           "scriptEvent vector \t\tgetAIAimTargets( entity aimAtEnt, float head );\n"
           "\n"
           "// TinMan: Entity list functions, compiles a list and returns index.\n"
           "scriptEvent\tfloat\t\t\tfindEnemies( float onlyInFov ); // TinMan: Returns all clients and actors visible.\n"
           "scriptEvent float\t\t\tfindInRadius( vector pos, float radius, string className ); // TinMan: Classname is class type (spawnclass) of entity you want to look for eg idItem.\n"
           "scriptEvent float\t\t\tfindItems(); // TinMan: Compile list of all idItems and all idItemPowerups.\n"
           "scriptEvent entity\t\tgetEntityList( float index ); // TinMan: Used to acess entity list, should only be used imediately after using one of the above functions.\n"
           "\n"
           "// scriptEvent void\t\tstopMove(); \t// TinMan: ( allready defined in idAI ) Reset move state\n"
           "// scriptEvent float\tmoveStatus(); // TinMan: ( allready defined in idAI )\n"
           "// TinMan: Calculate a route, use getMovePosition to get where bot should go.\n"
           "scriptEvent\tvoid \t\t\tsetMoveToCover();\n"
           "scriptEvent\tvoid \t\t\tsetMoveToEnemy();\n"
           "scriptEvent\tvoid \t\t\tsetMoveOutOfRange( entity ent, float range );\n"
           "scriptEvent\tvoid \t\t\tsetMoveToAttackPosition( entity ent );\n"
           "scriptEvent\tvoid \t\t\tsetMoveWander();\n"
           "scriptEvent\tvoid \t\t\tsetMoveToEntity( entity destination );\n"
           "scriptEvent\tvoid \t\t\tsetMoveToPosition( vector position );\n"
           "\n"
           "// TinMan: Allready defined in doomevents from idAI\n"
           "// Note: traveldistance - is approximate becuase it gets travel times between area centers, when the bot is travelling of course it's path is optimised\n"
           "//scriptEvent\tfloat\ttravelDistanceToPoint( vector destination ); // Approximate travel distance to point.\n"
           "//scriptEvent\tfloat\ttravelDistanceToEntity( entity destination ); // Approximate travel distance to entity.\n"
           "//scriptEvent\tfloat\ttravelDistanceBetweenEntities( entity source, entity dest ); // Approximate travel distance between two entities.\n"
           "//scriptEvent\tfloat\ttravelDistanceBetweenPoints( vector source, vector dest ); // Approximate travel distance between two points.\n"
           "//scriptEvent entity\tgetObstacle(); // gets the obstacle in the character's path\n"
           "//scriptEvent vector\tpushPointIntoAAS( vector pos ); // tries to push the point into a valid AAS area\n"
           "\n"
           "scriptEvent void\t\t\tnextBestWeapon();\n"
           "\n"
           "// TinMan: The old integration vs independence argument, the proper way would be to integrate the following script events into different classes\n"
           "scriptEvent float\t\t \tgetActorHealth( entity actor ); // TinMan: Could be in actor\n"
           "scriptEvent float\t\t \tgetArmor( entity player ); // TinMan: Could be in player\n"
           "\n"
           "scriptEvent float\t\t \tgetTeam( entity ent ); // TinMan: Could be in actor\n"
           "\n"
           "// TinMan: Direct access to entities array\n"
           "scriptEvent entity getEntityByNum( float index );\n"
           "scriptEvent float getNumEntities();\n"
           "\n"
           "// TinMan: Could be in entity\n"
           "scriptEvent string getClassName( entity ent ); // TinMan: returns classname of entity.\n"
           "scriptEvent string getClassType( entity ent ); // TinMan: returns class type of entity.\n"
           "\n"
           "scriptEvent float\t\t\tacos( float a ); // TinMan: Could be in script sys\n"
           "\n"
           "// TinMan: *CTF*\n"
           "scriptEvent entity\t\tgetFlag( float team );\n"
           "scriptEvent float\t\t\tgetFlagStatus( float team );\n"
           "scriptEvent entity\t\tgetFlagCarrier( float team );\n"
           "scriptEvent entity\t\tgetCapturePoint( float team );\n"
           "\n"
           "// TinMan: Plat\n"
           "scriptEvent float\t\tisUnderPlat( entity plat );\n"
           "scriptEvent vector\tgetWaitPosition( entity plat );\n"
           "\n"
           "// TinMan: Command\n"
           "scriptEvent float\t\tgetCommandType();\n"
           "scriptEvent entity\tgetCommandEntity();\n"
           "scriptEvent vector\tgetCommandPosition();\n"
           "scriptEvent void\t\tclearCommand();\n"
            "\n"
            "scriptEvent entity\t\tfindOther();\n";
}

/*******************************************************************************
SABot - Stupid Angry Bot - release alpha 7 - "I'm not a puppet! I'm a real boy!"

bot_sabot
The brains of SABot. Braaaaaiiinnns!
********************************************************************************/
idStr botAi::GetBotSabotScript(void)
{
    return "#define\tSABOT_NEXT_ENEMY_LOOK\t\t\t\t\t\t\t0.2\n"
           "#define\tSABOT_NEXT_GOAL_CHOOSE\t\t\t\t\t\t1\n"
           "#define\tSABOT_NEXT_SUBGOAL_LOOK\t\t\t\t\t\t0.3\n"
           "#define\tSABOT_NEXT_AIM\t\t\t\t\t\t\t\t\t\t0.05\n"
           "\n"
           "// TinMan: Delays before reacting to events\n"
           "#define\tSABOT_REACT_TO_ENEMY\t\t\t\t\t\t\t0.2 //0.3\n"
           "#define\tSABOT_REACT_TO_ENEMY_SOUND\t\t\t\t0.3 //0.4\n"
           "#define\tSABOT_REACT_FIRE\t\t\t\t\t\t\t\t\t0.2\n"
           "\n"
           "#define\tSABOT_ENEMY_LOST_TIME\t\t\t\t\t\t\t0.6\n"
           "#define SABOT_SUBGOAL_LOST_TIME\t\t\t\t\t\t3\n"
           "\n"
           "#define\tSABOT_ENEMY_UNREACHABLE_TIME\t\t\t2\n"
           "\n"
           "#define SABOT_CHASE_TIME\t\t\t\t\t\t\t\t\t12 // TinMan: Time to chase (out of view) enemy before giving up\n"
           "#define SABOT_HOLD_TIME\t\t\t\t\t\t\t\t\t\t90\n"
           "\n"
           "#define\tSABOT_CHECK_MOVE_DISTANCE\t\t\t\t\t48\n"
           "\n"
           "// TinMan: time between random strafe changes\n"
           "#define\tSABOT_STRAFE_MIN\t\t\t\t\t\t\t\t\t1\n"
           "#define\tSABOT_STRAFE_MAX\t\t\t\t\t\t\t\t\t3\n"
           "\n"
           "// TinMan: Distances for following\n"
           "#define SABOT_FOLLOWDIST_MAX\t\t\t\t\t\t\t140\n"
           "#define SABOT_FOLLOWDIST_MIN\t\t\t\t\t\t\t100\n"
           "\n"
           "#define SABOT_GOAL_NONE\t\t\t\t\t\t\t\t\t\t\t0\n"
           "#define SABOT_GOAL_MOVE\t\t\t\t\t\t\t\t\t\t\t1\n"
           "#define SABOT_GOAL_HOLD\t\t\t\t\t\t\t\t\t\t\t2\n"
           "#define SABOT_GOAL_FOLLOW\t\t\t\t\t\t\t\t\t\t3\n"
           "#define SABOT_GOAL_ATTACK\t\t\t\t\t\t\t\t\t\t4\n"
           "#define SABOT_GOAL_WANDER\t\t\t\t\t\t\t\t\t\t5\n"
           "\n"
           "#define SABOT_ROLE_ROAM\t\t\t\t\t\t\t\t\t\t\t0\n"
           "#define SABOT_ROLE_OFFENCE\t\t\t\t\t\t\t\t\t1\n"
           "#define SABOT_ROLE_DEFENCE\t\t\t\t\t\t\t\t\t2\n"
           "\n"
           "// TinMan: Basically just used as a workaround the fact that setMoveToEntity doesn't like moving to triggers (what ctf cappoints are).\n"
           "#define SABOT_MOVETYPE_ENTITY\t\t\t\t\t\t\t\t0\n"
           "#define SABOT_MOVETYPE_POSITION\t\t\t\t\t\t\t1\n"
           "\n"
           "#define\tSABOT_ITEMTYPE_ITEM\t\t\t\t\t\t\t\t\t0\n"
           "#define\tSABOT_ITEMTYPE_WEAPON\t\t\t\t\t\t\t\t1\n"
           "#define\tSABOT_ITEMTYPE_AMMO\t\t\t\t\t\t\t\t\t2\n"
           "#define\tSABOT_ITEMTYPE_POWERUP\t\t\t\t\t\t\t3\n"
           "\n"
           "object bot_sabot : bot_base {\n"
           "\tvector\t\tweaponRange;\n"
           "\t\n"
           "\tentity \t\tgoal;\n"
           "\tvector\t\tgoalPosition;\n"
           "\tfloat\t\t\tgoalType;\n"
           "\tfloat\t\t\tgoalPriority;\n"
           "\t\n"
           "\tentity \t\toldGoal;\n"
           "\t\n"
           "\tfloat\t\t\tmoveType;\n"
           "\t\n"
           "\t// TinMan: alternate goal for comparing against current, oh yes the crudeness of script\n"
           "\tentity \t\tnewGoal;\n"
           "\tvector\t\tnewGoalPosition;\n"
           "\tfloat\t\t\tnewGoalType;\n"
           "\tfloat\t\t\tnewGoalPriority;\t\n"
           "\t\n"
           "\tfloat\t\t\trole;\n"
           "\tfloat\t\t\troleDefault;\n"
           "\t\n"
           "\tentity\t\tsubGoal;\n"
           "\t\n"
           "\tfloat \t\tteam;\n"
           "\t// TinMan: *CTF*\n"
           "\tentity\t\tourFlag;\n"
           "\tentity\t\ttheirFlag;\n"
           "\tentity\t\tourCap;\n"
           "\tentity\t\ttheirCap;\n"
           "\t\n"
           "\tfloat \t\tgameType;\n"
           "\t\n"
           "\tfloat\t\t\tviewHeight;\n"
           "\tfloat\t\t\tjumpHeight;\n"
           "\t\n"
           "\t//float\t\t\ttimerAmount;\n"
           "\t//float\t\t\ttimerStart;\n"
           "\tfloat\t\t\ttimerEnd;\n"
           "\t\n"
           "\tvector\t\tlastPosition;\n"
           "\tfloat\t\t\tlastPositionTime;\n"
           "\t\n"
           "\tfloat\t\t\tnextEnemyLookTime;\n"
           "\t\n"
           "\tvector\t\tplatTop;\n"
           "\t\n"
           "\tvoid \t\t\tdebugPrint( string func, string message );\n"
           "\n"
           "\t// TinMan: States\n"
           "\tvoid \t\t\tstate_Begin();\n"
           "\tvoid \t\t\tstate_MoveToGoal();\n"
           "\tvoid \t\t\tstate_SubGoal();\n"
           "\tvoid \t\t\tstate_Combat();\n"
           "\tvoid \t\t\tstate_CombatSubGoal();\n"
           "\tvoid\t\t\tstate_CombatRetreat();\n"
           "\tvoid \t\t\tstate_Chase();\n"
           "\tvoid\t\t\tstate_Retreat();\n"
           "\tvoid\t\t\tstate_Hold();\n"
           "\tvoid\t\t\tstate_Follow();\n"
           "\tvoid\t\t\tstate_Wander();\n"
           "\tvoid \t\t\tstate_Killed();\n"
           "\n"
           "\t// TinMan: Functions\n"
           "\tvoid \t\t\tsetNewGoal();\n"
           "\tvoid\t\t\tclearGoal();\n"
           "\tvoid\t\t\tclearNewGoal();\n"
           "\t\n"
           "\tvoid \t\t\tmoveForward();\n"
           "\tvoid \t\t\tmoveBackward();\n"
           "\tvoid \t\t\tmoveRight();\n"
           "\tvoid \t\t\tmoveLeft();\n"
           "\t\n"
           "\tvector \t\tmoveAction();\n"
           "\n"
           "\tvoid \t\t\tsetTimer( float endTime );\n"
           "\tfloat \t\tgetTimer();\n"
           "\tvoid \t\t\tclearTimer();\n"
           "\tboolean\t\tnextEnemyLook();\n"
           "\n"
           "\tboolean \tcheckGoal( entity thisGoal );\n"
           "\tboolean\t\tgotFlag();\n"
           "\tboolean \tcheckEnemy( entity thisEnemy );\n"
           "\tboolean \tcheckSelf();\n"
           "\tboolean \tcheckLeader( entity thisLeader );\n"
           "\tboolean\t\tcheckWeapon();\n"
           "\n"
           "\tboolean \tcheckStrafeLeft();\n"
           "\tboolean \tcheckStrafeRight();\n"
           "\tboolean \tcheckMoveForward();\n"
           "\tboolean \tcheckMoveBack();\n"
           "\tfloat\t\t \tcheckMoves();\n"
           "\t\n"
           "\tboolean \tcheckBlocked();\n"
           "\n"
           "\tboolean \tcheckShot( boolean simple, boolean shootEnemy );\n"
           "\tboolean \tcheckAimedShot( vector aimPosition, float range );\n"
           "\t\n"
           "\tvoid \t\t\tchooseWeapon( float range );\n"
           "\n"
           "\tvector\t\tpredictTargetPosition( vector targetPosition, vector myPosition, vector targetVelocity, float projectileSpeed );\n"
           "\tvector \t\taddAimVariation( vector aimPosition );\n"
           "\n"
           "\tvector\t\tgetAimTarget( entity target );\n"
           "\n"
           "\tfloat \t\tgetItemPriority( entity item );\n"
           "\tfloat \t\tgetPlayerPriority( entity badass );\n"
           "\tfloat \t\tgetProjectileSpeed( string weaponName );\n"
           "\n"
           "\tentity \t\tchooseGoal( entity ignoreGoal );\n"
           "\tentity \t\tlookForGoal( float ignoreLow, float useFov );\n"
           "\tentity \t\tlookForEnemies( float useFov );\n"
           "\tentity\t\tlistenForEnemies();\n"
           "};\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::init\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::init() {\n"
           "\t// TinMan: Grab your keys please\n"
           "\tviewHeight = body.getFloatKey( \"pm_normalviewheight\" );\n"
           "\tjumpHeight = body.getFloatKey( \"pm_jumpheight\" );\n"
           "\t\n"
           "\tgameType = getGameType(); // TinMan: *todo* see if gametype change restarts map (and bot), on brief look it does\n"
           "\troleDefault = SABOT_ROLE_ROAM;\n"
           "\t\n"
           "\tclearTimer();\n"
           "\t\n"
           "\tsetState( \"state_Begin\" );\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::destroy\n"
           "TinMan: Clean up stuff for when script is killed.\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::destroy() {\n"
           "\twaitFrame();\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::debugPrint\n"
           "TinMan: Sommat a leetle cleaner, lets you have more control over what bots are spamming out debug. For great justice!\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::debugPrint( string func, string message ) {\n"
           "\tif ( getIntKey( \"debug\" ) ) {\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][\" + func + \"][\" + message + \"]\" );\n"
           "\t}\n"
           "}\n"
           "\n"
           "/***********************************************************************\n"
           "\n"
           "\tStates - Main AI\n"
           "\n"
           "***********************************************************************/\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::state_Begin\n"
           "TinMan: Basic setup. Wakey wakey, rise 'n' shine.\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::state_Begin() {\n"
           "\tgameType = getGameType(); // TinMan: *todo* see if gametype change restarts map (and bot), on brief look it does\n"
           "\t\n"
           "\t// TinMan: Wait till you get your weapon.\n"
           "\twhile( !weapon ) {\n"
           "\t\tweapon = body.getWeaponEntity();\n"
           "\t\twaitFrame();\n"
           "\t}\n"
           "\t\n"
           "\tcheckWeapon(); // TinMan: Update our weapon vars (currentweapon, weaponrange)\n"
           "\t\n"
           "\tAI_RUN = true;\n"
           "\t\n"
           "\tclearGoal();\n"
           "\t\n"
           "\tclearEnemy();\n"
           "\t\n"
           "\trole = roleDefault;\n"
           "\t\n"
           "\tgameType = getGameType(); // TinMan: *todo* see if gametype change restarts map (and bot), on brief look it does\n"
           "\tif ( gameType == GAME_CTF ) {\n"
           "\t\tteam \t\t\t\t= getTeam( body );  // TinMan: *todo* see if there is any auto ballance during game that could change bots team while it's alive, else this is safe\n"
           "\t\tourFlag \t\t= getFlag( team );\n"
           "\t\ttheirFlag \t= getFlag( 1 - team );\n"
           "\t\tourCap \t\t\t= getCapturePoint( team );\n"
           "\t\ttheirCap \t\t= getCapturePoint( 1 - team );\n"
           "\t}\n"
           "\t\n"
           "\tsetState( \"state_Idle\" );\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::state_Idle\n"
           "TinMan: Default fallback state\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::state_Idle() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Idle]\" ); // TinMan *debug*\n"
           "\tfloat nextGoalChoose;\n"
           "\tfloat reactToEnemy;\n"
           "\tentity newEnemy;\n"
           "\t\n"
           "\teachFrame {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Idle]\" ); // TinMan *debug*\n"
           "\t\t\t\n"
           "\t\tif ( !goal && sys.getTime() > nextGoalChoose ) {\n"
           "\t\t\tnextGoalChoose = sys.getTime() + SABOT_NEXT_GOAL_CHOOSE;\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: Choose a role, which is used to decide on a goal. Curses rhyming strikes again!\n"
           "\t\t\tif ( checkSelf() ) { // TinMan: Bot too beat up to be thinging abount anything\n"
           "\t\t\t\trole = SABOT_ROLE_ROAM;\n"
           "\t\t\t} else {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Idle][checkSelf: happy]\" ); // TinMan *debug*\n"
           "\t\t\t\t// TinMan: *CTF* Choose a goalType\n"
           "\t\t\t\tif ( gameType == GAME_CTF ) { // TinMan: *todo* check to see when gametype is set, if map is restarted on gametype change then bot will be restarted, then you can just set a local gameType on state_Begin and save the function lookup\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t\t/* TinMan: Simple\n"
           "\t\t\t\t\tif ( role == SABOT_ROLE_ROAM ) {\n"
           "\t\t\t\t\t\trole = SABOT_ROLE_DEFENCE;\n"
           "\t\t\t\t\t} */\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t\t// TinMan: Very crude, but seems to be working ok. *todo* except the way the hold works is it sets up the goal as a movegoal, which of course when acvieved will clear, thuse resulting in an extra rolecheck, which might flip the bot out the the role you'd normaly want to keep. // TinMan: Very crude, but seems to be working ok. *todo* except the way the hold works is it sets up the goal as a movegoal, which of course when acvieved will clear, thuse resulting in an extra rolecheck, which might flip the bot out the the role you'd normaly want to keep. Lol, but then again this is just a placeholder for the propper goal system.\n"
           "\t\t\t\t\tfloat rnd = sys.random( 100 );\n"
           "\t\t\t\t\tif ( rnd < 33 ) {\n"
           "\t\t\t\t\t\trole = SABOT_ROLE_OFFENCE;\n"
           "\t\t\t\t\t} else if ( rnd < 66 ) {\n"
           "\t\t\t\t\t\trole = SABOT_ROLE_DEFENCE;\n"
           "\t\t\t\t\t} else {\n"
           "\t\t\t\t\t\trole = SABOT_ROLE_ROAM;\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\trole = SABOT_ROLE_ROAM;\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\t/*\n"
           "\t\t\tif ( role == SABOT_ROLE_ROAM ) {\n"
           "\t\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][state_Idle][\" + me + \"][SABOT_ROLE_ROAM]\" ); // TinMan *debug*\n"
           "\t\t\t} else if ( role == SABOT_ROLE_OFFENCE ) {\n"
           "\t\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][state_Idle][\" + me + \"][SABOT_ROLE_OFFENCE]\" ); // TinMan *debug*\n"
           "\t\t\t} else if ( role == SABOT_ROLE_DEFENCE ) {\n"
           "\t\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][state_Idle][\" + me + \"][SABOT_ROLE_DEFENCE]\" ); // TinMan *debug*\n"
           "\t\t\t} else {\n"
           "\t\t\t\tsys.warning( \"[\" + int( sys.getTime() ) + \"][state_Idle][\" + me + \"][Unknow role]\" ); // TinMan *debug*\n"
           "\t\t\t}\n"
           "\t\t\t*/\n"
           "\t\t\t\n"
           "\t\t\tgoal = chooseGoal( oldGoal );\n"
           "\t\t\tif ( !goal ) {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Idle][\" + me + \"][Cannot find long range goal]\" ); // TinMan *debug*\n"
           "\t\t\t\tstopMove();\n"
           "\t\t\t\twaitFrame(); // TinMan: Catch a breather.\n"
           "\t\t\t\t// TinMan: *todo* set up some kind of wander goal/state?\n"
           "\n"
           "\t\t\t\t//karin: forbid freeze, always moving!\n"
           "\t\t\t\tgoal = findOther();\n"
           "\t\t\t\tif(goal)\n"
           "\t\t\t\t{\n"
           "\t\t\t\t\tgoalType = SABOT_GOAL_MOVE;\n"
           "\t\t\t\t\tmoveType = SABOT_MOVETYPE_ENTITY;\n"
           "\t\t\t\t}\n"
           "\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t//waitFrame(); // TinMan: Catch a breather.\n"
           "\t\t\n"
           "\t\tif ( goal ) {\n"
           "\t\t\tif ( goalType == SABOT_GOAL_MOVE ) {\n"
           "\t\t\t\tsetState( \"state_MoveToGoal\" );\n"
           "\t\t\t} else if ( goalType == SABOT_GOAL_FOLLOW ) {\n"
           "\t\t\t\tsetState( \"state_Follow\" );\n"
           "\t\t\t} else if ( goalType == SABOT_GOAL_HOLD ) {\n"
           "\t\t\t\tsetState( \"state_Hold\" );\n"
           "\t\t\t}\telse if ( goalType == SABOT_GOAL_ATTACK ) {\n"
           "\t\t\t\tsetState( \"state_Combat\" );\n"
           "\t\t\t}\telse if ( goalType == SABOT_GOAL_WANDER ) {\n"
           "\t\t\t\tsetState( \"state_Wander\" );\n"
           "\t\t\t} else {\n"
           "\t\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][state_Idle][!Unknown goalType!]\" ); // TinMan *debug*\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tvector bodyOrigin, pushPosition, moveDir;\n"
           "\t\t\tboolean outOfAAS = false;\n"
           "\t\t\tbodyOrigin = body.getOrigin();\n"
           "\t\t\tpushPosition = pushPointIntoAAS( bodyOrigin );\n"
           "\t\t\tif ( pushPosition != bodyOrigin ) {\n"
           "\t\t\t\tif ( sys.vecLength( pushPosition - bodyOrigin ) > 16 ) {\n"
           "\t\t\t\t\toutOfAAS = true;\n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Idle][\" + me + \"][pushpos != bodyOrigin]\" ); // TinMan *debug*\n"
           "\t\t\t\t\tmoveDir = pushPosition - bodyOrigin * 100;\n"
           "\t\t\t\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\t\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\tif ( !outOfAAS && AI_ONGROUND ) {\n"
           "\t\t\t\tsetState( \"state_Wander\" );\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: *todo* create a wander state for !goal - flip to idle after certian time to see if new goal\n"
           "\t\t\tif ( !reactToEnemy ) {\n"
           "\t\t\t\tif ( nextEnemyLook() || AI_PAIN || AI_ENEMY_VISIBLE ) {\n"
           "\t\t\t\t\tif ( AI_ENEMY_VISIBLE ) {\n"
           "\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY; // TinMan: Set react timer.\n"
           "\t\t\t\t\t} else {\n"
           "\t\t\t\t\t\tnewEnemy = lookForEnemies( true );\n"
           "\t\t\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY; // TinMan: Set react timer.\n"
           "\t\t\t\t\t\t} else {\n"
           "\t\t\t\t\t\t\t// TinMan: Shh, I hear something.\n"
           "\t\t\t\t\t\t\tnewEnemy = listenForEnemies();\n"
           "\t\t\t\t\t\t\tif ( !newEnemy && AI_PAIN ) { // TinMan: *cheaphack* work around due to fack heardsound is being shoehorned into something it's not desiged to handle - multiple players\n"
           "\t\t\t\t\t\t\t\tnewEnemy = lookForEnemies( false );\n"
           "\t\t\t\t\t\t\t}\n"
           "\t\t\t\t\t\t\tif ( newEnemy ) {\n"
           "\t\t\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY_SOUND; // TinMan: Set react timer.\n"
           "\t\t\t\t\t\t\t}\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t} else {\n"
           "\t\t\t\tif ( reactToEnemy < sys.getTime() ) {\n"
           "\t\t\t\t\tsetEnemy( newEnemy );\n"
           "\t\t\t\t\tsetState( \"state_Combat\" );\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::state_MoveToGoal\n"
           "TinMan: Only interested in moving here, ie grabbing item.\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::state_MoveToGoal() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_MoveToGoal]\" ); // TinMan *debug*\n"
           "\tvector movePosition, secondaryPosition;\n"
           "\tvector aimDir;\n"
           "\tfloat nextSubGoalLook;\n"
           "\tentity newEnemy;\n"
           "\tfloat reactToEnemy;\n"
           "\n"
           "\tsubGoal = $null_entity;\n"
           "\t\n"
           "\treactToEnemy = 0;\n"
           "\n"
           "\tstopMove();\n"
           "\t\n"
           "\tif ( goal ) {\n"
           "\t\tif ( moveType == SABOT_MOVETYPE_ENTITY ) {\n"
           "\t\t\tsetMoveToEntity( goal );\n"
           "\t\t} else {\n"
           "\t\t\tsetMoveToPosition( goalPosition );\n"
           "\t\t}\n"
           "\t}\n"
           "\t\n"
           "\teachFrame {\n"
           "\t\t//checkWeapon(); // TinMan: Make sure your weapon is nice and shiny\n"
           "\t\t\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_MoveToGoal]\" ); // TinMan *debug*\n"
           "\t\t// TinMan: Lookin for trouble with a big T.\n"
           "\t\tif ( !reactToEnemy ) {\n"
           "\t\t\tif ( nextEnemyLook() || AI_PAIN || AI_ENEMY_VISIBLE ) {\n"
           "\t\t\t\tif ( AI_ENEMY_VISIBLE ) {\n"
           "\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY; // TinMan: Set react timer.\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\tnewEnemy = lookForEnemies( true );\n"
           "\t\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY; // TinMan: Set react timer.\n"
           "\t\t\t\t\t} else {\n"
           "\t\t\t\t\t\t// TinMan: Shh, I hear something.\n"
           "\t\t\t\t\t\tnewEnemy = listenForEnemies();\n"
           "\t\t\t\t\t\tif ( !newEnemy && AI_PAIN ) { // TinMan: *cheaphack* work around due to fack heardsound is being shoehorned into something it's not desiged to handle - multiple players\n"
           "\t\t\t\t\t\t\tnewEnemy = lookForEnemies( false );\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t\tif ( newEnemy ) {\n"
           "\t\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY_SOUND; // TinMan: Set react timer.\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tif ( reactToEnemy < sys.getTime() ) {\n"
           "\t\t\t\tsetEnemy( newEnemy );\n"
           "\t\t\t\tsetState( \"state_Combat\" );\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tif ( gameType == GAME_CTF ) {\n"
           "\t\t\tif ( gotFlag() ) { // TinMan: *cheaphack* got flag?\n"
           "\t\t\t\tclearGoal();\n"
           "\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Look for other items to grab on the way\n"
           "\t\tif ( sys.getTime() > nextSubGoalLook ) {\n"
           "\t\t\tnextSubGoalLook = sys.getTime() + SABOT_NEXT_SUBGOAL_LOOK;\n"
           "\t\t\tfloat lowPriority = 1;\n"
           "\t\t\tif ( gameType == GAME_CTF ) { // TinMan: *cheaphack* ignore crappy stuff if have flag *todo* remove while overhauling priority\n"
           "\t\t\t\tif ( getFlagCarrier( team ) == body ) {\n"
           "\t\t\t\t\tlowPriority = 30;\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t\tsubGoal = lookForGoal( lowPriority, false );\n"
           "\t\t\tif ( subGoal ) {\n"
           "\t\t\t\tif ( goal ) { // TinMan: trying to stop travelDistanceBetweenEntities killing thread when it gets invalid entity.\n"
           "\t\t\t\t\tif ( goal != subGoal ) {\n"
           "\t\t\t\t\t\t// TinMan: Don't want to go after items that are out of the way. Unless the bot needs excersise.\n"
           "\t\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_MoveToGoal][dist][subgoaltogoal: \" + travelDistanceBetweenEntities( goal, subGoal ) + \"][goal: \" +  travelDistanceToEntity( goal )+ \"]\" ); // TinMan: expensive *debug*\n"
           "\t\t\t\t\t\tif ( travelDistanceBetweenEntities( goal, subGoal ) < travelDistanceToEntity( goal ) + 256 ) { // TinMan: *todo* tweak buffer (greater than sugoal look radius is of course pointless, hmm maybe not)\n"
           "\t\t\t\t\t\t\twaitFrame();\n"
           "\t\t\t\t\t\t\tif ( newEnemy ) { // TinMan: *cheaphack* Fix the loosing enemy due to reactiontime and state change *todo* rethink\n"
           "\t\t\t\t\t\t\t\tsetEnemy( newEnemy );\n"
           "\t\t\t\t\t\t\t}\n"
           "\t\t\t\t\t\t\tsetState( \"state_SubGoal\" );\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Move along given path\n"
           "\t\tmovePosition = moveAction();\n"
           "\t\t\n"
           "\t\t// TinMan: Lookee where we damn be going.\n"
           "\t\tif ( AI_ONGROUND && movePosition != body.getOrigin() ) { // TinMan: *cheaphack* stop bot from looking down when movepos = body.org\n"
           "\t\t\taimDir = movePosition - body.getOrigin();\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_MoveToGoal][aimdir: \" + aimDir + \"]\" ); // TinMan: expensive *debug*\n"
           "\t\t\tsetAimDirection( aimDir );\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tcheckBlocked();\n"
           "\t\t\n"
           "\t\tif ( checkShot( true, false ) ) {\n"
           "\t\t\tAI_WEAPON_FIRE = true;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: See if we should still go for goal.\n"
           "\t\tif ( checkGoal( goal ) ) {\n"
           "\t\t\tclearGoal();\n"
           "\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t}\n"
           "\t\tif ( AI_MOVE_DONE || AI_DEST_UNREACHABLE ) {\n"
           "\t\t\tclearGoal();\n"
           "\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t}\n"
           "\t} // TinMan: End eachFrame/state\n"
           "\t\n"
           "\t// TinMan: Exit state\n"
           "\tif ( newEnemy ) { // TinMan: *cheaphack* Fix the loosing enemy due to reactiontime and state change *todo* rethink\n"
           "\t\tsetEnemy( newEnemy );\n"
           "\t}\n"
           "\t\n"
           "\tif ( getEnemy() ) {\n"
           "\t\tif ( !AI_ENEMY_VISIBLE ) {\n"
           "\t\t\tsetState( \"state_Chase\" );\n"
           "\t\t} else {\n"
           "\t\t\tsetState( \"state_Combat\" );\n"
           "\t\t}\n"
           "\t} else {\n"
           "\t\tsetState( \"state_Idle\" );\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::state_SubGoal\n"
           "TinMan: Hunt for close range items. Grab ALL the l00t.\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::state_SubGoal() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_SubGoal]\" ); // TinMan *debug*\n"
           "\tvector movePosition;\n"
           "\tvector aimDir;\n"
           "\tfloat nextSubGoalLook;\n"
           "\tfloat reactToEnemy;\n"
           "\tentity newEnemy;\n"
           "\n"
           "\treactToEnemy = 0;\n"
           "\t\n"
           "\tsetMoveToEntity( subGoal );\n"
           "\n"
           "\teachFrame {\n"
           "\t\tif ( AI_MOVE_DONE || AI_DEST_UNREACHABLE ) {\n"
           "\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Move along given path\n"
           "\t\tmovePosition = moveAction();\n"
           "\t\t\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_MoveToGoal][PATHTYPE: \" + getPathType() + \"]\" ); // TinMan *debug*\n"
           "\t\t// TinMan: Lookee where we damn be going.\n"
           "\t\t//movePosition = getMovePosition(); // TinMan: expensive\n"
           "\t\tif ( AI_ONGROUND && movePosition != body.getOrigin() ) {\n"
           "\t\t\taimDir = movePosition - body.getOrigin();\n"
           "\t\t\tsetAimDirection( aimDir );\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tcheckBlocked();\n"
           "\t\t\n"
           "\t\tif ( checkShot( true, false ) ) {\n"
           "\t\t\tAI_WEAPON_FIRE = true;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Lookin for trouble with a big T.\n"
           "\t\tif ( !reactToEnemy ) {\n"
           "\t\t\tif ( nextEnemyLook() || AI_PAIN || AI_ENEMY_VISIBLE ) {\n"
           "\t\t\t\tif ( AI_ENEMY_VISIBLE ) {\n"
           "\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY; // TinMan: Set react timer.\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\tnewEnemy = lookForEnemies( true );\n"
           "\t\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY; // TinMan: Set react timer.\n"
           "\t\t\t\t\t} else {\n"
           "\t\t\t\t\t\t// TinMan: Shh, I hear something.\n"
           "\t\t\t\t\t\tnewEnemy = listenForEnemies();\n"
           "\t\t\t\t\t\tif ( !newEnemy && AI_PAIN ) { // TinMan: *cheaphack* work around due to fack heardsound is being shoehorned into something it's not desiged to handle - multiple players\n"
           "\t\t\t\t\t\t\tnewEnemy = lookForEnemies( false );\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t\tif ( newEnemy ) {\n"
           "\t\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY_SOUND; // TinMan: Set react timer.\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tif ( reactToEnemy < sys.getTime() ) {\n"
           "\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\n"
           "\t\tif ( checkGoal( subGoal ) || !subGoal ) { // TinMan: See if we should still go for it\n"
           "\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t}\n"
           "\n"
           "\t\tcheckWeapon(); // TinMan: Make sure your weapon is nice and shiny\n"
           "\t\t\n"
           "\t} // TinMan: End eachFrame/state\n"
           "\t\n"
           "\t// TinMan: Exit state\n"
           "\tif ( newEnemy ) { // TinMan: *cheaphack* Fix the loosing enemy due to reactiontime and state change *todo* rethink\n"
           "\t\tsetEnemy( newEnemy );\n"
           "\t}\n"
           "\t\n"
           "\tif ( getEnemy() ) {\n"
           "\t\tif ( !AI_ENEMY_VISIBLE ) {\n"
           "\t\t\tsetState( \"state_Chase\" );\n"
           "\t\t} else {\n"
           "\t\t\tsetState( \"state_Combat\" );\n"
           "\t\t}\n"
           "\t} else {\n"
           "\t\tsetState( \"state_Idle\" );\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::state_Combat\n"
           "TinMan: Direct combat with enemy. Strike him down!\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::state_Combat() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Combat]\" ); // TinMan: *debug*\n"
           "\t\n"
           "\tfloat weaponRangeBuffer;\n"
           "\tfloat nextAimTime;\n"
           "\tfloat nextSubGoalLook;\n"
           "\tfloat enemyLostTime;\n"
           "\tfloat fire, forwards, back, left, right;\n"
           "\tfloat nextStrafeTime;\n"
           "\tfloat moveFlags;\n"
           "\tfloat reactToEnemy, reactFire;\n"
           "\tfloat dist;\n"
           "\tfloat lastVisibleEnemyDist;\n"
           "\tfloat checkTime;\n"
           "\tfloat unreachableTime;\n"
           "\tvector lastVisibleEnemyPos;\n"
           "\tvector aimDir, aimPosition;\n"
           "\tentity enemy, newEnemy;\n"
           "\n"
           "\tsubGoal = $null_entity;\n"
           "\t\n"
           "\tif ( !getEnemy() ) {\n"
           "\t\tsetState( \"state_Idle\" );\n"
           "\t}\n"
           "\t\n"
           "\treactToEnemy = false;\n"
           "\tenemyLostTime = 0;\n"
           "\t\n"
           "\tenemy = getEnemy();\n"
           "\n"
           "\tsetMoveToEnemy();\n"
           "\t// TinMan: Flip out straight away if you can't do move. *todo* move to attack position instead\n"
           "\t/*\n"
           "\tif ( AI_DEST_UNREACHABLE ) {\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][Start:Cannot move to enemy!]\" ); // TinMan: *debug*\n"
           "\t\tsetState( \"state_Idle\" );\n"
           "\t}\n"
           "\t*/\n"
           "\n"
           "\tweaponRangeBuffer = sys.random( 16 ) + 16; // TinMan: *todo* rethink\n"
           "\teachFrame {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Combat]\" ); // TinMan: *debug*\n"
           "\t\t// TinMan: Check to see if enemy died, and set some reaction time\n"
           "\t\tif ( AI_ENEMY_DEAD || !getEnemy() ) { // TinMan: idAI checks to see if enemy is alive each think and sets these if not.\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"[state_Combat][no enemy]\" ); // TinMan *debug*\n"
           "\t\t\tif ( timerEnd == -1 ) {\n"
           "\t\t\t\tsetMoveToPosition( lastVisibleEnemyPos );\n"
           "\t\t\t\tsetTimer( 0.3 );\n"
           "\t\t\t} else if ( getTimer() ) {\n"
           "\t\t\t\tclearTimer();\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"[state_Combat][no enemy]\" ); // TinMan *debug*\n"
           "\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tlastVisibleEnemyPos = getEnemyPos();\n"
           "\t\t\tlastVisibleEnemyPos_z += viewHeight; // TinMan: cheap hack pos off ground since we'll be aiming at it when enemy dead\n"
           "\t\t\tlastVisibleEnemyDist = enemyRange();\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: The enemy might move to an unreachable spot, wall edge, or be midair, so we need to reset move *todo* Ideally we want to do a movetoattackposition\n"
           "\t\tif ( AI_DEST_UNREACHABLE || AI_MOVE_DONE ) {\n"
           "\t\t\tif ( checkTime < sys.getTime() ) {\n"
           "\t\t\t\tif ( getEnemy() ) {\n"
           "\t\t\t\t\tif ( !unreachableTime ) {\n"
           "\t\t\t\t\t\tunreachableTime = sys.getTime() + SABOT_ENEMY_UNREACHABLE_TIME;\n"
           "\t\t\t\t\t} else if ( unreachableTime < sys.getTime() ) { // TinMan: Can't reach the bugger. *todo* should do shorter test and check if you can movetoattackpos?\n"
           "\t\t\t\t\t\tsetMoveToAttackPosition( getEnemy() );\n"
           "\t\t\t\t\t\tif ( AI_DEST_UNREACHABLE || AI_MOVE_DONE ){\n"
           "\t\t\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][Cannot movetoattackpos]\" ); // TinMan: *debug*\n"
           "\t\t\t\t\t\t\tclearEnemy();\n"
           "\t\t\t\t\t\t\tbreak;\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][reset move to enemy!]\" ); // TinMan: *debug*\n"
           "\t\t\t\t\tcheckTime = sys.getTime() + 0.3;\n"
           "\t\t\t\t\tif ( AI_MOVE_DONE ) { // TinMan: at last reachable enemy pos\n"
           "\t\t\t\t\t\tlocateEnemy(); // TinMan: force update\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t\tsetMoveToEnemy();\n"
           "\t\t\t\t\t//setMoveToAttackPosition( getEnemy() );\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tunreachableTime = 0;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tcheckWeapon(); // TinMan: Make sure your weapon is nice and shiny\n"
           "\t\t\n"
           "\t\t// TinMan: See if we even want to be fighting - if enemy too badass or too beatup\n"
           "\t\tif ( checkSelf() ) { // checkEnemy( enemy ) || \n"
           "\t\t\t//if ( sys.random( 100 ) < 40 ) { // TinMan: *todo* demagic, set a limit/timer\n"
           "\t\t\t\t//if ( body.distanceTo( getEnemy() ) > 128 ) {\n"
           "\t\t\t\t\twaitFrame();\n"
           "\t\t\t\t\tsetState( \"state_CombatRetreat\" );\n"
           "\t\t\t\t//}\n"
           "\t\t\t//}\n"
           "\t\t}\n"
           "\n"
           "\t\t// TinMan: Aim at enemy\n"
           "\t\tif ( nextAimTime < sys.getTime() ) { // TinMan: Roughen up aiming a bit\n"
           "\t\t\tnextAimTime = sys.getTime() + SABOT_NEXT_AIM;\n"
           "\t\t\tif ( !AI_ENEMY_DEAD ) {\n"
           "\t\t\t\t// TinMan: Get initial aim position  - chest, feets.\n"
           "\t\t\t\taimPosition = getAimTarget( getEnemy() );\n"
           "\t\t\t\t\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][aimPosition = \" + aimPosition_x + \" \" + aimPosition_y + \" \" +aimPosition_z + \"]\" ); // TinMan: *debug*\n"
           "\t\t\t\t// TinMan: Lead shot\n"
           "\t\t\t\taimPosition = predictTargetPosition( aimPosition, getViewPosition(), enemy.getLinearVelocity(), getProjectileSpeed( currentWeapon ) );\n"
           "\t\t\t\taimDir = addAimVariation( aimPosition ); // TinMan: Screw up aim cause I'm mean.\n"
           "\t\t\t\t\n"
           "\t\t\t\t//aimPosition = enemy.getOrigin(); // TinMan: *test* simple\n"
           "\t\t\t\t//aimDir = aimPosition - getViewPosition(); // TinMan: *test* simple\n"
           "\t\t\t\t\n"
           "\t\t\t\tsetAimDirection( aimDir ); // TinMan: Finally set our target to aim to.\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][aimDir = \" + aimDir_x + \" \" + aimDir_y + \" \" +aimDir_z + \"]\" ); // TinMan: *debug*\n"
           "\t\t\t} else { // TinMan: Aim at teh dedders\n"
           "\t\t\t\taimDir = lastVisibleEnemyPos - getViewPosition();\n"
           "\t\t\t\tsetAimDirection( aimDir );\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\n"
           "\t\t// TinMan: Check shot is within weapon range. AND SMITE HIM!\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][CurrentWeapon: \" + currentWeapon + \"][Weaponrange]\" ); // TinMan: *debug*\n"
           "\t\tif ( ( lastVisibleEnemyDist > weaponRange_y ) && ( lastVisibleEnemyDist < weaponRange_z ) )\t{\n"
           "\t\t\t// TinMan: See if any enemies in shot.\n"
           "\t\t\tif ( !reactFire ) { // TinMan: Allready going to fire\n"
           "\t\t\t\tif ( checkShot( false, true ) ) { // TinMan: See if enemy in straight bounds trace.\n"
           "\t\t\t\t\treactFire = sys.getTime() + SABOT_REACT_FIRE;\n"
           "\t\t\t\t} else if ( checkShot( true, true ) ) { // TinMan: See if enemy in straight point trace.\n"
           "\t\t\t\t\treactFire = sys.getTime() + SABOT_REACT_FIRE;\n"
           "\t\t\t\t} else if ( checkAimedShot( aimPosition, lastVisibleEnemyDist ) ) { // TinMan: See if we are aimed at position and shot will make it.\n"
           "\t\t\t\t\treactFire = sys.getTime() + SABOT_REACT_FIRE;\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\treactFire = 0;\n"
           "\t\t\t\t\tfire = false;\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\telse { // TinMan: Aw, out of weapon range.\n"
           "\t\t\treactFire = 0;\n"
           "\t\t\tfire = false;\n"
           "\t\t}\n"
           "\n"
           "\t\tif ( reactFire != 0 ) {\n"
           "\t\t\tif ( reactFire < sys.getTime() ) {\n"
           "\t\t\t\tfire = true; // TinMan: Ratatat tat, boom, fwoosh!\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tif ( fire && ( enemyLostTime < 0.2 || AI_ENEMY_DEAD ) ) { // TinMan: The delayed fire is working out quite nicely at the moment except leads to the bot shooting into walls too much.\n"
           "\t\t\tAI_WEAPON_FIRE = true;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Look out for more imediate threats.\n"
           "\t\tif ( !reactToEnemy ) {\n"
           "\t\t\tif ( nextEnemyLook() ) {\n"
           "\t\t\t\tnewEnemy = lookForEnemies( true );\n"
           "\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\tdist = body.distanceTo( newEnemy );\n"
           "\t\t\t\t\tif ( dist < lastVisibleEnemyDist - 64 ) {\n"
           "\t\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][Wah! New enemy closy close]\" ); // TinMan: *debug*\n"
           "\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY; // TinMan: Set react timer.\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\t// TinMan: Shh, I hear something.\n"
           "\t\t\t\t\tnewEnemy = listenForEnemies();\n"
           "\t\t\t\t\tif ( !newEnemy && AI_PAIN ) { // TinMan: *cheaphack* work around due to fack heardsound is being shoehorned into something it's not desiged to handle - multiple players\n"
           "\t\t\t\t\t\tnewEnemy = lookForEnemies( false );\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\t\tdist = body.distanceTo( newEnemy );\n"
           "\t\t\t\t\t\tif ( dist < lastVisibleEnemyDist - 64 ) {\n"
           "\t\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY_SOUND; // TinMan: Set react timer.\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tif ( reactToEnemy < sys.getTime() ) {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me +\"][state_Combat][newenemy!!]\" ); // TinMan: *debug*\n"
           "\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\n"
           "\t\t// TinMan: Move closer/ retreat/ strafe.. to get to weapon sweet spot\n"
           "\t\tif ( lastVisibleEnemyDist > weaponRange_x + weaponRangeBuffer ) { // TinMan *todo* rejigger to lastenpos\n"
           "\t\t\t// TinMan: Closer than weaponRange\n"
           "\t\t\tif ( AI_ENEMY_VISIBLE ) {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][Moving to sweet spot: \" + weaponRange_x + \"]\" ); // TinMan: *debug*\n"
           "\t\t\t\tif ( travelDistanceToPoint( lastVisibleEnemyPos ) < 600  ) { // TinMan: *todo* remove once better solution implemented\n"
           "\t\t\t\t\t// TinMan: -v- still like the careening off any height\n"
           "\t\t\t\t\t/*if ( checkMoveForward() ) {\n"
           "\t\t\t\t\t\tmoveForward();\n"
           "\t\t\t\t\t}*/\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t\tmoveAction();\n"
           "\t\t\t\t}\n"
           "\t\t\t} else { // !AI_ENEMY_VIS\n"
           "\t\t\t\tmoveAction();\n"
           "\t\t\t}\n"
           "\t\t} else if ( lastVisibleEnemyDist < ( weaponRange_x - weaponRangeBuffer ) ) { // TinMan: EnemyRange Further than weaponRange\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][Moving backwards to sweet spot]\" ); // TinMan: *debug*\n"
           "\t\t\tAI_FORWARD = false;\n"
           "\t\t\tif ( checkMoveBack() ) {\n"
           "\t\t\t\tmoveBackward();\n"
           "\t\t\t}\n"
           "\t\t} /*else {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][At sweet spot]\" ); // TinMan: *debug*\n"
           "\t\t} */\n"
           "\n"
           "\t\tif ( nextStrafeTime < sys.getTime() ) { // TinMan: Randomly change strafe\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][Strafe]\" ); // TinMan: *debug*\n"
           "\t\t\tnextStrafeTime = RandomDelay( SABOT_STRAFE_MIN, SABOT_STRAFE_MAX );\n"
           "\t\n"
           "\t\t\tleft = false;\n"
           "\t\t\tright = false;\n"
           "\t\t\tleft = checkStrafeLeft();\n"
           "\t\t\tright = checkStrafeRight();\n"
           "\t\t\t \t\n"
           "\t\t\tif ( left && right ) {\n"
           "\t\t\t\tright == !AI_STRAFE_RIGHT; // TinMan: went right last time\n"
           "\t\t\t \tleft == !AI_STRAFE_LEFT;\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\n"
           "\t\tif ( right ) {\n"
           "\t\t\tmoveRight();\n"
           "\t\t} else if ( left ) {\n"
           "\t\t\tmoveLeft();\n"
           "\t\t}\n"
           "\n"
           "\t\t// TinMan: *cheaphack* stop bashing into stuff\n"
           "\t\tif ( AI_STRAFE_RIGHT && !checkStrafeRight() ) {\n"
           "\t\t\tAI_STRAFE_RIGHT = false;\n"
           "\t\t\tnextStrafeTime = sys.getTime() + 0.05;\n"
           "\t\t}\n"
           "\t\tif ( AI_STRAFE_LEFT && !checkStrafeLeft() ) {\n"
           "\t\t\tAI_STRAFE_LEFT = false;\t\t\n"
           "\t\t\tnextStrafeTime = sys.getTime() + 0.05;\n"
           "\t\t}\n"
           "\t\tif ( AI_FORWARD && !checkMoveForward() ) {\n"
           "\t\t\tAI_FORWARD = false;\n"
           "\t\t}\n"
           "\t\tif ( AI_BACKWARD && !checkMoveBack() ) {\n"
           "\t\t\tAI_BACKWARD = false;\n"
           "\t\t}\n"
           "\n"
           "\t\t// TinMan: Wherizy?\n"
           "\t\tif ( !AI_ENEMY_VISIBLE ) {\n"
           "\t\t\tif ( enemyLostTime == 0 ) {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][start lost timer]\" ); // TinMan: *debug*\n"
           "\t\t\t\tenemyLostTime = RandomDelay( SABOT_ENEMY_LOST_TIME, SABOT_ENEMY_LOST_TIME + 0.5 );\n"
           "\t\t\t} else if ( enemyLostTime < sys.getTime() ) {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][chase]\" ); // TinMan: *debug*\n"
           "\t\t\t\tsetState( \"state_Chase\" );\n"
           "\t\t\t}\n"
           "\t\t} else if ( AI_ENEMY_VISIBLE ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][reset lost timer]\" ); // TinMan: *debug*\n"
           "\t\t\tenemyLostTime = 0; // TinMan: Can see enemy again, so stop timer\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tcheckBlocked();\n"
           "\t\t\n"
           "\t\t// TinMan: Look for items that will help you fight\n"
           "\t\tif ( sys.getTime() > nextSubGoalLook ) {\n"
           "\t\t\tnextSubGoalLook = sys.getTime() + SABOT_NEXT_SUBGOAL_LOOK;\n"
           "\t\t\tsubGoal = lookForGoal( 30, true ); // TinMan: Ignore low priority, we a fussin and a fuedin.\n"
           "\t\t\tfloat buffer = 64; // TinMan: *todo* move, demagic\n"
           "\t\t\tif ( subGoal ) {\n"
           "\t\t\t\twaitFrame();\n"
           "\t\t\t\tsetState( \"state_CombatSubGoal\" );\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t} // TinMan: End eachFrame/state\n"
           "\t\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][Exit state]\" ); // TinMan: *debug*\n"
           "\t\n"
           "\t// TinMan: Exit state\n"
           "\tif ( newEnemy ) { // TinMan: *cheaphack* Fix the loosing enemy due to reactiontime and state change *todo* rethink\n"
           "\t\tsetEnemy( newEnemy );\n"
           "\t}\n"
           "\t\n"
           "\tif ( getEnemy() ) {\n"
           "\t\tsetState( \"state_Combat\" );\n"
           "\t} else {\n"
           "\t\tclearGoal();\n"
           "\t\tsetState( \"state_Idle\" );\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::state_CombatSubGoal\n"
           "TinMan: Grabbing item while fighting.\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::state_CombatSubGoal() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_CombatSubGoal]\" ); // TinMan *debug*\n"
           "\tvector movePosition, aimDir, aimPosition;\n"
           "\tfloat weaponRangeBuffer;\n"
           "\tfloat nextSubGoalLook;\n"
           "\tfloat subGoalLostTime, enemyLostTime;\n"
           "\tfloat nextAimTime;\n"
           "\tfloat reactToEnemy;\n"
           "\tfloat reactFire, fire;\n"
           "\tfloat dist;\n"
           "\tfloat lastVisibleEnemyDist;\n"
           "\tvector lastVisibleEnemyPos;\n"
           "\tentity newEnemy;\n"
           "\t\n"
           "\tsetMoveToEntity( subGoal );\n"
           "\t// TinMan: Flip out straight away if you can't do move.\n"
           "\tif ( AI_MOVE_DONE || AI_DEST_UNREACHABLE ) {\n"
           "\t\tclearGoal();\n"
           "\t\tsetState( \"state_Idle\" );\t\t\n"
           "\t}\n"
           "\n"
           "\treactToEnemy = false;\n"
           "\n"
           "\tweaponRangeBuffer = sys.random( 16 ) + 16; // TinMan: *todo* rethink\n"
           "\t\n"
           "\teachFrame {\n"
           "\t\t// TinMan: Check to see if enemy died, and set some reaction time\n"
           "\t\tif ( AI_ENEMY_DEAD || !getEnemy() ) { // TinMan: idAI checks to see if enemy is alive each think and sets these if not.\n"
           "\t\t\tif ( timerEnd == -1 ) {\n"
           "\t\t\t\tsetTimer( 0.3 );\n"
           "\t\t\t} else if ( getTimer() ) {\n"
           "\t\t\t\tclearTimer();\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_CombatSubGoal]\" ); // TinMan *debug*\n"
           "\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tlastVisibleEnemyPos = getEnemyPos();\n"
           "\t\t\tlastVisibleEnemyPos_z += viewHeight; // TinMan: cheap hack pos off ground since we'll be aiming at it when enemy dead\n"
           "\t\t\tlastVisibleEnemyDist = enemyRange();\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tif ( AI_MOVE_DONE || AI_DEST_UNREACHABLE ) {\n"
           "\t\t\tsubGoal = $null_entity;\n"
           "\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tcheckWeapon(); // TinMan: Make sure your weapon is nice and shiny\n"
           "\t\t\n"
           "\t\t// TinMan: Aim at enemy\n"
           "\t\tif ( nextAimTime < sys.getTime() ) { // TinMan: Roughen up aiming a bit\n"
           "\t\t\tnextAimTime = sys.getTime() + SABOT_NEXT_AIM;\n"
           "\t\t\tif ( AI_ENEMY_VISIBLE ) {\n"
           "\t\t\t\t// TinMan: Get initial aim position  - chest, feets.\n"
           "\t\t\t\taimPosition = getAimTarget( getEnemy() );\n"
           "\t\t\t\t// TinMan: Lead shot\n"
           "\t\t\t\tentity enemy = getEnemy();\n"
           "\t\t\t\taimPosition = predictTargetPosition( aimPosition, getViewPosition(), enemy.getLinearVelocity(), getProjectileSpeed( currentWeapon ) );\n"
           "\t\t\t\taimDir = addAimVariation( aimPosition ); // TinMan: Screw up aim cause I'm mean.\n"
           "\t\t\t\t//aimDir = aimPosition - getViewPosition(); // TinMan: *test* simple\n"
           "\t\t\t\tsetAimDirection( aimDir ); // TinMan: Finally set our target to aim to.\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][aimPosition = \" + aimPosition_x + \" \" + aimPosition_y + \" \" +aimPosition_z + \"]\" ); // TinMan: *debug*\n"
           "\t\t\t} else { // TinMan: Aim at teh dedders\n"
           "\t\t\t\taimDir = lastVisibleEnemyPos - getViewPosition();\n"
           "\t\t\t\tsetAimDirection( aimDir );\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Check shot is within weapon range. AND SMITE HIM!\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][CurrentWeapon: \" + currentWeapon + \"][Weaponrange]\" ); // TinMan: *debug*\n"
           "\t\tif ( ( lastVisibleEnemyDist > weaponRange_y ) && ( lastVisibleEnemyDist < weaponRange_z ) )\t{\n"
           "\t\t\t// TinMan: See if any enemies in shot.\n"
           "\t\t\tif ( !reactFire ) { // TinMan: Allready going to fire\n"
           "\t\t\t\tif ( checkShot( false, true ) ) { // TinMan: See if enemy in straight bounds trace.\n"
           "\t\t\t\t\treactFire = sys.getTime() + SABOT_REACT_FIRE;\n"
           "\t\t\t\t} else if ( checkShot( true, true ) ) { // TinMan: See if enemy in straight point trace.\n"
           "\t\t\t\t\treactFire = sys.getTime() + SABOT_REACT_FIRE;\n"
           "\t\t\t\t} else if ( checkAimedShot( aimPosition, lastVisibleEnemyDist ) ) { // TinMan: See if we are aimed at position and shot will make it.\n"
           "\t\t\t\t\treactFire = sys.getTime() + SABOT_REACT_FIRE;\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\treactFire = 0;\n"
           "\t\t\t\t\tfire = false;\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\telse { // TinMan: Aw, out of weapon range.\n"
           "\t\t\treactFire = 0;\n"
           "\t\t\tfire = false;\n"
           "\t\t}\n"
           "\n"
           "\t\tif ( reactFire != 0 ) {\n"
           "\t\t\tif ( reactFire < sys.getTime() ) {\n"
           "\t\t\t\tfire = true; // TinMan: Ratatat tat, boom, fwoosh!\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tif ( fire && ( enemyLostTime < 0.2 || AI_ENEMY_DEAD ) ) { // TinMan: The delayed fire is working out quite nicely at the moment except leads to the bot shooting into walls too much.\n"
           "\t\t\tAI_WEAPON_FIRE = true;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Look out for more imediate threats.\n"
           "\t\tif ( !reactToEnemy ) {\n"
           "\t\t\tif ( nextEnemyLook() ) {\n"
           "\t\t\t\tnewEnemy = lookForEnemies( true );\n"
           "\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\tdist = body.distanceTo( newEnemy );\n"
           "\t\t\t\t\tif ( dist < lastVisibleEnemyDist - 64 ) {\n"
           "\t\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][Wah! New enemy closy close]\" ); // TinMan: *debug*\n"
           "\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY; // TinMan: Set react timer.\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\t// TinMan: Shh, I hear something.\n"
           "\t\t\t\t\tnewEnemy = listenForEnemies();\n"
           "\t\t\t\t\tif ( !newEnemy && AI_PAIN ) { // TinMan: *cheaphack* work around due to fack heardsound is being shoehorned into something it's not desiged to handle - multiple players\n"
           "\t\t\t\t\t\tnewEnemy = lookForEnemies( false );\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\t\tdist = body.distanceTo( newEnemy );\n"
           "\t\t\t\t\t\tif ( dist < lastVisibleEnemyDist - 64 ) {\n"
           "\t\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY_SOUND; // TinMan: Set react timer.\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t} \n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tif ( reactToEnemy < sys.getTime() ) {\n"
           "\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: We aren't super man so if we can't see item after a while forget it and go back to fight\n"
           "\t\tif ( !canSeeEntity( subGoal, true ) ) {\n"
           "\t\t\tif ( subGoalLostTime == 0 ) {\n"
           "\t\t\t\tsubGoalLostTime = sys.getTime() + SABOT_SUBGOAL_LOST_TIME;\n"
           "\t\t\t} else {\n"
           "\t\t\t\tif ( subGoalLostTime < sys.getTime() ) {\n"
           "\t\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tsubGoalLostTime = 0; // TinMan: Can see, stop timer\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: See if we lost enemy\n"
           "\t\tif ( !AI_ENEMY_VISIBLE ) {\n"
           "\t\t\tif ( enemyLostTime == 0 ) {\n"
           "\t\t\t\tenemyLostTime = RandomDelay( SABOT_ENEMY_LOST_TIME, SABOT_ENEMY_LOST_TIME + 0.5 );\n"
           "\t\t\t} else if ( enemyLostTime < sys.getTime() ) {\n"
           "\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tenemyLostTime = 0; // TinMan: Can see enemy again, so stop timer\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Move along given path\n"
           "\t\tmoveAction();\n"
           "\t\t\n"
           "\t\tcheckBlocked();\n"
           "\n"
           "\t\tif ( checkGoal( subGoal ) || !subGoal ) { // TinMan: See if we should still go for it\n"
           "\t\t\tsubGoal = $null_entity;\n"
           "\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t}\n"
           "\t} // TinMan: End eachFrame/state\n"
           "\t\n"
           "\t// TinMan: Exit state\n"
           "\tif ( newEnemy ) { // TinMan: *cheaphack* Fix the loosing enemy due to reactiontime and state change *todo* rethink\n"
           "\t\tsetEnemy( newEnemy );\n"
           "\t}\n"
           "\t\n"
           "\tif ( getEnemy() ) {\n"
           "\t\tif ( !AI_ENEMY_VISIBLE ) {\n"
           "\t\t\tsetState( \"state_Chase\" );\n"
           "\t\t} else {\n"
           "\t\t\tsetState( \"state_Combat\" );\n"
           "\t\t}\n"
           "\t} else if ( subGoal ) {\n"
           "\t\tsetState( \"state_SubGoal\" );\n"
           "\t}else {\n"
           "\t\tsetState( \"state_Idle\" );\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::state_CombatRetreat\n"
           "TinMan: Combat while retreating.\n"
           "Will still check for new enemies and switch to combat, which should choose whether bot still wants to retreat or stands and fights.\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::state_CombatRetreat() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_CombatRetreat]\" ); // TinMan *debug*\n"
           "\tvector movePosition, aimDir, aimPosition;\n"
           "\tfloat weaponRangeBuffer;\n"
           "\tfloat nextSubGoalLook;\n"
           "\tfloat enemyLostTime;\n"
           "\tfloat nextAimTime;\n"
           "\tfloat reactToEnemy;\n"
           "\tfloat reactFire, fire;\n"
           "\tfloat dist;\n"
           "\tfloat lastVisibleEnemyDist;\n"
           "\tvector lastVisibleEnemyPos;\n"
           "\tentity newEnemy;\n"
           "\t\n"
           "\tsubGoal = $null_entity;\n"
           "\t\n"
           "\tsetMoveToCover();\n"
           "\t// TinMan: Flip out straight away if you can't do move.\n"
           "\t/*if ( AI_MOVE_DONE || AI_DEST_UNREACHABLE ) {\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][state_CombatRetreat][Cannot move to cover]\" ); // TinMan: *debug*\n"
           "\t} else {\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][state_CombatRetreat][Moving to cover]\" ); // TinMan: *debug*\n"
           "\t}*/\n"
           "\n"
           "\treactToEnemy = false;\n"
           "\n"
           "\tweaponRangeBuffer = sys.random( 16 ) + 16; // TinMan: *todo* rethink\n"
           "\t\n"
           "\teachFrame {\n"
           "\t\t// TinMan: Check to see if enemy died, and set some reaction time\n"
           "\t\tif ( AI_ENEMY_DEAD || !getEnemy() ) { // TinMan: idAI checks to see if enemy is alive each think and sets these if not.\n"
           "\t\t\tif ( timerEnd == -1 ) {\n"
           "\t\t\t\tsetTimer( 0.3 );\n"
           "\t\t\t} else if ( getTimer() ) {\n"
           "\t\t\t\tclearTimer();\n"
           "\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tlastVisibleEnemyPos = getEnemyPos();\n"
           "\t\t\tlastVisibleEnemyPos_z += viewHeight; // TinMan: cheap hack pos off ground since we'll be aiming at it when enemy dead\n"
           "\t\t\tlastVisibleEnemyDist = enemyRange();\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tif ( AI_MOVE_DONE || AI_DEST_UNREACHABLE ) {\n"
           "\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tcheckWeapon(); // TinMan: Make sure your weapon is nice and shiny\n"
           "\t\t\n"
           "\t\t// TinMan: Aim at enemy\n"
           "\t\tif ( nextAimTime < sys.getTime() ) { // TinMan: Roughen up aiming a bit\n"
           "\t\t\tnextAimTime = sys.getTime() + SABOT_NEXT_AIM;\n"
           "\t\t\tif ( AI_ENEMY_VISIBLE ) {\n"
           "\t\t\t\t// TinMan: Get initial aim position  - chest, feets.\n"
           "\t\t\t\taimPosition = getAimTarget( getEnemy() );\n"
           "\t\t\t\t// TinMan: Lead shot\n"
           "\t\t\t\tentity enemy = getEnemy();\n"
           "\t\t\t\taimPosition = predictTargetPosition( aimPosition, getViewPosition(), enemy.getLinearVelocity(), getProjectileSpeed( currentWeapon ) );\n"
           "\t\t\t\taimDir = addAimVariation( aimPosition ); // TinMan: Screw up aim cause I'm mean.\n"
           "\t\t\t\t//aimDir = aimPosition - getViewPosition();  // TinMan: *test* simple\n"
           "\t\t\t\tsetAimDirection( aimDir ); // TinMan: Finally set our target to aim to.\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][aimPosition = \" + aimPosition_x + \" \" + aimPosition_y + \" \" +aimPosition_z + \"]\" ); // TinMan: *debug*\n"
           "\t\t\t} else { // TinMan: Aim at teh dedders\n"
           "\t\t\t\taimDir = lastVisibleEnemyPos - getViewPosition();\n"
           "\t\t\t\tsetAimDirection( aimDir );\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Check shot is within weapon range. AND SMITE HIM!\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][CurrentWeapon: \" + currentWeapon + \"][Weaponrange]\" ); // TinMan: *debug*\n"
           "\t\tif ( ( lastVisibleEnemyDist > weaponRange_y ) && ( lastVisibleEnemyDist < weaponRange_z ) )\t{\n"
           "\t\t\t// TinMan: See if any enemies in shot.\n"
           "\t\t\tif ( !reactFire ) { // TinMan: Allready going to fire\n"
           "\t\t\t\tif ( checkShot( false, true ) ) { // TinMan: See if enemy in straight bounds trace.\n"
           "\t\t\t\t\treactFire = sys.getTime() + SABOT_REACT_FIRE;\n"
           "\t\t\t\t} else if ( checkShot( true, true ) ) { // TinMan: See if enemy in straight point trace.\n"
           "\t\t\t\t\treactFire = sys.getTime() + SABOT_REACT_FIRE;\n"
           "\t\t\t\t} else if ( checkAimedShot( aimPosition, lastVisibleEnemyDist ) ) { // TinMan: See if we are aimed at position and shot will make it.\n"
           "\t\t\t\t\treactFire = sys.getTime() + SABOT_REACT_FIRE;\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\treactFire = 0;\n"
           "\t\t\t\t\tfire = false;\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\telse { // TinMan: Aw, out of weapon range.\n"
           "\t\t\treactFire = 0;\n"
           "\t\t\tfire = false;\n"
           "\t\t}\n"
           "\n"
           "\t\tif ( reactFire != 0 ) {\n"
           "\t\t\tif ( reactFire < sys.getTime() ) {\n"
           "\t\t\t\tfire = true; // TinMan: Ratatat tat, boom, fwoosh!\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tif ( fire && ( enemyLostTime < 0.2 || AI_ENEMY_DEAD ) ) { // TinMan: The delayed fire is working out quite nicely at the moment except leads to the bot shooting into walls too much.\n"
           "\t\t\tAI_WEAPON_FIRE = true;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Look out for more imediate threats.\n"
           "\t\tif ( !reactToEnemy ) {\n"
           "\t\t\tif ( nextEnemyLook() ) {\n"
           "\t\t\t\tnewEnemy = lookForEnemies( true );\n"
           "\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\tdist = body.distanceTo( newEnemy );\n"
           "\t\t\t\t\tif ( dist < lastVisibleEnemyDist - 64 ) {\n"
           "\t\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][Wah! New enemy closy close]\" ); // TinMan: *debug*\n"
           "\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY; // TinMan: Set react timer.\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\t// TinMan: Shh, I hear something.\n"
           "\t\t\t\t\tnewEnemy = listenForEnemies();\n"
           "\t\t\t\t\tif ( !newEnemy && AI_PAIN ) { // TinMan: *cheaphack* work around due to fack heardsound is being shoehorned into something it's not desiged to handle - multiple players\n"
           "\t\t\t\t\t\tnewEnemy = lookForEnemies( false );\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\t\tdist = body.distanceTo( newEnemy );\n"
           "\t\t\t\t\t\tif ( dist < lastVisibleEnemyDist - 64 ) {\n"
           "\t\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY_SOUND; // TinMan: Set react timer.\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t} \n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tif ( reactToEnemy < sys.getTime() ) {\n"
           "\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\n"
           "\t\t// TinMan: See if we want to go into full tally ho retreat\n"
           "\t\tif ( !AI_ENEMY_VISIBLE ) {\n"
           "\t\t\tif ( enemyLostTime == 0 ) {\n"
           "\t\t\t//if ( getTimer() == SABOT_TIMER_NOT_SET ) {\n"
           "\t\t\t\tenemyLostTime = RandomDelay( SABOT_ENEMY_LOST_TIME, SABOT_ENEMY_LOST_TIME + 0.5 );\n"
           "\t\t\t//\tsetTimer( SABOT_ENEMY_LOST_TIME );\n"
           "\t\t\t} else if ( enemyLostTime < sys.getTime() ) {\n"
           "\t\t\t//} else if ( getTimer() ) {\n"
           "\t\t\t\tsetState( \"state_Retreat\" );\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tenemyLostTime = 0; // TinMan: Can see enemy again, so stop timer\n"
           "\t\t\t//clearTimer();\n"
           "\t\t}\n"
           "\n"
           "\t\t// TinMan: Move along given path\n"
           "\t\tmoveAction();\n"
           "\t\t\n"
           "\t\tcheckBlocked();\n"
           "\t\t\n"
           "\t\t// TinMan: Look for items that will help you fight\n"
           "\t\tif ( sys.getTime() > nextSubGoalLook ) {\n"
           "\t\t\tnextSubGoalLook = sys.getTime() + SABOT_NEXT_SUBGOAL_LOOK;\n"
           "\t\t\tsubGoal = lookForGoal( 40, true ); // TinMan: Ignore low priority, we a fussin and a fuedin.\n"
           "\t\t\tfloat buffer = 64; // TinMan: *todo* move, demagic\n"
           "\t\t\tif ( subGoal ) {\n"
           "\t\t\t\twaitFrame();\n"
           "\t\t\t\tsetState( \"state_CombatSubGoal\" );\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t} // TinMan: End eachFrame/state\n"
           "\t\n"
           "\t// TinMan: Exit state\n"
           "\tif ( newEnemy ) { // TinMan: *cheaphack* Fix the loosing enemy due to reactiontime and state change *todo* rethink\n"
           "\t\tsetEnemy( newEnemy );\n"
           "\t}\n"
           "\t\n"
           "\tif ( getEnemy() ) {\n"
           "\t\tif ( !AI_ENEMY_VISIBLE ) {\n"
           "\t\t\tsetState( \"state_Retreat\" );\n"
           "\t\t} else {\n"
           "\t\t\tsetState( \"state_Combat\" );\n"
           "\t\t}\n"
           "\t} else {\n"
           "\t\tsetState( \"state_Idle\" );\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::state_Chase\n"
           "TinMan: Move to restablish combat. Hunt him down!\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::state_Chase() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Chase]\" ); // TinMan: *debug*\n"
           "\tvector movePosition, aimDir, aimPosition;\n"
           "\tfloat chaseTime;\n"
           "\tfloat nextSubGoalLook;\n"
           "\tfloat reactToEnemy;\n"
           "\tfloat unreachableTime;\n"
           "\tentity newEnemy;\n"
           "\t\n"
           "\tsubGoal = $null_entity;\n"
           "\t\n"
           "\tif ( !getEnemy() ) {\n"
           "\t\tsetState( \"state_Idle\" );\n"
           "\t}\n"
           "\n"
           "\t// TinMan: Gentlemen, start your engines.\n"
           "\t//if ( canReachEntity( getEnemy() ) ) {\n"
           "\tsetMoveToEnemy();\n"
           "\t//} else {\n"
           "\t\t//setMoveToAttackPosition( getEnemy() );\n"
           "\t\t//\n"
           "\t\t/*\n"
           "\t\tif ( AI_DEST_UNREACHABLE ) {\n"
           "\t\t\t// sys.println( \"[\" + int( sys.getTime() ) + \"][state_Chase][Cannot reach enemy or attack position]\" ); // TinMan: *debug*\n"
           "\t\t\tclearEnemy();\n"
           "\t\t\tsetState( \"state_Idle\" );\n"
           "\t\t}\n"
           "\t\t*/\n"
           "\t\t// sys.println( \"[\" + int( sys.getTime() ) + \"][state_Chase][Moving to attack position]\" ); // TinMan: *debug*\n"
           "\t//}\n"
           "\t// TinMan: Flip out straight away if you can't do move.\n"
           "\t/*if ( AI_MOVE_DONE || AI_DEST_UNREACHABLE ) {\n"
           "\t\tsetState( \"state_Idle\" );\t\t\n"
           "\t}*/\n"
           "\t\n"
           "\treactToEnemy = false;\n"
           "\n"
           "\tsetTimer( SABOT_CHASE_TIME ); // TinMan: Start chase timer.\n"
           "\t//chaseTime = sys.getTime() + SABOT_CHASE_TIME; // TinMan: Start chase timer.\n"
           "\n"
           "\teachFrame {\t\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Chase]\" ); // TinMan: *debug*\n"
           "\t\t// TinMan: Check to see if enemy died\n"
           "\t\tif ( AI_ENEMY_DEAD || !getEnemy() ) { // TinMan: idAI checks to see if enemy is alive each think and sets these if not.\n"
           "\t\t\tsetState( \"state_Idle\" );\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t/*\n"
           "\t\t// TinMan: *cheaphack* Don't chase if have flag. rethink once singlegoal/priority\n"
           "\t\tif ( gameType == GAME_CTF ) {\n"
           "\t\t\tif ( getFlagCarrier( team ) == body && getFlagCarrier( 1 - team ) != getEnemy() ) {\n"
           "\t\t\t\tclearEnemy();\n"
           "\t\t\t\tsetState( \"state_Idle\" );\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t*/\n"
           "\t\t\n"
           "\t\t// TinMan: Move along given path\n"
           "\t\tmovePosition = moveAction();\n"
           "\t\t\n"
           "\t\t// TinMan: Lookee where we damn be going.\n"
           "\t\t//movePosition = getMovePosition(); // TinMan: expensive\n"
           "\t\tif ( AI_ONGROUND && movePosition != body.getOrigin() ) {\n"
           "\t\t\taimDir = movePosition - body.getOrigin();\n"
           "\t\t\tsetAimDirection( aimDir );\n"
           "\t\t}\n"
           "\t\t\t\t\n"
           "\t\tcheckBlocked();\n"
           "\t\t\n"
           "\t\tif ( checkShot( true, false ) ) {\n"
           "\t\t\tAI_WEAPON_FIRE = true;\n"
           "\t\t}\n"
           "\n"
           "\t\t// TinMan: Look out for new badasses trying to kill you.\n"
           "\t\tif ( !reactToEnemy ) {\n"
           "\t\t\tif ( nextEnemyLook() || AI_PAIN || AI_ENEMY_VISIBLE ) {\n"
           "\t\t\t\tif ( AI_ENEMY_VISIBLE ) {\n"
           "\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY; // TinMan: Set react timer.\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\tnewEnemy = lookForEnemies( true );\n"
           "\t\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\t\tif ( body.distanceTo( newEnemy ) < enemyRange() ) { // TinMan: Closer than the chump I'm hunting.\n"
           "\t\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY; // TinMan: Set react timer.\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t} else {\n"
           "\t\t\t\t\t\t// TinMan: Shh, I hear something.\n"
           "\t\t\t\t\t\tnewEnemy = listenForEnemies();\n"
           "\t\t\t\t\t\tif ( !newEnemy && AI_PAIN ) { // TinMan: *cheaphack* work around due to fack heardsound is being shoehorned into something it's not desiged to handle - multiple players\n"
           "\t\t\t\t\t\t\tnewEnemy = lookForEnemies( false );\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t\tif ( newEnemy ) {\n"
           "\t\t\t\t\t\t\tif (  body.distanceTo( newEnemy ) < enemyRange() ) { // TinMan: Closer than the chump I'm hunting.\n"
           "\t\t\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY_SOUND; // TinMan: Set react timer.\n"
           "\t\t\t\t\t\t\t}\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tif ( reactToEnemy < sys.getTime() ) {\n"
           "\t\t\t\tsetEnemy( newEnemy );\n"
           "\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\n"
           "\t\tcheckWeapon();\n"
           "\t\t\n"
           "\t\t// TinMan: Look for other items to grab on the way\n"
           "\t\tif ( sys.getTime() > nextSubGoalLook ) {\n"
           "\t\t\tnextSubGoalLook = sys.getTime() + SABOT_NEXT_SUBGOAL_LOOK;\n"
           "\t\t\tsubGoal = lookForGoal( 30, false ); // TinMan: Ignore low priority, we have a mission.\n"
           "\t\t\tfloat buffer = 64; // TinMan: *todo* move, demagic\n"
           "\t\t\tif ( subGoal ) {\n"
           "\t\t\t\tentity enemy = getEnemy();\n"
           "\t\t\t\tif ( travelDistanceBetweenPoints( subGoal.getOrigin(), enemy.getOrigin() ) + buffer < travelDistanceToEntity( enemy ) ) { // TinMan: *todo* sort it oot.\n"
           "\t\t\t\t\twaitFrame();\n"
           "\t\t\t\t\tif ( newEnemy ) { // TinMan: *cheaphack*\n"
           "\t\t\t\t\t\tsetEnemy( newEnemy );\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t\tsetState( \"state_SubGoal\" );\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Get back into the fightening\n"
           "\t\tif ( AI_ENEMY_IN_FOV ) {\n"
           "\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t}\n"
           "\t\t\t\n"
           "\t\t// TinMan: At last seen enemy pos and can't see enemy *todo* rethink\n"
           "\t\tif ( AI_MOVE_DONE || AI_DEST_UNREACHABLE ) {\n"
           "\t\t\tfloat checkTime;\n"
           "\t\t\tif ( checkTime < sys.getTime() ) {\n"
           "\t\t\t\tif ( getEnemy() ) {\n"
           "\t\t\t\t\tif ( !unreachableTime ) {\n"
           "\t\t\t\t\t\tunreachableTime = sys.getTime() + SABOT_ENEMY_UNREACHABLE_TIME;\n"
           "\t\t\t\t\t} else if ( unreachableTime < sys.getTime() ) { // TinMan: Can't reach the bugger. *todo* should do shorter test and check if you can movetoattackpos?\n"
           "\t\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Chase][cantreach time up, clearing enemy!]\" ); // TinMan: *debug*\n"
           "\t\t\t\t\t\tclearEnemy();\n"
           "\t\t\t\t\t\tbreak;\t\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Chase][reset move to enemy!]\" ); // TinMan: *debug*\n"
           "\t\t\t\t\tcheckTime = sys.getTime() + 0.3;\n"
           "\t\t\t\t\tif ( AI_MOVE_DONE ) { // TinMan: Cheat a bit, move towards current enemy pos\n"
           "\t\t\t\t\t\tlocateEnemy(); \n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t\tsetMoveToEnemy();\n"
           "\t\t\t\t\t//setMoveToAttackPosition( getEnemy() );\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tunreachableTime = 0;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Only chase the enemy for a certain amount of time, if it's up you've lost him.\n"
           "\t\t//if ( chaseTime < sys.getTime() ) {\n"
           "\t\tif ( getTimer() ) {\n"
           "\t\t\t// sys.println( \"[\" + int( sys.getTime() ) + \"][state_Chase][ChaseTime Up]\" ); // TinMan: *debug*\n"
           "\t\t\tclearTimer();\n"
           "\t\t\tclearEnemy();\n"
           "\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t}\n"
           "\t} // TinMan: End eachFrame/state\n"
           "\t\n"
           "\t// TinMan: Exit state\n"
           "\tif ( newEnemy ) { // TinMan: *cheaphack* Fix the loosing enemy due to reactiontime and state change *todo* rethink\n"
           "\t\tsetEnemy( newEnemy );\n"
           "\t}\n"
           "\t\n"
           "\tif ( getEnemy() ) {\n"
           "\t\tif ( !AI_ENEMY_VISIBLE ) {\n"
           "\t\t\tsetState( \"state_Chase\" );\n"
           "\t\t} else {\n"
           "\t\t\tsetState( \"state_Combat\" );\n"
           "\t\t}\n"
           "\t} else {\n"
           "\t\tsetState( \"state_Idle\" );\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::state_Retreat\n"
           "TinMan: Trying to escape enemy. Run Forest! Run!\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::state_Retreat() {\n"
           "\t// sys.println( \"[\" + int( sys.getTime() ) + \"][state_Retreat]\" ); // TinMan: *debug*\n"
           "\tfloat nextSubGoalLook;\n"
           "\tfloat reactToEnemy;\n"
           "\tfloat enemyLostTime;\n"
           "\tvector movePosition;\n"
           "\tvector aimDir;\n"
           "\tentity newEnemy;\n"
           "\t\n"
           "\tsubGoal = $null_entity;\n"
           "\t\n"
           "\tclearGoal();\n"
           "\t\n"
           "\tif ( !getEnemy() ) {\n"
           "\t\tsetState( \"state_Idle\" );\n"
           "\t} \n"
           "\t\n"
           "\tsetMoveToCover();\n"
           "\t/* if ( AI_DEST_UNREACHABLE || AI_MOVE_DONE ) {\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][state_Retreat][Cannot move to cover]\" ); // TinMan: *debug*\n"
           "\t\tsetMoveOutOfRange( getEnemy(), 400 ); // TinMan: *todo* no magic\n"
           "\t\tif ( AI_DEST_UNREACHABLE || AI_MOVE_DONE ) {\n"
           "\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][state_Retreat][Cannot move out of range]\" ); // TinMan: *debug*\n"
           "\t\t}\telse {\n"
           "\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][state_Retreat][Moving out of range]\" ); // TinMan: *debug*\n"
           "\t\t}\n"
           "\t} else {\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][state_Retreat][Moving to cover]\" ); // TinMan: *debug*\n"
           "\t} */\n"
           "\n"
           "\teachFrame {\n"
           "\t\t// TinMan: Check to see if enemy died\t\n"
           "\t\tif ( AI_ENEMY_DEAD || !getEnemy() ) { // TinMan: idAI checks to see if enemy is alive each think and sets these if not.\n"
           "\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tif ( AI_MOVE_DONE || AI_DEST_UNREACHABLE ) {\n"
           "\t\t\tclearEnemy();\n"
           "\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Don't want to be running all our lives\n"
           "\t\tif ( !AI_ENEMY_VISIBLE ) {\n"
           "\t\t\tif ( enemyLostTime == 0 ) {\n"
           "\t\t\t\tenemyLostTime = sys.getTime() + 12; // TinMan: *todo* demagic\n"
           "\t\t\t} else if ( enemyLostTime < sys.getTime() ) {\n"
           "\t\t\t\tclearEnemy();\n"
           "\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tif ( AI_PAIN && AI_ENEMY_VISIBLE ) { // TinMan: *todo* set reaction timer\n"
           "\t\t\t\tsetState( \"state_CombatRetreat\" );\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Move along given path\n"
           "\t\tmovePosition = moveAction();\n"
           "\t\t\n"
           "\t\t// TinMan: Lookee where we damn be going.\n"
           "\t\t//movePosition = getMovePosition(); // TinMan: expensive\n"
           "\t\tif ( AI_ONGROUND && movePosition != body.getOrigin() ) {\n"
           "\t\t\taimDir = movePosition - body.getOrigin();\n"
           "\t\t\tsetAimDirection( aimDir );\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tcheckBlocked();\n"
           "\t\t\n"
           "\t\tif ( checkShot( true, false ) ) {\n"
           "\t\t\tAI_WEAPON_FIRE = true;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Look out for new badasses trying to kill you.\n"
           "\t\tif ( !reactToEnemy ) {\n"
           "\t\t\tif ( nextEnemyLook() || AI_PAIN ) {\n"
           "\t\t\t\tnewEnemy = lookForEnemies( true );\n"
           "\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\tif ( body.distanceTo( newEnemy ) < enemyRange() ) { // TinMan: Closer than the chump I'm hunting.\n"
           "\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY; // TinMan: Set react timer.\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\t// TinMan: Shh, I hear something.\n"
           "\t\t\t\t\tnewEnemy = listenForEnemies();\n"
           "\t\t\t\t\tif ( !newEnemy && AI_PAIN ) { // TinMan: *cheaphack* work around due to fack heardsound is being shoehorned into something it's not desiged to handle - multiple players\n"
           "\t\t\t\t\t\tnewEnemy = lookForEnemies( false );\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t\tif ( newEnemy ) {\n"
           "\t\t\t\t\t\tif ( body.distanceTo( newEnemy ) < enemyRange() ) { // TinMan: Closer than the chump I'm hunting.\n"
           "\t\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY_SOUND; // TinMan: Set react timer.\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tif ( reactToEnemy < sys.getTime() ) {\n"
           "\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\t\t\n"
           "\t\tcheckWeapon();\n"
           "\t\t\n"
           "\t\t// TinMan: Look for items that will help you fight\n"
           "\t\tif ( sys.getTime() > nextSubGoalLook ) {\n"
           "\t\t\tnextSubGoalLook = sys.getTime() + SABOT_NEXT_SUBGOAL_LOOK;\n"
           "\t\t\tsubGoal = lookForGoal( 40, true ); // TinMan: Ignore low priority, we a fussin and a fuedin.\n"
           "\t\t\tfloat buffer = 64; // TinMan: *todo* move, demagic\n"
           "\t\t\tif ( subGoal ) {\n"
           "\t\t\t\twaitFrame();\n"
           "\t\t\t\tsetState( \"state_CombatSubGoal\" );\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t} // TinMan: End eachFrame/state\n"
           "\t\n"
           "\t// TinMan: Exit state\n"
           "\tif ( newEnemy ) { // TinMan: *cheaphack* Fix the loosing enemy due to reactiontime and state change *todo* rethink\n"
           "\t\tsetEnemy( newEnemy );\n"
           "\t}\n"
           "\t\n"
           "\tif ( getEnemy() ) {\n"
           "\t\tsetState( \"state_Combat\" );\n"
           "\t} else {\n"
           "\t\tsetState( \"state_Idle\" );\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::state_Hold\n"
           "TinMan: Hold position - Aka camp.\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::state_Hold() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Hold]\" ); // TinMan *debug*\n"
           "\tfloat nextSubGoalLook;\n"
           "\tvector movePosition;\n"
           "\tentity newEnemy;\n"
           "\tfloat reactToEnemy;\n"
           "\n"
           "\treactToEnemy = 0;\n"
           "\n"
           "\tstopMove(); // TinMan: *note* All states should handle movement to that goal, if it doesn't do a move command at start then stopMove previous movement.\n"
           "\t\n"
           "\tsetTimer( SABOT_HOLD_TIME ); // TinMan: Start timer if we don't want to wait forever\n"
           "\t\n"
           "\teachFrame {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + getName() + \"][state_Hold][\" + goal.getName() + \"]\" ); // TinMan *debug*\n"
           "\t\t\n"
           "\t\t// TinMan: Lookin for trouble with a big T.\n"
           "\t\tif ( !reactToEnemy ) {\n"
           "\t\t\tif ( nextEnemyLook() || AI_PAIN || AI_ENEMY_VISIBLE ) {\n"
           "\t\t\t\tif ( AI_ENEMY_VISIBLE ) {\n"
           "\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY; // TinMan: Set react timer.\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\tnewEnemy = lookForEnemies( true );\n"
           "\t\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY; // TinMan: Set react timer.\n"
           "\t\t\t\t\t} else {\n"
           "\t\t\t\t\t\t// TinMan: Shh, I hear something.\n"
           "\t\t\t\t\t\tnewEnemy = listenForEnemies();\n"
           "\t\t\t\t\t\tif ( !newEnemy && AI_PAIN ) { // TinMan: *cheaphack* work around due to fack heardsound is being shoehorned into something it's not desiged to handle - multiple players\n"
           "\t\t\t\t\t\t\tnewEnemy = lookForEnemies( false );\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t\tif ( newEnemy ) {\n"
           "\t\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY_SOUND; // TinMan: Set react timer.\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tif ( reactToEnemy < sys.getTime() ) {\n"
           "\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\n"
           "\t\t// TinMan: What are we waiting for?\t\t\n"
           "\t\tif ( gameType == GAME_CTF ) {\n"
           "\t\t\t/*\n"
           "\t\t\tif ( goal == ourCap ) {\n"
           "\t\t\t\tif ( getFlagStatus( team ) == FLAGSTATUS_INBASE ) {\n"
           "\t\t\t\t\tif ( body.distanceToPoint( goal.getOrigin() ) > 32 ) {\n"
           "\t\t\t\t\t\tgoalType = SABOT_GOAL_MOVE;\n"
           "\t\t\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t} else if ( goal == theirCap ) {\n"
           "\t\t\t\tif ( getFlagStatus( team ) == FLAGSTATUS_INBASE ) {\n"
           "\t\t\t\t\tif ( body.distanceToPoint( goal.getOrigin() ) > 32 ) {\n"
           "\t\t\t\t\t\tgoalType = SABOT_GOAL_MOVE;\n"
           "\t\t\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\t\t\t\t\n"
           "\t\t\t}\n"
           "\t\t\t*/\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: *cheaphack* look somewhere usefull (hopefully), better would be to do a quick predict towards theircap and look there.\n"
           "\t\t\tvector lookDir, capPos;\n"
           "\t\t\tif ( goal == ourCap ) {\n"
           "\t\t\t\tcapPos = theirCap.getOrigin();;\n"
           "\t\t\t} else if ( goal == theirCap ) {\n"
           "\t\t\t\tcapPos = ourCap.getOrigin();\n"
           "\t\t\t}\n"
           "\t\t\tlookDir = capPos - body.getOrigin();\n"
           "\t\t\tlookDir_z = 0;\n"
           "\t\t\tsetAimDirection( lookDir );\n"
           "\t\t\t\n"
           "\t\t\tif ( gotFlag() ) { // TinMan: *cheaphack* got flag?\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + getName() + \"][state_Hold][\" + goal.getName() + \"]\" ); // TinMan *debug*\n"
           "\t\t\t\tclearGoal();\n"
           "\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: We only hold for a certain amount of time in ctf\n"
           "\t\t\tif ( getTimer() ) {\n"
           "\t\t\t\t// sys.println( \"[\" + int( sys.getTime() ) + \"][state_Hold][HoldTime Up]\" ); // TinMan: *debug*\n"
           "\t\t\t\tclearTimer();\n"
           "\t\t\t\tclearGoal();\n"
           "\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Look for other items to grab\n"
           "\t\tif ( sys.getTime() > nextSubGoalLook ) {\n"
           "\t\t\tnextSubGoalLook = sys.getTime() + SABOT_NEXT_SUBGOAL_LOOK;\n"
           "\t\t\tsubGoal = lookForGoal( 10, false );\n"
           "\t\t\tif ( subGoal ) {\n"
           "\t\t\t\twaitFrame();\n"
           "\t\t\t\tif ( newEnemy ) { // TinMan: *cheaphack*\n"
           "\t\t\t\t\tsetEnemy( newEnemy );\n"
           "\t\t\t\t}\n"
           "\t\t\t\tsetState( \"state_SubGoal\" );\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\n"
           "\t\t// TinMan: Move to hold position if too far away\n"
           "\t\tif ( body.distanceToPoint( goal.getOrigin() ) > 128 ) {\n"
           "\t\t\tgoalType = SABOT_GOAL_MOVE; // TinMan: Once the bot reaches the hold goal via movetogoal, the choosegoal will probably set goal back to hold.\n"
           "\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tcheckWeapon(); // TinMan: Make sure your weapon is nice and shiny\n"
           "\t} // TinMan: End eachFrame/state\n"
           "\t\n"
           "\t// TinMan: Exit state\n"
           "\tif ( newEnemy ) { // TinMan: *cheaphack* Fix the loosing enemy due to reactiontime and state change *todo* rethink\n"
           "\t\tsetEnemy( newEnemy );\n"
           "\t}\n"
           "\t\n"
           "\tif ( getEnemy() ) {\n"
           "\t\tsetState( \"state_Combat\" );\n"
           "\t} else {\n"
           "\t\tsetState( \"state_Idle\" );\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::state_Follow\n"
           "TinMan: Follow teammate.\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::state_Follow() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Follow]\" ); // TinMan *debug*\n"
           "\tvector movePosition;\n"
           "\tvector aimDir;\n"
           "\tfloat nextGoalLook;\n"
           "\tentity leader;\n"
           "\tentity newEnemy;\n"
           "\tfloat reactToEnemy;\n"
           "\n"
           "\treactToEnemy = 0;\n"
           "\t\n"
           "\tif ( !goal ) {\n"
           "\t\tsetState( \"state_Idle\" );\n"
           "\t}\n"
           "\t\n"
           "\tleader = goal;\n"
           "\t\n"
           "\tsetMoveToPosition( goal.getOrigin() );\n"
           "\n"
           "\teachFrame {\n"
           "\t\tif ( checkLeader( leader ) || !leader ) { // TinMan: See if we should still go for it\n"
           "\t\t\tsetState( \"state_Idle\" );\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Lookin for trouble with a big T.\n"
           "\t\tif ( !reactToEnemy ) {\n"
           "\t\t\tif ( nextEnemyLook() || AI_PAIN && !getEnemy() ) {\n"
           "\t\t\t\tnewEnemy = lookForEnemies( true );\n"
           "\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY; // TinMan: Set react timer.\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\t// TinMan: Shh, I hear something.\n"
           "\t\t\t\t\tnewEnemy = listenForEnemies();\n"
           "\t\t\t\t\tif ( !newEnemy && AI_PAIN ) { // TinMan: *cheaphack* work around due to fack heardsound is being shoehorned into something it's not desiged to handle - multiple players\n"
           "\t\t\t\t\t\tnewEnemy = lookForEnemies( false );\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t\tif ( newEnemy ) {\n"
           "\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY_SOUND; // TinMan: Set react timer.\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tif ( reactToEnemy < sys.getTime() ) {\n"
           "\t\t\t\tsetEnemy( newEnemy );\n"
           "\t\t\t\tsetState( \"state_Combat\" );\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t/*\n"
           "\t\t// TinMan: Look for other items to grab on the way\n"
           "\t\tif ( sys.getTime() > nextGoalLook ) {\n"
           "\t\t\tnextGoalLook = sys.getTime() + SABOT_NEXT_GOAL_LOOK;\n"
           "\t\t\tsubGoal = lookForGoal( true, false );\n"
           "\t\t\tif ( subGoal ) {\n"
           "\t\t\t\t// TinMan: Don't want to go after items that are out of the way. Unless the bot needs excersise.\n"
           "\t\t\t\t//if ( travelDistanceBetweenEntities( goal, subGoal ) < travelDistanceToEntity( goal ) + 192 ) { // TinMan: *todo* tweak buffer *todo* these funcs are expensive, can you grab current travel distance for current route, I seem to remember it being set somewhere\n"
           "\t\t\t\t\twaitFrame();\n"
           "\t\t\t\t\tsetState( \"state_SubGoal\" );\n"
           "\t\t\t\t//}\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t*/\n"
           "\t\t\n"
           "\t\tsetMoveToPosition( leader.getOrigin() ); // TinMan: Diferent from other states, our goal, the leader is on the move\n"
           "\t\t\n"
           "\t\t// TinMan: The actual following\n"
           "\t\tif  ( body.distanceTo( leader ) < SABOT_FOLLOWDIST_MIN ) {\n"
           "\t\t\t//setAimPosition( getAIAimTargets( leader, true ) );\n"
           "\t\t\tstopMove();\n"
           "\t\t} else if ( body.distanceTo( leader ) > SABOT_FOLLOWDIST_MAX ) {\n"
           "\t\t\t// TinMan: Move along given path\n"
           "\t\t\tmovePosition = moveAction();\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: Lookee where we damn be going.\n"
           "\t\t\t//movePosition = getMovePosition(); // TinMan: expensive\n"
           "\t\t\tif ( AI_ONGROUND && movePosition != body.getOrigin() ) {\n"
           "\t\t\t\taimDir = movePosition - body.getOrigin();\n"
           "\t\t\t\tsetAimDirection( aimDir );\n"
           "\t\t\t}\t\t\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tcheckBlocked();\n"
           "\t\t\n"
           "\t\tif ( checkShot( true, false ) ) {\n"
           "\t\t\tAI_WEAPON_FIRE = true;\n"
           "\t\t}\n"
           "\n"
           "\t\tcheckWeapon(); // TinMan: Make sure your weapon is nice and shiny\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::state_Wander\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::state_Wander() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Hold]\" ); // TinMan *debug*\n"
           "\tfloat nextSubGoalLook;\n"
           "\tvector movePosition;\n"
           "\tentity newEnemy;\n"
           "\tfloat reactToEnemy;\n"
           "\n"
           "\treactToEnemy = 0;\n"
           "\n"
           "\tstopMove(); // TinMan: *note* All states should handle movement to that goal, if it doesn't do a move command at start then stopMove previous movement.\n"
           "\t\n"
           "\tsetTimer( 2 ); // TinMan: Start timer if we don't want to wait forever\n"
           "\t\n"
           "\teachFrame {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + getName() + \"][state_Wander][\" + goal.getName() + \"]\" ); // TinMan *debug*\n"
           "\t\t\n"
           "\t\t// TinMan: Lookin for trouble with a big T.\n"
           "\t\tif ( !reactToEnemy ) {\n"
           "\t\t\tif ( nextEnemyLook() || AI_PAIN || AI_ENEMY_VISIBLE ) {\n"
           "\t\t\t\tif ( AI_ENEMY_VISIBLE ) {\n"
           "\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY; // TinMan: Set react timer.\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\tnewEnemy = lookForEnemies( true );\n"
           "\t\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY; // TinMan: Set react timer.\n"
           "\t\t\t\t\t} else {\n"
           "\t\t\t\t\t\t// TinMan: Shh, I hear something.\n"
           "\t\t\t\t\t\tnewEnemy = listenForEnemies();\n"
           "\t\t\t\t\t\tif ( !newEnemy && AI_PAIN ) { // TinMan: *cheaphack* work around due to fack heardsound is being shoehorned into something it's not desiged to handle - multiple players\n"
           "\t\t\t\t\t\t\tnewEnemy = lookForEnemies( false );\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t\tif ( newEnemy ) {\n"
           "\t\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY_SOUND; // TinMan: Set react timer.\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tif ( reactToEnemy < sys.getTime() ) {\n"
           "\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\n"
           "\t\n"
           "\t\tsetMoveWander();\n"
           "\n"
           "\t\t\t\t\t\n"
           "\t\t// TinMan: Do actual movement\n"
           "\t\tmovePosition = moveAction();\n"
           "\t\n"
           "\t\tif ( getTimer() ) {\n"
           "\t\t\t// sys.println( \"[\" + int( sys.getTime() ) + \"][state_Hold][HoldTime Up]\" ); // TinMan: *debug*\n"
           "\t\t\tclearTimer();\n"
           "\t\t\tclearGoal();\n"
           "\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t}\n"
           "\n"
           "\t\t\n"
           "\t\t/*\n"
           "\t\t// TinMan: Look for other items to grab\n"
           "\t\tif ( sys.getTime() > nextSubGoalLook ) {\n"
           "\t\t\tnextSubGoalLook = sys.getTime() + SABOT_NEXT_SUBGOAL_LOOK;\n"
           "\t\t\tsubGoal = lookForGoal( 10, false );\n"
           "\t\t\tif ( subGoal ) {\n"
           "\t\t\t\twaitFrame();\n"
           "\t\t\t\tif ( newEnemy ) { // TinMan: *cheaphack*\n"
           "\t\t\t\t\tsetEnemy( newEnemy );\n"
           "\t\t\t\t}\n"
           "\t\t\t\tsetState( \"state_SubGoal\" );\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t*/\n"
           "\t\n"
           "\t\t\n"
           "\t\tcheckWeapon(); // TinMan: Make sure your weapon is nice and shiny\n"
           "\t} // TinMan: End eachFrame/state\n"
           "\t\n"
           "\t// TinMan: Exit state\n"
           "\tif ( newEnemy ) { // TinMan: *cheaphack* Fix the loosing enemy due to reactiontime and state change *todo* rethink\n"
           "\t\tsetEnemy( newEnemy );\n"
           "\t}\n"
           "\t\n"
           "\tif ( getEnemy() ) {\n"
           "\t\tsetState( \"state_Combat\" );\n"
           "\t} else {\n"
           "\t\tsetState( \"state_Idle\" );\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::state_Killed\n"
           "TinMan: botAi hijacks script when bots fakeclient is AI_DEAD, sets state to this.\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::state_Killed() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][Died]\" ); // TinMan: *debug*\n"
           "\n"
           "\tstopMove();\n"
           "\t\n"
           "\twhile( AI_DEAD ) {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Killed][waiting]\" ); // TinMan: *debug*\n"
           "\t\t\n"
           "\t\tfloat nextFire;\n"
           "\t\tif ( sys.getTime() > nextFire ) {\n"
           "\t\t\tnextFire = sys.getTime() + 0.1;\n"
           "\t\t\tAI_WEAPON_FIRE = true; // TinMan: Fire so bot respawns\n"
           "\t\t}\n"
           "\t\twaitFrame();\n"
           "\t}\n"
           "\t\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][Restarting]\" ); // TinMan: *debug*\n"
           "\tsetState( \"state_Begin\" );\n"
           "}\n"
           "\n"
           "\n"
           "/***********************************************************************\n"
           "\n"
           "\tFunctions\n"
           "\n"
           "***********************************************************************/\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::setNewGoal\n"
           "TinMan: *todo* complete\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::setNewGoal() {\n"
           "\tgoalType = newGoalType;\n"
           "\t//moveType = newMoveType;\n"
           "\tgoal = newGoal;\n"
           "\t//goalPosition = newGoalPosition; // TinMan: *todo* hmm how do you null a vector?\n"
           "\tgoalPriority = newGoalPriority;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::clearGoal\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::clearGoal() {\n"
           "\tif ( goal ) {\n"
           "\t\toldGoal = goal;\n"
           "\t}\n"
           "\t\n"
           "\tgoalType = 0;\n"
           "\tmoveType = 0;\n"
           "\tgoal = $null_entity;\n"
           "\tgoalPosition = '0 0 0'; // TinMan: *todo* hmm how do you null a vector?\n"
           "\tgoalPriority = 0;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::clearNewGoal\n"
           "TinMan: *todo* complete\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::clearNewGoal() {\n"
           "\tnewGoalType = 0;\n"
           "\t//moveType = 0;\n"
           "\tnewGoal = $null_entity;\n"
           "\t//newGoalPosition = '0 0 0'; // TinMan: *todo* hmm how do you null a vector?\n"
           "\tnewGoalPriority = 0;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::moveForward\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::moveForward() {\n"
           "\tAI_FORWARD = true;\n"
           "\tAI_BACKWARD = false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::moveBackward\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::moveBackward() {\n"
           "\tAI_BACKWARD = true;\n"
           "\tAI_FORWARD = false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::moveRight\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::moveRight() {\n"
           "\tAI_STRAFE_RIGHT = true;\n"
           "\tAI_STRAFE_LEFT = false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::moveLeft\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::moveLeft() {\n"
           "\tAI_STRAFE_LEFT = true;\n"
           "\tAI_STRAFE_RIGHT = false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::moveAction\n"
           "TinMan: Folow path given by routing, check and do more complex navigation actions: Jumps, elevators \n"
           "*todo* Rough as guts, should be moved into botAi and overhauled.\n"
           "Note: pathtype is allways ored against pathtype_walk which is enum 0 so doing equality tests is fine.\n"
           "=====================\n"
           "*/\n"
           "vector bot_sabot::moveAction() {\n"
           "\tfloat pathType;\n"
           "\tvector movePosition, secondaryMovePosition, bodyOrigin, moveDir, velocity;\n"
           "\tfloat dist, moveSpeed;\n"
           "\t\n"
           "\tentity plat;\n"
           "\tfloat i, numListedEntities, radius;\n"
           "\tvector platOrigin, platStart, platBottom;\n"
           "\tvector waitPos;\n"
           "\tradius = 256;\n"
           "\t\n"
           "\tmovePosition = getMovePosition(); // TinMan: expensive\n"
           "\t\n"
           "\tif ( AI_MOVE_DONE || AI_DEST_UNREACHABLE ) {\n"
           "\t\treturn movePosition;\n"
           "\t}\n"
           "\t\n"
           "\tpathType = getPathType();\n"
           "\t\n"
           "\tvelocity = body.getLinearVelocity();\n"
           "\tbodyOrigin = body.getOrigin();\n"
           "\t\n"
           "\t// TinMan: *test* don't strafe on complicated paths\n"
           "\tif ( pathType != PATHTYPE_WALK ) {\n"
           "\t\tAI_STRAFE_RIGHT = false;\n"
           "\t\tAI_STRAFE_LEFT = false;\n"
           "\t}\n"
           "\t\n"
           "\t// reset the topOfPlat reach memory when it has a value and we are no longer using a plat\n"
           "\tif ( pathType != PATHTYPE_ELEVATOR && platTop != '0 0 0' ) {\n"
           "\t\t//sys.println( \"re setting topOfPlat\" ); // TinMan *debug*\n"
           "\t\tplatTop = '0 0 0';\n"
           "\t\tplat = $null_entity;\n"
           "\t}\n"
           "\t\n"
           "\t//sys.debugBounds( '1 1 0', movePosition + '-1 -1 -1', movePosition + '1 1 1' , 0.01 ); // TinMan: *debug*\n"
           "\t\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_MoveToGoal][PATHTYPE: \" + getPathType() + \"]\" ); // TinMan *debug*\n"
           "\tif ( pathType == PATHTYPE_WALK ) {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_MoveToGoal][PATHTYPE_WALK]\" ); // TinMan *debug*\n"
           "\t\t\t\n"
           "\t\t// TinMan: Do actual movement\n"
           "\t\tmoveDir = movePosition - bodyOrigin;\n"
           "\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\n"
           "\t\tdist = sys.vecLength( moveDir );\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][dist: \" + dist + \"]\" ); // TinMan *debug*\n"
           "\t\t// TinMan: This code is a complete nasty mess at the moment. The problem being caused by an area under a platform. A bot chasing a player as he hits the platform will get a walk path to the area under the platform, if the platfor rises the bot could move under the platform. The path doesn't seem to fail or be done despite ai_debugmove showing bot trying to move to top of elevator ( which in a walk path he can't )\n"
           "\t\tif ( dist < 128 ) { // TinMan: Getting close\n"
           "\t\t\t//float pong = movePosition_z  - bodyOrigin_z;\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][ping][pong: \" + pong + \"]\" ); // TinMan *debug*\n"
           "\t\t\t//if ( movePosition_z - bodyOrigin_z > 16 ) { // TinMan: At moveposition but it's above bots head. stupid *todo* hmm, moveposition still seems to be at ground so this won't work.\n"
           "\t\t\t\t// TinMan: See if it's the plat weirdness *todo* shift this to checkblocked?\n"
           "\t\t\t\tnumListedEntities = findInRadius( movePosition, radius, \"idPlat\" );\n"
           "\t\t\t\t/* if ( numListedEntities > 1 ) {\n"
           "\t\t\t\t\tsys.warning( \"[\" + int( sys.getTime() ) + \"][moveAction][More than 1 plat]\" ); // TinMan *debug*\n"
           "\t\t\t\t\t// TinMan: *todo* get closest\n"
           "\t\t\t\t} */\n"
           "\t\t\t\tfor ( i = 0; i < numListedEntities; i++ ) {\n"
           "\t\t\t\t\tplat = getEntityList( i );\n"
           "\t\t\t\t}\n"
           "\t\t\t\tif ( plat ) {\n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][Found plat]\" ); // TinMan *debug*\n"
           "\t\t\t\t\tplatOrigin = plat.getOrigin();\n"
           "\t\t\t\t\tplatStart = plat.getVectorKey( \"origin\" ); // TinMan: Grab spawn origin - the plats starting origin - the top\n"
           "\t\t\t\t\tplatBottom = platStart;\n"
           "\t\t\t\t\tplatBottom_z -= plat.getFloatKey( \"height\" );\n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][platOrigin z: \" + platOrigin_z + \"][platOrigin z: \" + platStart_z + \"]\" ); // TinMan *debug* *todo* why isn't origin updated?\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t\t//sys.debugBounds( '1 0 0', platOrigin + plat.getMins(), platOrigin + plat.getMaxs() , 1 ); // TinMan: *debug* \n"
           "\t\t\t\t\tif ( platOrigin_z > platBottom_z + 32 && isUnderPlat( plat ) ) { // TinMan: Plat above?\n"
           "\t\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][under plat!]\" ); // TinMan *debug* *todo* why isn't origin updated?\n"
           "\t\t\t\t\t\twaitPos = getWaitPosition( plat );\n"
           "\t\t\t\t\t\tmoveDir = waitPos - bodyOrigin;\n"
           "\t\t\t\t\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\t\t\t\tdist = sys.vecLength( moveDir );\n"
           "\t\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][dist to waitpos:\" + dist + \"]\" ); // TinMan *debug*\n"
           "\t\t\t\t\t\tif ( dist > 8 ) {\n"
           "\t\t\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][path_walk: move to waitpos]\" ); // TinMan *debug*\n"
           "\t\t\t\t\t\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t} else {\n"
           "\t\t\t\t\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t\t\t\t }\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t\t\t}\n"
           "\t\t\t//}\n"
           "\t\t} else {\n"
           "\t\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t}\n"
           "\t\t//moveForward();\n"
           "\t\t\n"
           "\t\t//checkBlocked();\n"
           "\t//} else if ( getPathType() & PATHTYPE_WALKOFFLEDGE ) {\n"
           "\t\t\n"
           "\t} else if ( pathType & PATHTYPE_BARRIERJUMP ) {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][PATHTYPE_BARRIERJUMP]\" ); // TinMan *debug*\n"
           "\t\t//sys.debugBounds( '1 0 0', getSecondaryMovePosition() + '-1 -1 -1', getSecondaryMovePosition() + '1 1 1' , 0.01 ); // TinMan: *debug* show bound secondarypos\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][LinearVelocity:\" + body.getLinearVelocity() + \"][vecLength:\" + sys.vecLength( body.getLinearVelocity() ) + \"]\" ); // TinMan *debug*\n"
           "\t\tif ( body.distanceToPoint( movePosition ) < 8 ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][close to moveposition]\" ); // TinMan *debug*\n"
           "\t\t\t\t\n"
           "\t\t\t// TinMan: Ping a vector from self through jump end (which will be directly above jump start position)\n"
           "\t\t\t//secondaryMovePosition = getSecondaryMovePosition();\n"
           "\n"
           "\t\t\t//moveDir = movePosition - bodyOrigin;\n"
           "\t\t\t//moveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\t//movePosition = moveDir * 2048;\n"
           "\t\t\t//movePosition_z = bodyOrigin_z + viewHeight;\n"
           "\t\t\t//sys.debugBounds( '0 1 0', movePosition + '-1 -1 -1', movePosition + '1 1 1' , 0.01 ); // TinMan: *debug* show bound secondarypos\n"
           "\t\t\t//setAimPosition( movePosition );\n"
           "\t\t\t\t\n"
           "\t\t\t//moveForward();\n"
           "\t\t\tAI_JUMP = true;\n"
           "\t\t\t//AI_JUMP = !AI_JUMP;\n"
           "\t\t} else if ( AI_ONGROUND ) { // TinMan: Move to jump position *todo* need propper check to indicate we aren't interested in reach start but reach end.\n"
           "\t\t\t// TinMan: Do actual movement\n"
           "\t\t\tmoveDir = movePosition - bodyOrigin;\n"
           "\t\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\t\n"
           "\t\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t\t//moveForward();\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][vertical vel: \" + velocity_z + \"]\" ); // TinMan *debug*\n"
           "\t\t\n"
           "\t\t// TinMan: Going down\n"
           "\t\tif ( velocity_z < 250 /*&& !AI_ONGROUND*/ ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][falling]\" ); // TinMan *debug*\n"
           "\t\t\t//moveForward();\n"
           "\t\t\t\t\n"
           "\t\t\t// TinMan: While it's more propper to use secondarypos, since in this case the reach end is right above reach start there isn't much of a difference, movepos even seems to be working a little better, haven't looked into why.\n"
           "\t\t\t//secondaryMovePosition = getSecondaryMovePosition();\n"
           "\t\t\t//moveDir = secondaryMovePosition - bodyOrigin;\n"
           "\t\t\tmoveDir = movePosition - bodyOrigin;\n"
           "\t\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\t\t\n"
           "\t\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t}\n"
           "\t\n"
           "\t} else if ( pathType & PATHTYPE_ELEVATOR ) {\n"
           "\t\t// set the topOfPlat the first time we hit elevator and it isn't set (this is valid top from WalkPathToGoal)\n"
           "\t\tif ( platTop == '0 0 0' ) {\n"
           "\t\t\tplatTop = getSecondaryMovePosition();\n"
           "\t\t} \n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][PATHTYPE_ELEVATOR]\" ); // TinMan *debug*\n"
           "\t\t\n"
           "\t\t//secondaryMovePosition = getSecondaryMovePosition();\n"
           "\t\t//sys.debugBounds( '0 0 1', movePosition + '-4 -4 -4', movePosition + '4 4 4' , 10 ); // TinMan: *debug*\n"
           "\t\t//sys.debugBounds( '0.5 0 1', secondaryMovePosition + '-4 -4 -4', secondaryMovePosition + '4 4 4' , 10 ); // TinMan: *debug*\n"
           "\t\t\t\n"
           "\t\t// TinMan: *todo* so damn crude, better to just go through all plats and find closest to bot?\n"
           "\t\tnumListedEntities = findInRadius( bodyOrigin, radius, \"idPlat\" );\n"
           "\t\t//numListedEntities = findInRadius( movePosition, radius, \"idPlat\" );\n"
           "\t\t/*if ( !numListedEntities ) {\n"
           "\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][spang!]\" ); // TinMan *debug*\n"
           "\t\t\tnumListedEntities = findInRadius( secondaryMovePosition, radius, \"idPlat\" );\n"
           "\t\t}\n"
           "\t\t*/\n"
           "\t\t/*if ( !numListedEntities ) {\n"
           "\t\t\tnumListedEntities = findInRadius( bodyOrigin, radius, \"idPlat\" );\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][why bobo why!]\" ); // TinMan *debug*\n"
           "\t\t}*/\n"
           "\t\t\n"
           "\t\t/*\n"
           "\t\tif ( numListedEntities > 1 ) {\n"
           "\t\t\tsys.warning( \"[\" + int( sys.getTime() ) + \"][moveAction][More than 1 plat]\" ); // TinMan *debug*\n"
           "\t\t\t// TinMan: *todo* get closest\n"
           "\t\t}\n"
           "\t\t*/\n"
           "\t\tfor ( i = 0; i < numListedEntities; i++ ) {\n"
           "\t\t\tplat = getEntityList( i );\n"
           "\t\t}\n"
           "\t\tif ( plat ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][Found plat]\" ); // TinMan *debug*\n"
           "\t\t\tplatOrigin = plat.getOrigin();\n"
           "\t\t\tplatStart = plat.getVectorKey( \"origin\" ); // TinMan: Grab spawn origin - the plats starting origin - the top\n"
           "\t\t\tplatBottom = platStart;\n"
           "\t\t\tplatBottom_z -= plat.getFloatKey( \"height\" );\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][platOrigin z: \" + platOrigin_z + \"][platOrigin z: \" + platStart_z + \"]\" ); // TinMan *debug* *todo* why isn't origin updated?\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tif ( body.touches( plat ) && platOrigin_z <= bodyOrigin_z ) { // TinMan: On plat (not under)\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][On plat][platOrigin z: \" + platStart_z + \"][platOrigin z: \" + platStart_z + \"]\" ); // TinMan *debug*\n"
           "\t\t\tif ( platOrigin_z >= platStart_z - 24 ) { // TinMan: Plat near top. 18 = stepheight\n"
           "\t\t\t\t// TinMan: Move to end point\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][On plat: Move to end]\" ); // TinMan *debug*\n"
           "\t\t\t\t//moveDir = movePosition - bodyOrigin;\n"
           "\t\t\t\tmoveDir = platTop - bodyOrigin;\n"
           "\t\t\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t\t\t\n"
           "\t\t\t\tmovePosition = platTop;\n"
           "\t\t\t} else {\n"
           "\t\t\t\t// TinMan: Move to middle of plat\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][On plat: Move to center]\" ); // TinMan *debug*\n"
           "\t\t\t\tmoveDir = platBottom - bodyOrigin;\n"
           "\t\t\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\t\tdist = sys.vecLength( moveDir );\n"
           "\t\t\t\tif ( dist > 4 ) { \n"
           "\t\t\t\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t\t\t}\n"
           "\t\t\t\t\n"
           "\t\t\t\t//movePosition = platBottom;\n"
           "\t\t\t}\n"
           "\t\t} else if ( plat ) { // TinMan: Not on plat\n"
           "\t\t\t// TinMan: Move to plat\n"
           "\t\t\tmoveDir = movePosition - bodyOrigin;\n"
           "\t\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\tdist = sys.vecLength( moveDir );\n"
           "\t\t\tif ( platOrigin_z < platBottom_z + 18 ) { // TinMan: plat at bottom \n"
           "\t\t\t\tif ( dist > 32 ) { \n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][move reach start]\" ); // TinMan *debug*\n"
           "\t\t\t\t\tsetMoveDirection( moveDir, 400 ); // TinMan: Move to reach start\n"
           "\t\t\t\t} else { // TinMan: else close to reach\n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][move plat center]\" ); // TinMan *debug*\n"
           "\t\t\t\t\t// TinMan: Move to middle of plat\n"
           "\t\t\t\t\tmoveDir = platBottom - bodyOrigin;\n"
           "\t\t\t\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\t\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t\t//movePosition = platBottom;\n"
           "\t\t\t\t}\n"
           "\t\t\t} else {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][plat not at bottom: move reach start]\" ); // TinMan *debug*\n"
           "\t\t\t\tif ( isUnderPlat( plat ) ) { // TinMan: Plat above?\n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][under plat!]\" ); // TinMan *debug* *todo* why isn't origin updated?\n"
           "\t\t\t\t\twaitPos = getWaitPosition( plat );\n"
           "\t\t\t\t\tmoveDir = waitPos - bodyOrigin;\n"
           "\t\t\t\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\t\t\tdist = sys.vecLength( moveDir );\n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][dist to waitpos:\" + dist + \"]\" ); // TinMan *debug*\n"
           "\t\t\t\t\tif ( dist > 8 ) {\n"
           "\t\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][path_elev: move to waitpos]\" ); // TinMan *debug*\n"
           "\t\t\t\t\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t\t//movePosition = waitPos;\n"
           "\t\t\t\t} /*else {\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t}*/\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t} else if ( !plat ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][!plat]\" ); // TinMan *debug*\t\n"
           "\t\t\t//sys.debugBounds( '1 0 0', movePosition + '-4 -4 -4', movePosition + '4 4 4' , 10 ); // TinMan: *debug*\n"
           "\t\t\tmoveDir = movePosition - bodyOrigin;\n"
           "\t\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t//sys.debugBounds( '1 0 0', platStart + '-1 -1 -1', platStart + '1 1 1' , 1000 ); // TinMan: *debug*\n"
           "\t\t//sys.debugBounds( '1 1 0', platBottom + '-1 -1 -1', platBottom + '1 1 1' , 1000 ); // TinMan: *debug*\n"
           "\t\t\n"
           "\t} else { // TinMan: Unknown pathtype\n"
           "\t\t// TinMan: Have a bash at it anyway\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][Unhandled pathtype: \" + getPathType() + \"]\" ); // TinMan *debug*\n"
           "\t\t\n"
           "\t\t// TinMan: Do actual movement\n"
           "\t\tmoveDir = movePosition - bodyOrigin;\n"
           "\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t\n"
           "\t\t//checkBlocked();\n"
           "\t}\n"
           "\t\n"
           "\treturn movePosition;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::setTimer\n"
           "TinMan: I am the very model of a modern major general\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::setTimer( float endTime ) {\n"
           "\t//timerAmount = time;\n"
           "\t//timerStart = sys.getTime();\n"
           "\ttimerEnd = sys.getTime() + endTime;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::getTimer\n"
           "TinMan: the bell, the bells\n"
           "=====================\n"
           "*/\n"
           "float bot_sabot::getTimer() {\n"
           "\tif ( timerEnd == -1 ) { // TinMan: Timer not set\n"
           "\t\t//return -1;\n"
           "\t\treturn false;\n"
           "\t} else if ( timerEnd < sys.getTime() ) { // TinMan: Timer over\n"
           "\t\t// TinMan: *todo* return Elapsed time\n"
           "\t\t//clearTimer(); // TinMan: Reset timer now it's over, since sometimes you'll be checking if theres a timer set `*todo* rethink this\n"
           "\t\treturn true; \n"
           "\t} else { // TinMan: Timer still going\n"
           "\t\t// TinMan: *todo* return Elapsed time\n"
           "\t\treturn false; \n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::clearTimer\n"
           "TinMan: car button cloth\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::clearTimer() {\n"
           "\ttimerEnd = -1;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::nextEnemyLook\n"
           "TinMan: Timer\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot::nextEnemyLook() {\n"
           "\tif ( sys.getTime() > nextEnemyLookTime ) {\n"
           "\t\tnextEnemyLookTime = sys.getTime() + SABOT_NEXT_ENEMY_LOOK;\n"
           "\t\treturn true;\n"
           "\t}\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/***********************************************************************\n"
           "\n"
           "\tChecks\n"
           "\n"
           "***********************************************************************/\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::checkGoal\n"
           "TinMan: See if we still want this goal, bumps off goal if it's old and mankey, or if we just want to rechoose goal.\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot::checkGoal( entity thisGoal ) {\n"
           "\tvector origin, goalOrigin;\n"
           "\tfloat goalDist;\n"
           "\t\n"
           "\tif ( !thisGoal ) {\n"
           "\t\treturn true;\n"
           "\t}\n"
           "\t\n"
           "\tgoalDist = body.distanceTo( thisGoal );\n"
           "\n"
           "\tif ( goalDist < 150 ) {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][checkGoal][close, checking]\" ); // TinMan *debug*\n"
           "\t\tif ( thisGoal.isHidden() ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][checkGoal][goal ishidden]\" ); // TinMan *debug*\n"
           "\t\t\treturn true;\n"
           "\t\t} else if ( body.touches( thisGoal ) ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][checkGoal][touched goal]\" ); // TinMan *debug*\n"
           "\t\t\treturn true;\n"
           "\t\t} else if ( goalDist < 4 ) {\n"
           "\t\t\treturn true;\n"
           "\t\t}\t\n"
           "\t}\n"
           "\n"
           "\t// TinMan: It seems (though not certain)that flag carrier is set even if you are just touching your flag to return, this will drop ourcap in this case.\n"
           "\t// *todo* *test* not working at all? will nerf moveto defence anyway, found out if the above^ really is the case.\n"
           "\t/*\n"
           "\tif ( gameType == GAME_CTF ) {\n"
           "\t\tif ( thisGoal == ourCap && !getFlagCarrier( team ) == body ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][checkGoal][tard is going for ourCap and doesn't have flag]\" ); // TinMan *debug*\n"
           "\t\t\treturn true;\n"
           "\t\t}\n"
           "\t}\n"
           "\t*/\n"
           "\t\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::gotFlag\n"
           "TinMan: *cheaphack* a fix untill single goal/priority is sorted\n"
           "*todo* expand into more general flag checking?\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot::gotFlag() {\n"
           "\tif ( getFlagCarrier( team ) == body ) {\n"
           "\t\t// TinMan: Did we get flag somehow? If so dump goal and go to idle where chooseGoal will sort it out.\n"
           "\t\tif ( goal != ourCap ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_hold][!have flag!]\" ); // TinMan *debug*\n"
           "\t\t\treturn true;\n"
           "\t\t}\n"
           "\t}\n"
           "\t\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::checkEnemy\n"
           "TinMan: See if we still want to fight this enemy.\n"
           "TinMan: *todo* no magic numbers, set em up and tweak em.\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot::checkEnemy( entity thisEnemy ) {\n"
           "\tfloat selfPriority, enemyPriority;\n"
           "\t\n"
           "\t/*\n"
           "\tif ( !getEnemy() ) {\n"
           "\t\treturn true;\n"
           "\t}\n"
           "\t*/\n"
           "\t\n"
           "\tif ( AI_ENEMY_VISIBLE ) {\n"
           "\t\tenemyPriority = getPlayerPriority( thisEnemy );\n"
           "\t\tselfPriority = getPlayerPriority( body ) + 30;  // TinMan: *todo* fool! no magic number\n"
           "\t\t// TinMan: Enemy too badass for me! I ph34r him!\n"
           "\t\tif ( enemyPriority > selfPriority ) {\n"
           "\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][checkEnemy][Enemy too badass for me! I ph34r him!]\" ); // TinMan *debug* \" : \" + getClassName( item ) +\n"
           "\t\t\treturn true;\n"
           "\t\t} /* else if ( selfPriority < 50 ) { // TinMan: *todo* fool! no magic number\n"
           "\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][checkEnemy][Self Priority too low]\" ); // TinMan *debug* \" : \" + getClassName( item ) +\n"
           "\t\t\treturn true;\n"
           "\t\t} */\n"
           "\t}\n"
           "\t\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::checkSelf\n"
           "TinMan: See if you are happy with your weapon/hp/armor. Returns true if not happy happy joy joy.\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot::checkSelf() {\n"
           "\tfloat weaponPriority;\n"
           "\n"
           "\tweaponPriority = getFloatKey( \"priority_\" + body.getCurrentWeapon() ); // TinMan: Grab priority from def\n"
           "\n"
           "\tif ( weaponPriority <= 10 && getActorHealth( body ) + getArmor( body ) < 40 ) { // TinMan: better weapon than pistol *todo* demagic happystrenght\n"
           "\t\treturn true;\n"
           "\t}\n"
           "\t\n"
           "\tif ( weaponPriority < 40 && getActorHealth( body ) + getArmor( body ) <= 20 && !AI_PAIN ) { // TinMan: Weapon < chaingun and very beat up, if your allready getting hurt you're probably going to die anyway\n"
           "\t\treturn true;\n"
           "\t}\n"
           "\t\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::checkLeader\n"
           "TinMan: \n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot::checkLeader( entity thisLeader ) {\n"
           "\tif ( !thisLeader ) {\n"
           "\t\treturn true;\n"
           "\t}\n"
           "\n"
           "\tif ( getActorHealth( thisLeader ) <= 0 ) {\n"
           "\t\treturn true;\n"
           "\t}\n"
           "\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::checkWeapon\n"
           "TinMan: Make sure your weapon is in order\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot::checkWeapon() {\n"
           "\tentity enemy;\n"
           "\tstring weaponName;\n"
           "\t\n"
           "\t/*\n"
           "\tif ( getEnemy() ) {\n"
           "\t\tchooseWeapon( enemyRange() );\t\n"
           "\t} else {\n"
           "\t\tchooseWeapon( -1 );\t\n"
           "\t}\n"
           "\t*/\n"
           "\t\n"
           "\t//nextBestWeapon();\n"
           "\tchooseWeapon( 1 );\n"
           "\t\n"
           "\tweaponRange = getVectorKey( \"range_\" + currentWeapon ); // TinMan: Grab ranges from def\n"
           "\n"
           "\t// TinMan: Autoload only works on next fire after empty (I may be mistaken)\n"
           "\tif ( weapon.ammoInClip() == 0 ) {\n"
           "\t\tweapon.WEAPON_RELOAD = true;\n"
           "\t}\n"
           "\n"
           "\tif ( !getEnemy() && !AI_PAIN ) {\n"
           "\t\tif ( weapon.ammoInClip() <= 20 ) { // TinMan:*todo* demagic\n"
           "\t\t\tweapon.WEAPON_RELOAD = true;\n"
           "\t\t}\n"
           "\t}\n"
           "\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::checkStrafeLeft\n"
           "TinMan: Crude as hell, but will do for now\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot::checkStrafeLeft() {\n"
           "\tvector\tpos, ang, dir, tracePosition;\n"
           "\tfloat maxRange, frac, traceDistance;\n"
           "\t//entity\ttraceEntity;\n"
           "\n"
           "\tmaxRange = SABOT_CHECK_MOVE_DISTANCE; // TinMan: Max a bounds trace can do is 4096.\n"
           "\n"
           "\tpos = getViewPosition();\n"
           "\tang = body.getViewAngles();\n"
           "\n"
           "\tang_x = 0;\n"
           "\tang_z = 0;\n"
           "\tang_y += 90;\n"
           "\tdir = sys.angToForward( ang ); // TinMan: Convert angles (pitch yaw roll), to forward vector (x y z).\n"
           "\n"
           "\tfrac = sys.tracePoint( pos, pos + ( dir * maxRange ), CONTENTS_OPAQUE | MASK_SHOT_RENDERMODEL, self );\n"
           "\n"
           "\t/*\n"
           "\ttraceDistance = frac * maxRange; // TinMan: Convert the fraction of trace completed to game units\n"
           "\ttracePosition = sys.getTraceEndPos(); // TinMan: Get where trace hit\n"
           "\n"
           "\tfloat debugTime = 0.01;\n"
           "\tsys.debugLine( '0 1 1', pos, pos + ( dir * maxRange ), debugTime ); // TinMan: *debug* full trace\n"
           "\tsys.debugBounds( '1 0 0', pos + '-1 -1 -1', pos + '1 1 1' , debugTime ); // TinMan: *debug* show bound at eyes\n"
           "\n"
           "\tsys.debugLine( '0 1 0', pos, tracePosition,\tdebugTime ); // TinMan: *debug* trace\n"
           "\tsys.debugBounds( '1 1 0', tracePosition + '-2 -2 -2', tracePosition + '2 2 2' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\t*/\n"
           "\n"
           "\tif ( frac == 1 ) {\n"
           "\t\treturn true;\n"
           "\t} else {\n"
           "\t\treturn false;\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::checkStrafeRight\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot::checkStrafeRight() {\n"
           "\tvector\tpos, ang, dir, tracePosition;\n"
           "\tfloat maxRange, frac, traceDistance;\n"
           "\t//entity\ttraceEntity;\n"
           "\n"
           "\tmaxRange = SABOT_CHECK_MOVE_DISTANCE; // TinMan: Max a bounds trace can do is 4096.\n"
           "\n"
           "\tpos = getViewPosition();\n"
           "\tang = body.getViewAngles();\n"
           "\n"
           "\tang_x = 0;\n"
           "\tang_z = 0;\n"
           "\tang_y -= 90;\n"
           "\tdir = sys.angToForward( ang ); // TinMan: Convert angles (pitch yaw roll), to forward vector (x y z).\n"
           "\n"
           "\tfrac = sys.tracePoint( pos, pos + ( dir * maxRange ), CONTENTS_OPAQUE | MASK_SHOT_RENDERMODEL, self );\n"
           "\n"
           "\t/*\n"
           "\ttraceDistance = frac * maxRange; // TinMan: Convert the fraction of trace completed to game units\n"
           "\ttracePosition = sys.getTraceEndPos(); // TinMan: Get where trace hit\n"
           "\n"
           "\tfloat debugTime = 0.01;\n"
           "\tsys.debugLine( '0 1 1', pos, pos + ( dir * maxRange ), debugTime ); // TinMan: *debug* full trace\n"
           "\tsys.debugBounds( '1 0 0', pos + '-1 -1 -1', pos + '1 1 1' , debugTime ); // TinMan: *debug* show bound at eyes\n"
           "\n"
           "\tsys.debugLine( '0 1 0', pos, tracePosition,\tdebugTime ); // TinMan: *debug* trace\n"
           "\tsys.debugBounds( '1 1 0', tracePosition + '-2 -2 -2', tracePosition + '2 2 2' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\t*/\n"
           "\n"
           "\tif ( frac == 1 ) {\n"
           "\t\treturn true;\n"
           "\t} else {\n"
           "\t\treturn false;\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::checkMoveForward\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot::checkMoveForward() {\n"
           "\tvector\tpos, ang, dir, tracePosition;\n"
           "\tfloat maxRange, frac, traceDistance;\n"
           "\tentity\ttraceEntity;\n"
           "\n"
           "\tmaxRange = SABOT_CHECK_MOVE_DISTANCE; // TinMan: Max a bounds trace can do is 4096.\n"
           "\n"
           "\t//pos = getViewPosition();\n"
           "\tpos = body.getOrigin();\n"
           "\tang = body.getViewAngles();\n"
           "\n"
           "\tang_x = 0;\n"
           "\tang_z = 0;\n"
           "\tdir = sys.angToForward( ang ); // TinMan: Convert angles (pitch yaw roll), to forward vector (x y z).\n"
           "\n"
           "\tfrac = sys.tracePoint( pos, pos + ( dir * maxRange ), CONTENTS_OPAQUE | MASK_SHOT_RENDERMODEL, self );\n"
           "\n"
           "\ttraceDistance = frac * maxRange; // TinMan: Convert the fraction of trace completed to game units\n"
           "\ttracePosition = sys.getTraceEndPos(); // TinMan: Get where trace hit\n"
           "\n"
           "\t/*\n"
           "\tfloat debugTime = 0.01;\n"
           "\tsys.debugLine( '0 1 1', pos, pos + ( dir * maxRange ), debugTime ); // TinMan: *debug* full trace\n"
           "\tsys.debugBounds( '1 0 0', pos + '-1 -1 -1', pos + '1 1 1' , debugTime ); // TinMan: *debug* show bound at eyes\n"
           "\t*/\n"
           "\n"
           "\t/*\n"
           "\tsys.debugLine( '0 1 0', pos, tracePosition,\tdebugTime ); // TinMan: *debug* trace\n"
           "\tsys.debugBounds( '1 1 0', tracePosition + '-2 -2 -2', tracePosition + '2 2 2' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\t*/\n"
           "\n"
           "\tif ( frac == 1 ) {\n"
           "\t\treturn true;\n"
           "\t} else {\n"
           "\t\treturn false;\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::checkMoveBack\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot::checkMoveBack() {\n"
           "\tvector\tpos, ang, dir, tracePosition;\n"
           "\tfloat maxRange, frac, traceDistance;\n"
           "\t//entity\ttraceEntity;\n"
           "\n"
           "\tmaxRange = SABOT_CHECK_MOVE_DISTANCE; // TinMan: Max a bounds trace can do is 4096.\n"
           "\n"
           "\tpos = getViewPosition();\n"
           "\tang = body.getViewAngles();\n"
           "\n"
           "\tang_x = 0;\n"
           "\tang_z = 0;\n"
           "\tang_y += 180;\n"
           "\tdir = sys.angToForward( ang ); // TinMan: Convert angles (pitch yaw roll), to forward vector (x y z).\n"
           "\n"
           "\tfrac = sys.tracePoint( pos, pos + ( dir * maxRange ), CONTENTS_OPAQUE | MASK_SHOT_RENDERMODEL, self );\n"
           "\n"
           "\t/*\n"
           "\ttraceDistance = frac * maxRange; // TinMan: Convert the fraction of trace completed to game units\n"
           "\ttracePosition = sys.getTraceEndPos(); // TinMan: Get where trace hit\n"
           "\n"
           "\tfloat debugTime = 0.01;\n"
           "\tsys.debugLine( '0 1 1', pos, pos + ( dir * maxRange ), debugTime ); // TinMan: *debug* full trace\n"
           "\tsys.debugBounds( '1 0 0', pos + '-1 -1 -1', pos + '1 1 1' , debugTime ); // TinMan: *debug* show bound at eyes\n"
           "\n"
           "\tsys.debugLine( '0 1 0', pos, tracePosition,\tdebugTime ); // TinMan: *debug* trace\n"
           "\tsys.debugBounds( '1 1 0', tracePosition + '-2 -2 -2', tracePosition + '2 2 2' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\t*/\n"
           "\n"
           "\tif ( frac == 1 ) {\n"
           "\t\treturn true;\n"
           "\t} else {\n"
           "\t\treturn false;\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::checkMoves\n"
           "TinMan: Do simple trace check in each direction and return results as flags. *todo* can't seem to do a propper negative test, doesn't matter anyway these functions are just hacks untill I delve a bit deeper into pathing.\n"
           "=====================\n"
           "*/\n"
           "float bot_sabot::checkMoves() {\n"
           "\tvector\tpos, ang, dir, tracePosition;\n"
           "\tfloat maxRange, frac, traceDistance;\n"
           "\tfloat i, moveFlags;\n"
           "\t//entity\ttraceEntity;\n"
           "\n"
           "\tmoveFlags = 0;\n"
           "\n"
           "\tmaxRange = SABOT_CHECK_MOVE_DISTANCE; // TinMan: Max a bounds trace can do is 4096.\n"
           "\n"
           "\tpos = getViewPosition();\n"
           "\tang = body.getViewAngles();\n"
           "\n"
           "\tang_x = 0;\n"
           "\tang_z = 0;\n"
           "\n"
           "\t//float debugTime = 0.01;\n"
           "\t//sys.debugBounds( '1 0 0', pos + '-1 -1 -1', pos + '1 1 1' , debugTime ); // TinMan: *debug* show bound at eyes\n"
           "\n"
           "\t// TinMan: Test fwd,right,back,left.\n"
           "\tfor( i = 1; i < 10; i = i * 2 ) {\n"
           "\t\tdir = sys.angToForward( ang ); // TinMan: Convert angles (pitch yaw roll), to forward vector (x y z).\n"
           "\n"
           "\t\tfrac = sys.tracePoint( pos, pos + ( dir * maxRange ), CONTENTS_OPAQUE | MASK_SHOT_RENDERMODEL, self );\n"
           "\n"
           "\t\ttraceDistance = frac * maxRange; // TinMan: Convert the fraction of trace completed to game units\n"
           "\t\ttracePosition = sys.getTraceEndPos(); // TinMan: Get where trace hit\n"
           "\n"
           "\t\t/*\n"
           "\t\tsys.debugLine( '0 1 1', pos, pos + ( dir * maxRange ), debugTime ); // TinMan: *debug* full trace\n"
           "\n"
           "\t\tsys.debugLine( '0 1 0', pos, tracePosition,\tdebugTime ); // TinMan: *debug* trace\n"
           "\t\tsys.debugBounds( '1 1 0', tracePosition + '-2 -2 -2', tracePosition + '2 2 2' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\t\t*/\n"
           "\n"
           "\t\tif ( frac == 1 ) {\n"
           "\t\t\tmoveFlags |= i;\n"
           "\t\t}\n"
           "\n"
           "\t\tang_y += 90;\n"
           "\t}\n"
           "\n"
           "\treturn moveFlags;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_vladimir::checkBlocked\n"
           "TinMan: Deals with being blocked while moving to destination. \n"
           "*todo* save obstacle pos and check if it's moved, if it hasn't return true so we can choose new path\n"
           "*todo* this is currenly the only func that traps in a loop, rethink if you want this.\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot::checkBlocked() {\n"
           "\t//sys.println( \"[\" + sys.getTime() + \"][checkBlocked()]\" ); // TinMan: *debug*\n"
           "\tentity obstacle;\n"
           "\tvector obstacle_pos;\n"
           "\tvector delta;\n"
           "\tfloat dist;\n"
           "\tfloat endTime;\n"
           "\tvector movePosition;\n"
           "\tvector aimDir;\n"
           "\t\n"
           "\tfloat numListedEnemies;\n"
           "\tentity enemy;\n"
           "\t\n"
           "\t/*if ( moveStatus() > MOVE_STATUS_DONE ) {\n"
           "\t\tsys.println( \"[\" + sys.getTime() + \"][checkBlocked()][Movestatus:\" + moveStatus() + \"]\" ); // TinMan: *debug*\n"
           "\t}\t*/\n"
           "\t\n"
           "\t// TinMan: *cheaphack* see if we're not moving by comparing against previous. !! Interferes with new routing (stopping for elev etc)\n"
           "\tif ( moveStatus() == MOVE_STATUS_MOVING ) {\n"
           "\t\t//sys.println( \"[\" + sys.getTime() + \"][checkBlocked()][Movestatus:\" + moveStatus() + \"]\" ); // TinMan: *debug*\n"
           "\t\tvector currentPosition;\n"
           "\t\t\n"
           "\t\tcurrentPosition = body.getOrigin();\n"
           "\t\t\n"
           "\t\tif ( lastPositionTime < sys.getTime() ) {\n"
           "\t\t\tlastPositionTime = sys.getTime() + 0.3;\n"
           "\t\t\t// TinMan: Compare current position with previous to get movement vector.\n"
           "\t\t\tdelta = currentPosition  - lastPosition;\n"
           "\t\t\tdelta_z = 0;\n"
           "\t\t\tdist = sys.vecLength( delta );\n"
           "\t\t\t\n"
           "\t\t\tlastPosition = currentPosition;\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: Haven't moved enough?\n"
           "\t\t\tif ( dist <= 2 ) {\n"
           "\t\t\t\t//sys.println( \"[\" + sys.getTime() + \"][checkBlocked][blocked by something]\" ); // TinMan: *debug*\n"
           "\t\t\t\tsaveMove();\n"
           "\t\t\t\tsetMoveWander();\n"
           "\t\t\t\tendTime = RandomDelay( 0.6, 0.7 );\n"
           "\t\t\t\twhile( sys.getTime() < endTime || dist > 16 ) {\n"
           "\t\t\t\t\tdelta = currentPosition  - lastPosition;\n"
           "\t\t\t\t\tdelta_z = 0;\n"
           "\t\t\t\t\tdist = sys.vecLength( delta ); // TinMan: set dist wandered\t\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t\t// TinMan: Do actual movement\n"
           "\t\t\t\t\tmovePosition = moveAction();\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t\t// TinMan: Lookee where we damn be going.\n"
           "\t\t\t\t\t//movePosition_z = movePosition_z + viewHeight;\n"
           "\t\t\t\t\t//setAimPosition( movePosition );\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t\t// TinMan: Check for enemies\n"
           "\t\t\t\t\tif ( findEnemies( true ) ) {\n"
           "\t\t\t\t\t\tbreak;\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t\tenemy = heardSound( false );\n"
           "\t\t\t\t\tif ( canSeeEntity( enemy, false ) ) {\n"
           "\t\t\t\t\t\tbreak;\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t\twaitFrame();\n"
           "\t\t\t\t}\n"
           "\t\t\t\trestoreMove();\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t}\n"
           "\t\n"
           "\t/*\n"
           "\t// TinMan: *todo* Hmm doesn't seem to really trigger much at all\n"
           "\tif ( AI_BLOCKED ) {\n"
           "\t\tsys.println( \"[\" + sys.getTime() + \"][checkBlocked()][AI_BLOCKED]\" ); // TinMan: *debug*\n"
           "\t\tsaveMove();\n"
           "\t\tsetMoveWander();\n"
           "\t\tendTime = sys.getTime() + 0.8;\n"
           "\t\twhile( sys.getTime() < endTime ) {\n"
           "\t\t\t// TinMan: Lookee where we damn be going.\n"
           "\t\t\tmovePosition = getMovePosition(); // TinMan: expensive\n"
           "\t\t\tmovePosition_z = movePosition_z + viewHeight;\n"
           "\t\t\tsetAimPosition( movePosition );\n"
           "\t\t\t\t\t\n"
           "\t\t\t// TinMan: Do actual movement\n"
           "\t\t\tmoveForward();\n"
           "\t\t\t\t\n"
           "\t\t\t// TinMan: Check for enemies\n"
           "\t\t\tif ( findEnemies( true ) ) {\n"
           "\t\t\t\tbreak;\n"
           "\t\t\t}\n"
           "\t\t\tenemy = heardSound( false );\n"
           "\t\t\tif ( canSeeEntity( enemy, false ) ) {\n"
           "\t\t\t\tbreak;\n"
           "\t\t\t}\n"
           "\t\t\twaitFrame();\n"
           "\t\t}\n"
           "\t\trestoreMove();\n"
           "\t} else*/ if ( moveStatus() == MOVE_STATUS_BLOCKED_BY_MONSTER ) {\n"
           "\t\t//sys.println( \"[\" + sys.getTime() + \"][checkblocked][blocked by monster]\" ); // TinMan: *debug*\n"
           "\t\tobstacle = getObstacle();\n"
           "\t\tobstacle_pos = obstacle.getOrigin(); // TinMan: This wil come in handy later.\n"
           "\t\n"
           "\t\tsaveMove();\n"
           "\t\tsetMoveWander();\n"
           "\t\tendTime = sys.getTime() + 0.8;\n"
           "\t\twhile( sys.getTime() < endTime ) {\n"
           "\t\t\t// TinMan: Do actual movement\n"
           "\t\t\tmovePosition = moveAction();\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: Lookee where we damn be going.\n"
           "\t\t\t//movePosition = getMovePosition(); // TinMan: expensive\n"
           "\t\t\tif ( AI_ONGROUND && movePosition != body.getOrigin() ) {\n"
           "\t\t\t\taimDir = movePosition - body.getOrigin();\n"
           "\t\t\t\tsetAimDirection( aimDir );\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: Compare current position with previous to get movement vector.\n"
           "\t\t\tdelta = obstacle_pos - obstacle.getOrigin();\n"
           "\t\t\tdelta_z = 0;\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: Check for enemies\n"
           "\t\t\tif ( findEnemies( true ) ) {\n"
           "\t\t\t\tbreak;\n"
           "\t\t\t}\n"
           "\t\t\tenemy = heardSound( false );\n"
           "\t\t\tif ( canSeeEntity( enemy, false ) ) {\n"
           "\t\t\t\tbreak;\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: Yay it moved enough.\n"
           "\t\t\tif ( sys.vecLength( delta ) >= 4 ) {\n"
           "\t\t\t\t//sys.println( \"[\" + sys.getTime() + \"][\" + me + \"][checkBlocked][obstacle moved]\" ); // TinMan: *debug*\n"
           "\t\t\t\tbreak;\n"
           "\t\t\t}\n"
           "\t\t\twaitFrame();\n"
           "\t\t}\n"
           "\t\trestoreMove();\n"
           "\t}\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::checkShot\n"
           "TinMan: Find what we would hit if we fired. Bounds shot from eyes along viewangles. Itchy itch trigger finger.\n"
           "When bounds are used to decide whether to fire gives nice simulation of player pulling trigger when enemy near crosshair.\n"
           "*todo* axis align bounding box if possible.\n"
           "*todo* false if trace dist < min weapon range? checkaimedshot would intefere. also would have to make sure bot weaponswitches to something that can.\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot::checkShot( boolean simple, boolean shootEnemy ) {\n"
           "\tvector\tpos, ang, dir, tracePosition;\n"
           "\tfloat maxRange, frac, traceDistance;\n"
           "\tentity\ttraceEntity;\n"
           "\tfloat gameType;\n"
           "\tfloat boundSize, halfBound;\n"
           "\tvector boundMins, boundMaxs;\n"
           "\n"
           "\tmaxRange = 2048; // TinMan: Max a bounds trace can do is 4096.\n"
           "\t\n"
           "\t/*\n"
           "\tboundSize = 8;\n"
           "\thalfBound = boundSize / 2;\n"
           "\t\n"
           "\tboundMins_x = -halfBound;\n"
           "\tboundMins_y = -halfBound;\n"
           "\tboundMins_z = -halfBound;\n"
           "\tboundMaxs_x = halfBound;\n"
           "\tboundMaxs_y = halfBound;\n"
           "\tboundMaxs_z = halfBound;\n"
           "\t*/\n"
           "\t\n"
           "\t\n"
           "\n"
           "\tpos = getViewPosition();\n"
           "\tang = body.getViewAngles();\n"
           "\tdir = sys.angToForward( ang ); // TinMan: Convert angles (pitch yaw roll), to forward vector (x y z).\n"
           "\n"
           "\tif ( simple ) {\n"
           "\t\tfrac = sys.tracePoint( pos, pos + ( dir * maxRange ), MASK_SOLID|CONTENTS_BODY, self );  //  CONTENTS_OPAQUE | MASK_SHOT_RENDERMODEL\n"
           "\t} else { // TinMan: Bounds trace\n"
           "\t\tfrac = sys.trace( pos, pos + ( dir * maxRange ), '-4 -4 -4', '4 4 4', MASK_SOLID|CONTENTS_BODY, self );\n"
           "\t}\n"
           "\ttraceEntity = sys.getTraceEntity(); // TinMan: Get what was hit by trace\n"
           "\n"
           "\ttraceDistance = frac * maxRange; // TinMan: Convert the fraction of trace completed to game units\n"
           "\t// TinMan: Hmm, do straight maths, or call function ( which returns value allready calculated when trace func was called. )\n"
           "\t//tracePosition = pos + ( dir * traceDistance ); // TinMan: Get where trace hit\n"
           "\ttracePosition = sys.getTraceEndPos(); // TinMan: Get where trace hit\n"
           "/*\n"
           "\tfloat debugTime = 0.01;\n"
           "\t//sys.debugLine( '0 1 1', pos, pos + ( dir * maxRange ), debugTime ); // TinMan: *debug* full trace\n"
           "\tsys.debugBounds( '1 0 0', pos + '-1 -1 -1', pos + '1 1 1' , debugTime ); // TinMan: *debug* show bound at eyes\n"
           "\n"
           "\tsys.debugLine( '0 1 0', pos, tracePosition,\tdebugTime ); // TinMan: *debug* trace\n"
           "\n"
           "\tsys.debugBounds( '1 1 0', tracePosition + '-4 -4 -4', tracePosition + '4 4 4' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\t//sys.debugBounds( '0 0.5 1', traceEntity.getOrigin() + traceEntity.getMins(), traceEntity.getOrigin() + traceEntity.getMaxs(), debugTime ); // TinMan: *debug* hilite hit ent\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][Trace Hit: \" + traceEntity.getName() + \"]\" ); // TinMan: *debug*\n"
           "\n"
           "\tsys.debugBounds( '1 0 1', getAimPosition() + '-4 -4 -4', getAimPosition() + '4 4 4', debugTime ); // TinMan: *debug* show bound at aimPos\n"
           "\t//sys.debugBounds( '1 1 0', body.getOrigin() + getMins() + '-2 -2 -2', body.getOrigin() + getMaxs() + '2 2 2' , debugTime ); // TinMan: *debug* aimPos reset\n"
           "\n"
           "\t//sys.debugLine( '0 1 0', body.getOrigin(), body.getOrigin() + getLinearVelocity(),\tdebugTime ); // TinMan: *debug* trace velocity\n"
           "*/\n"
           "\n"
           "\t// TinMan: Oh my god I think we hit something. Charles, I think we hit something!\n"
           "\tif ( traceEntity ) {\n"
           "\t\tstring type = getClassType( traceEntity );\n"
           "\t\tif ( shootEnemy && ( type == \"idPlayer\" || type == \"idAI\" ) ) { // TinMan: *todo* shotenemy just a work around at the moment due to using this func to shoot windows in non combat states\n"
           "\t\t\t// TinMan: Friendly fire check. I swear his orange hunting jacket look just like a prize buck officer! *todo* IsGametypeTeamBased?\n"
           "\t\t\tgameType = getGameType();\n"
           "\t\t\tif ( gameType == GAME_SP || gameType == GAME_TDM || gameType == GAME_CTF ) {\n"
           "\t\t\t\tif ( getTeam( traceEntity ) != getTeam( body ) ) {\n"
           "\t\t\t\t\treturn true;\n"
           "\t\t\t\t}\n"
           "\t\t\t} else {\n"
           "\t\t\t\treturn true;\n"
           "\t\t\t}\n"
           "\t\t} else if ( traceDistance < 128 && type == \"idBrittleFracture\"  ) { // TinMan: Breakable glass *todo* this will hurt if the bot got rockets.\n"
           "\t\t\treturn true;\n"
           "\t\t} /* else if ( traceDistance > 128 && type == \"idExplodingBarrel\"  ) { // TinMan: *todo* a wider cansee check for barrels to shoot when enemy is near.\n"
           "\t\t\treturn true;\n"
           "\t\t} */\n"
           "\t}\n"
           "\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::checkAimedShot\n"
           "TinMan: See if bot is aimed at given position and if a shot would make it.\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot::checkAimedShot( vector aimDir, float range ) {\n"
           "\tvector viewDir, aimDir, tracePosition, eyePosition;\n"
           "\tfloat ang;\n"
           "\tfloat frac, maxRange;\n"
           "\n"
           "\tmaxRange = 2048; // TinMan: Max a bounds trace can do is 4096.\n"
           "\n"
           "\teyePosition = getViewPosition();\n"
           "\tviewDir = sys.angToForward( body.getViewAngles() );\t// TinMan: Vector of where bot is looking\n"
           "\t//aimDir = aimPosition - eyePosition;\t\t\t// TinMan: Vector of where aimPosition is\n"
           "\n"
           "\tang = sys.DotProduct( sys.vecNormalize( viewDir ), sys.vecNormalize( aimDir ) );\n"
           "\tang = acos( ang ); // TinMan: Angle between viewDir and aimDir\n"
           "\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][viewDir<>aimDir Ang:\" + ang + \"]\" ); // TinMan: *debug*\n"
           "\tif ( ang < 0.1 ) { // TinMan: Minimal angle between the two so must be looking at aimed spot. Frankenstein says: I like nice mice.\n"
           "\n"
           "\t\t// TinMan: Figure out if bots shot will make it to aimPosition\n"
           "\t\tfrac = sys.tracePoint( eyePosition, eyePosition + aimDir * maxRange, MASK_SOLID|CONTENTS_BODY, self );  //  CONTENTS_OPAQUE | MASK_SHOT_RENDERMODEL\n"
           "\n"
           "\t\t//traceDistance = frac * maxRange; // TinMan: Convert the fraction of trace completed to game units\n"
           "\t\ttracePosition = sys.getTraceEndPos(); // TinMan: Get where trace hit\n"
           "\n"
           "\t\t/*\n"
           "\t\tfloat debugTime = 0.01;\n"
           "\t\tsys.debugBounds( '1 0 0', pos + '-1 -1 -1', pos + '1 1 1' , debugTime ); // TinMan: *debug* show bound at eyes\n"
           "\n"
           "\t\tsys.debugLine( '0 1 0', pos, tracePosition,\tdebugTime ); // TinMan: *debug* trace\n"
           "\t\tsys.debugBounds( '1 1 0', tracePosition + '-2 -2 -2', tracePosition + '2 2 2' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\n"
           "\t\tsys.debugLine( '1 0 0', pos, pos + aimDir,\tdebugTime ); // TinMan: *debug* trace\n"
           "\t\tsys.debugBounds( '1 0 0', aimPosition + '-2 -2 -2', aimPosition + '2 2 2' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\t\t*/\n"
           "\n"
           "\t\t// TinMan: Something in the way of shot.\n"
           "\t\tif ( body.distanceToPoint( tracePosition ) + 32 < range ) { // TinMan: traceDistance should have buffer since it will be shorter than aimPosition due to the trace hitting the model, of course my buffer is rough and inaccurate.\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][checkAimedShot][aimPosition blocked][tracePosition: \" + distanceToPoint( tracePosition ) + \"][aimPosition: \" + distanceToPoint( aimPosition ) + \"]\" ); // TinMan: *debug*\n"
           "\t\t\treturn false;\n"
           "\t\t} else {\n"
           "\t\t\treturn true;\n"
           "\t\t}\n"
           "\t}\n"
           "\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::chooseWeapon\n"
           "TinMan: Chose weapon based on range *todo* fix/rethink, and use.\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot::chooseWeapon( float range ) {\n"
           "\tfloat w;\n"
           "\tstring weap, bestWeapon;\n"
           "\tfloat maxWeapons, weaponPriority, bestPriority;\n"
           "\t\n"
           "\tvector weapRange;\n"
           "\n"
           "\t// TinMan: update currentweapon\t\n"
           "\tcurrentWeapon = body.getCurrentWeapon();\n"
           "\t\n"
           "\tbestPriority = 0;\n"
           "\tbestWeapon = currentWeapon;\n"
           "\tfor ( w = 0; w < MAX_WEAPONS; w++ ) {\n"
           "\t\tweap = body.getKey( \"def_weapon\" + w );\n"
           "\t\tif ( !weap ) {\n"
           "\t\t\tbreak;\n"
           "\t\t}\n"
           "\n"
           "\t\t/*\n"
           "\t\tif ( sys.strLeft( weap, 17 ) == \"weapon_bloodstone\" ) { // TinMan: weapon causes trouble with ctf when !_d3xp\n"
           "\t\t\tcontinue;\n"
           "\t\t}\n"
           "\t\t*/\n"
           "\t\t\t\t\n"
           "\t\t//sys.println( \"[\" + sys.getTime() + \"][chooseWeapon][weapon[\" + w + \"]: \" + weap + \"]\" ); // TinMan: *debug*\n"
           "\t\tif ( hasWeapon( weap ) && hasAmmoForWeapon( weap ) ) { // TinMan: *todo* at least a clip?\n"
           "\t\t\t//sys.println( \"[\" + sys.getTime() + \"][chooseWeapon][hasWeapon: \" + weap + \"]\" ); // TinMan: *debug*\n"
           "\t\t\tweaponPriority = getFloatKey( \"priority_\" + weap ); // TinMan: Grab priority from def *todo* ismultiplayer _mp\n"
           "\t\t\t//sys.println( \"[\" + sys.getTime() + \"][chooseWeapon][weapon: \" + weap + \"][priority: \" + weaponPriority + \"]\" ); // TinMan: *debug*\t\t\t\n"
           "\t\t\t\n"
           "\t\t\tif ( weaponPriority > bestPriority ) {\n"
           "\t\t\t\tbestPriority = weaponPriority;\n"
           "\t\t\t\tbestWeapon = weap;\t\n"
           "\t\t\t\t//sys.println( \"[\" + sys.getTime() + \"][chooseWeapon][bestWeapon: \" + bestWeapon + \"]\" ); // TinMan: *debug*\t\t\t\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\t//weapRange = getVectorKey( \"range_\" + weap ); // TinMan: Grab ranges from def\n"
           "\t\t\t/*if ( range > weapRange_y && range < weapRange_z ) { // TinMan: Weapon out of min max ranges of current enemy dist.\n"
           "\t\t\t\tbreak; \n"
           "\t\t\t} else { // TinMan: weapon not good for range, chose next weapon\n"
           "\t\t\t\tcontinue;\n"
           "\t\t\t}*/\n"
           "\t\t}\t\n"
           "\t}\n"
           "\t\n"
           "\t//sys.println( \"[\" + sys.getTime() + \"][chooseWeapon][bestWeapon: \" + bestWeapon + \"]\" ); // TinMan: *debug*\n"
           "\t\n"
           "\tif ( bestWeapon != currentWeapon ) {\n"
           "\t\tbody.selectWeapon( bestWeapon );\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::predictTargetPosition\n"
           "Frankenstein says: I got my eyes from the corpse of the mikeBot.\n"
           "TinMan: Lead target\n"
           "*todo* sort out loop, it's a mess\n"
           "=====================\n"
           "*/\n"
           "vector bot_sabot::predictTargetPosition( vector targetPosition, vector myPosition, vector targetVelocity, float projectileSpeed ) {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][predictTargetPosition]\" ); // TinMan *debug*\n"
           "\tfloat travelTime = 0.0; // time for projectile to reach target\n"
           "\tfloat timeEstimate; \t\t// estimated time for projectile arrival\n"
           "\tfloat predictError; \t\t// error in target location\n"
           "\tfloat loopCount;\n"
           "\tvector targetLocation = targetPosition; // = targetVelocity;\n"
           "\n"
           "\tfloat debugTime = 0.01;\n"
           "\n"
           "\tfloat predictLoopMaximum = 10;\n"
           "\tfloat predictErrorTollerance = 0.1;\n"
           "\n"
           "\tpredictError = 100;\n"
           "\t\n"
           "\t// TinMan: *todo* maybe a bug here, gettin div by zeros, I think this is the only place I'm doing division. That would mean projectileSpeed is 0. Sort it out.\n"
           "\tif ( projectileSpeed == 0 ) {\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][predictTargetPosition][!!projectileSpeed == 0]\" ); // TinMan *debug*\n"
           "\t\tprojectileSpeed = 1;\n"
           "\t}\n"
           "\n"
           "\tfor ( loopCount = 0; loopCount < predictLoopMaximum; loopCount++ ) {\n"
           "\t\ttargetLocation = travelTime * targetVelocity + targetLocation; // TinMan: This will shift each loop as traveTime is changed\n"
           "\t\t//sys.debugBounds( '1 0.5 0.5', targetLocation + '-2 -2 -2', targetLocation + '2 2 2' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][predictTargetPosition][\" + loopCount + \"]\" ); // TinMan *debug*\n"
           "\t\ttimeEstimate = sys.vecLength( myPosition - targetLocation ) / projectileSpeed; // TinMan: Estimate of how long it will take projectile to reach targetLocation\n"
           "\t\tpredictError = timeEstimate - travelTime;\n"
           "\t\ttravelTime = timeEstimate;\n"
           "\t\tif ( predictError < predictErrorTollerance ) {\n"
           "\t\t\tbreak;\n"
           "\t\t}\n"
           "\t}\n"
           "\n"
           "\t//sys.debugLine( '0 1 1', pos, pos + ( dir * maxRange ), debugTime ); // TinMan: *debug* full trace\n"
           "\t/* sys.debugLine( '1 0 0', myPosition, targetLocation,\tdebugTime ); // TinMan: *debug* trace from self to predicted position\n"
           "\tsys.debugLine( '0 1 0', targetPosition, targetPosition + targetVelocity,\tdebugTime ); // TinMan: *debug* trace from  target along predicted direction\n"
           "\tsys.debugLine( '1 0 1', myPosition, targetPosition,\tdebugTime );\n"
           "\tsys.debugBounds( '0.5 1 0.2', targetPosition + '-1 -1 -1', targetPosition + '1 1 1' , debugTime );\n"
           "\tsys.debugBounds( '1 0.5 0.5', targetLocation + '-2 -2 -2', targetLocation + '2 2 2' , debugTime );\n"
           "\t*/\n"
           "\n"
           "\treturn targetLocation;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::addAimVariation\n"
           "TinMan: Add variation to aiming so it's not so damn good. I call this the drunkeness factor.\n"
           "*todo* just a cheaphack needs rethinking.\n"
           "=====================\n"
           "*/\n"
           "vector bot_sabot::addAimVariation( vector aimPosition ) {\n"
           "\tfloat t, attackAccuracy;\n"
           "\tvector aimDir, viewAng;\n"
           "\t\t\t\n"
           "\tattackAccuracy = getFloatKey( \"aim_accuracy\" );\n"
           "\t\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][addAimVariation][attackAccuracy: \" + attackAccuracy + \"]\" ); // TinMan *debug*\n"
           "\t\n"
           "\taimDir = aimPosition - getViewPosition();\t// TinMan: Vector towards aimPosition\n"
           "\t\n"
           "\tif ( attackAccuracy == 0 ) { // TinMan: No aim variation. uberbot.\n"
           "\t\treturn aimDir;\n"
           "\t}\n"
           "\n"
           "\tt = sys.getTime() * 50;\n"
           "\tviewAng = sys.VecToAngles( aimDir );\n"
           "\tviewAng_x += sys.sin( t * 5.1 ) * attackAccuracy;\n"
           "\tviewAng_y\t+= sys.sin( t * 6.7 ) * attackAccuracy;\n"
           "\n"
           "\tviewAng = sys.angToForward( viewAng );\n"
           "\t\n"
           "\t// TinMan: Convert angles back to position\n"
           "\t//viewAng = eyePosition + viewAng * sys.vecLength( aimDir );\n"
           "\n"
           "\t/*\n"
           "\t// TinMan: *debug*\n"
           "\tfloat maxRange = 2048; // TinMan: Max a bounds trace can do is 4096.\n"
           "\tvector viewDir = sys.angToForward( body.getViewAngles() ); // TinMan: Convert angles (pitch yaw roll), to forward vector (x y z).\n"
           "\n"
           "\tfloat frac = sys.tracePoint( eyePosition, eyePosition + viewDir * maxRange, MASK_SOLID|CONTENTS_BODY, self );  //  CONTENTS_OPAQUE | MASK_SHOT_RENDERMODEL\n"
           "\n"
           "\tvector tracePosition = sys.getTraceEndPos(); // TinMan: Get where trace hit\n"
           "\n"
           "\tfloat debugTime = 0.01;\n"
           "\tsys.debugBounds( '1 0 0',  eyePosition + '-1 -1 -1',  eyePosition + '1 1 1' , debugTime ); // TinMan: *debug* show bound at eyes\n"
           "\tsys.debugLine( '0 1 0',  eyePosition, tracePosition,\tdebugTime ); // TinMan: *debug* trace\n"
           "\tsys.debugBounds( '1 1 0', tracePosition + '-2 -2 -2', tracePosition + '2 2 2' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\n"
           "\tsys.debugBounds( '1 0 0', aimPosition + '-2 -2 -2', aimPosition + '2 2 2' , debugTime ); // TinMan: *debug*\n"
           "\t*/\n"
           "\t\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][addAimVariation][before: \" + aimDir + \"][after: \" + viewAng + \"]\" ); // TinMan *debug*\n"
           "\n"
           "\treturn viewAng;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::getAimTarget\n"
           "TinMan: Find out where to aim.\n"
           "getAIAimTargets automatically uses lastviablenemypos\n"
           "=====================\n"
           "*/\n"
           "vector bot_sabot::getAimTarget( entity target ) {\n"
           "\tvector aimPosition;\n"
           "\tfloat predictType;\n"
           "\n"
           "\tpredictType = getIntKey( \"predict_\" + currentWeapon );\n"
           "\tif ( predictType == 1 ) { // TinMan: Explosive|shoot the feet - I said dance boy, dance!\n"
           "\t\tvector targetOrigin = target.getOrigin();\n"
           "\t\tvector origin = body.getOrigin();\n"
           "\t\tif ( targetOrigin_z <= origin_z && body.distanceTo( target ) > 96 ) { // TinMan: Only attack his shoes if he's lower\n"
           "\t\t//if ( canSeePosition( target.getOrigin(), false ) ) {\n"
           "\t\t\taimPosition = target.getOrigin();\n"
           "\t\t\taimPosition_z += 8; // TinMan: More chance of checkshot hitting enemy.\n"
           "\t\t} else {\n"
           "\t\t\taimPosition = getAIAimTargets( target, false ); // TinMan: false chest, true head. Excuse me, can you point to where you want to be shot?\n"
           "\t\t}\n"
           "\t} else { // TinMan: Default|0|chest\n"
           "\t\taimPosition = getAIAimTargets( target, false );\n"
           "\t}\n"
           "\n"
           "\treturn aimPosition;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::getItemPriority\n"
           "TinMan: Find out what the priority of this entity is.\n"
           "=====================\n"
           "*/\n"
           "float bot_sabot::getItemPriority( entity item ) {\n"
           "\tfloat priority;\n"
           "\tstring itemName, prefix;\n"
           "\tfloat\titemType;\n"
           "\tfloat len;\n"
           "\tfloat health, maxHealth, armor, maxArmor;\n"
           "\n"
           "\t// TinMan: Grab some stats\n"
           "\thealth = getActorHealth( body );\n"
           "\tarmor = getArmor( body );\n"
           "\tmaxHealth = body.getFloatKey( \"maxhealth\" );\n"
           "\tmaxArmor = body.getFloatKey( \"maxarmor\" );\n"
           "\n"
           "\titemName = getClassName( item ); // TinMan: Get the name of the item\n"
           "\t// TinMan: Strip mp suffix\n"
           "\tlen = sys.strLength( itemName ) - 3;\n"
           "\tif ( sys.strSkip( itemName, len ) == \"_mp\" ) {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][getItemPriority][itemName: \" + sys.strLeft( itemName, len ) + \"]\" ); // TinMan *debug*\n"
           "\t\titemName = sys.strLeft( itemName, len );\n"
           "\t}\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][getItemPriority][itemName: \" + itemName + \"]\" ); // TinMan *debug*\n"
           "\t\n"
           "\tif ( getClassType( item ) == \"idMoveableItem\" ) {\n"
           "\t\titemName = sys.strSkip( getClassName( item ), sys.strLength( \"moveable_item_\" ) ); // TinMan: Nasty\n"
           "\t\titemName = \"weapon_\" + itemName; // TinMan: Also cheap *todo* better, this obviously doesn't handle other movables, why did id soft name them moveable_item_machinegun etc instead of moveable_weapon_machinegun. Waaaaaaa!\n"
           "\t}\n"
           "\t\n"
           "\t// TinMan: Grab priority from def\n"
           "\tpriority = getFloatKey( \"priority_\" + itemName ); \n"
           "\tif ( !priority ) {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][getItemPriority][No Priority for: \" + itemName + \"]\" ); // TinMan *debug*\n"
           "\t\treturn 0;\n"
           "\t}\n"
           "\t\n"
           "\t// TinMan: Add a bit of variety *todo* at the moment stuffs up lookforgoal\n"
           "\t//priority += sys.random( 15 );\n"
           "\t\n"
           "\t// TinMan: Lets us diferentiate between items\n"
           "\tprefix = sys.strLeft( itemName, 4 );\n"
           "\tif ( prefix == \"item\" ) {\n"
           "\t\titemType = SABOT_ITEMTYPE_ITEM;\n"
           "\t} else if ( prefix == \"weap\" ) {\n"
           "\t\titemType = SABOT_ITEMTYPE_WEAPON;\n"
           "\t} else if ( prefix == \"ammo\" ) {\n"
           "\t\titemType = SABOT_ITEMTYPE_AMMO;\n"
           "\t} else if ( prefix == \"powe\" ) {\n"
           "\t\titemType = SABOT_ITEMTYPE_POWERUP;\n"
           "\t}\n"
           "\t\n"
           "\t// TinMan: Bit less attactive if we allready have it. \n"
           "\t// *todo* still to test, -5 if have -10 if have and plenty ammo for it?\n"
           "\tif ( itemType == SABOT_ITEMTYPE_WEAPON ) {\n"
           "\t\tif ( hasWeapon( itemName ) ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][getItemPriority][bot has: \" + itemName + \"]\" ); // TinMan *debug*\n"
           "\t\t\tpriority -= 10;\n"
           "\t\t}\n"
           "\t} else if ( itemType == SABOT_ITEMTYPE_AMMO ) {\n"
           "\t\tlen = sys.strLength( itemName ) - 6; // TinMan: Strip off suffix ( _small, _large = 6 chars )\n"
           "\t\titemName = sys.strLeft( itemName, len );\n"
           "\t\tif ( itemName == \"ammo_grenade\" ) { // TinMan: pickups are ammo_grenade, while actuall ammo_type is ammo_grenades. Curses.\n"
           "\t\t\titemName = \"ammo_grenades\";\n"
           "\t\t}\n"
           "\t\tif ( hasAmmo( itemName ) >= body.getFloatKey( \"max_\" + itemName ) ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][getItemPriority][bot has full: \" + itemName + \"]\" ); // TinMan *debug*\n"
           "\t\t\tpriority = 0;\n"
           "\t\t}\n"
           "\t}\n"
           "\t\t\n"
           "\tif ( itemName == \"item_medkit\" ) {\n"
           "\t\tif ( health < maxHealth ) {\n"
           "\t\t\tif ( health < 40 ) {\n"
           "\t\t\t\tpriority += 50;\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tpriority = 0;\n"
           "\t\t}\n"
           "\t} else if ( itemName == \"item_medkit_small\" ) {\n"
           "\t\tif ( health < maxHealth ) {\n"
           "\t\t\tif ( health < 40 ) {\n"
           "\t\t\t\tpriority += 50;\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tpriority = 0;\n"
           "\t\t}\n"
           "\t} else if ( itemName ==  \"item_armor_security\" ) {\n"
           "\t\tif ( armor < maxArmor ) {\n"
           "\t\t\tif ( armor < 50 ) {\n"
           "\t\t\t\tpriority += 20;\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t priority = 0;\n"
           "\t\t}\n"
           "\t} else if ( itemName == \"item_armor_shard\" ) {\n"
           "\t\tif ( armor < maxArmor ) {\n"
           "\t\t\tif ( armor < 50 ) {\n"
           "\t\t\t\tpriority += 10;\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tpriority = 0;\n"
           "\t\t}\n"
           "\t}\n"
           "\t\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][getItemPriority][\" + itemName + \" Priority: \" + priority + \"]\" ); // TinMan *debug*\n"
           "\treturn priority;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::getPlayerPriority\n"
           "TinMan: How badass is this player? Also used to see how much of a badass this bot is.\n"
           "Remember: Unlike item where higher priority is better, here lower is better.\n"
           "*todo* weapon priority\n"
           "*todo* add powerups, + 200, 250, 300, uberbadness.\n"
           "*todo* + distance to enemy? ( shorter higher ) + last time seen enemy? ( shorter higher ), if so, don't put in here but where this func is called.\n"
           "=====================\n"
           "*/\n"
           "float bot_sabot::getPlayerPriority( entity badass ) {\n"
           "\tfloat priority, weaponPriority;\n"
           "\tstring playerWeapon;\n"
           "\t\t\n"
           "\tplayerWeapon = badass.getCurrentWeapon();\n"
           "\tweaponPriority = getFloatKey( \"priority_\" + playerWeapon ); // TinMan: Grab priority from def\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][getPlayerPriority][weapon: \" + playerWeapon + \"][\" + weaponPriority + \"]\" ); // TinMan *debug*\n"
           "\n"
           "\tpriority = ( getActorHealth( badass ) / 2 ) + getArmor( badass ) + weaponPriority;\n"
           "\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][getPlayerPriority][\" + badass.getName() + \" Priority: \" + priority + \"]\" ); // TinMan *debug*\n"
           "\tsys.println( \"[\" + int( sys.getTime() ) + \"][getPlayerPriority][\" + badass.getName() + \" HP: \" + getActorHealth( badass ) + \" ARM: \" + getArmor( badass ) + \" Weap: \" + weaponPriority + \" Priority: \" + priority + \"]\" ); // TinMan *debug*\n"
           "\treturn priority;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::getProjectileSpeed\n"
           "TinMan: How speedy are the shooty shooty kill kills?\n"
           "=====================\n"
           "*/\n"
           "float bot_sabot::getProjectileSpeed( string weaponName ) {\n"
           "\tfloat projectileSpeed = 0;\n"
           "\n"
           "\tif ( sys.isMultiplayer() ) {\n"
           "\t\tprojectileSpeed = getIntKey( \"projectile_\" + weaponName +  \"_mp\" );\n"
           "\t}\n"
           "\tif ( !sys.isMultiplayer() || !projectileSpeed ) { // TinMan: If mp projspeed isn't defined fall back to regular projspeed\n"
           "\t\tprojectileSpeed = getIntKey( \"projectile_\" + weaponName );\n"
           "\t}\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][predictShot][\" + weaponName + \"][\" + projectileSpeed + \"]\" ); // TinMan *debug*\n"
           "\tif ( !projectileSpeed ) {\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][getProjectileSpeed][!projectilespeed]\" ); // TinMan *debug*\t\n"
           "\t}\n"
           "\n"
           "\treturn projectileSpeed;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::chooseGoal\n"
           "TinMan: Choose long range goal. And I don't mean a five year plan.\n"
           "=====================\n"
           "*/\n"
           "entity bot_sabot::chooseGoal( entity ignoreGoal ) {\n"
           "\tfloat i, numListedEntities;\n"
           "\tfloat itemPriority, bestPriority;\n"
           "\tfloat dist, bestDist;\n"
           "\tfloat radius;\n"
           "\tentity item, bestGoal;\n"
           "\t\n"
           "\tclearGoal();\n"
           "\t\n"
           "\t// TinMan: *CTF* goals. All your base are belong to us.\t\n"
           "\tif ( gameType == GAME_CTF ) {\n"
           "\t\tif ( getFlagCarrier( team ) == body ) { // TinMan: w00t we gots teh falg!\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][chooseGoal][!have flag!]\" ); // TinMan *debug*\n"
           "\t\t\tbestGoal = ourCap;\n"
           "\t\t} else if ( role == SABOT_ROLE_OFFENCE ) {\n"
           "\t\t\tbestGoal = theirCap;\n"
           "\t\t} else if ( role == SABOT_ROLE_DEFENCE ) {\n"
           "\t\t\tbestGoal = ourCap;\n"
           "\t\t}\n"
           "\t\t\t\n"
           "\t\t// TinMan: Check if goal can be reached *todo* think about how you are going to handle unreachable goal. *todo* hmm it's ok if enemy is unreachable, he might not be later, or your still might be able to shoot him\n"
           "\t\tif ( bestGoal ) {\n"
           "\t\t\tgoalType = SABOT_GOAL_HOLD;\n"
           "\t\t\tmoveType = SABOT_MOVETYPE_POSITION;\n"
           "\t\t\tgoalPosition = bestGoal.getOrigin();\n"
           "\t\t\tgoalPriority = getFloatKey( \"priority_goal_team\" );\n"
           "\t\t\t\n"
           "\t\t\tif ( !canReachPosition( goalPosition ) ) {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][chooseGoal][can't reach goal position]\" ); // TinMan *debug*\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][chooseGoal][GoalPosition: \" + goalPosition + \"]\" ); // TinMan *debug*\n"
           "\t\t\t\tclearGoal();\n"
           "\t\t\t\tbestGoal = $null_entity;\n"
           "\t\t\t}\n"
           "\t\t} else { // TinMan: Can't CTF so roam\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][chooseGoal][!!No CTF Goal!!]\" ); // TinMan *debug*\n"
           "\t\t\trole = roleDefault;\n"
           "\t\t}\n"
           "\t}\n"
           "\n"
           "\t// TinMan: Find an item to hunt. Want l00t!\n"
           "\tif ( role == SABOT_ROLE_ROAM ) {\n"
           "\t\tnumListedEntities = findItems();\n"
           "\t\t// sys.println( \"[\" + int( sys.getTime() ) + \"][chooseGoal][numListedEntities: \" + numListedEntities + \"]\" ); // TinMan *debug*\n"
           "\t\tfor ( i = 0; i < numListedEntities; i++ ) {\n"
           "\t\t\titem = getEntityList( i );\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][chooseGoal][listedEntity[\" + i + \"] : \" + item.getName() +  \"]\" ); // TinMan *debug* \" : \" + getClassName( item ) +\n"
           "\t\t\tif ( item == ignoreGoal || item.isHidden() ) {\n"
           "\t\t\t\tcontinue;\n"
           "\t\t\t}\n"
           "\t\t\titemPriority = getItemPriority( item );\n"
           "\t\t\tif ( !itemPriority ) {\n"
           "\t\t\t\tcontinue;\n"
           "\t\t\t}\n"
           "\t\t\tif ( itemPriority > bestPriority ) {\n"
           "\t\t\t\tif ( canReachEntity( item ) ) {\n"
           "\t\t\t\t\tbestPriority = itemPriority;\n"
           "\t\t\t\t\tbestGoal = item;\n"
           "\t\t\t\t}\n"
           "\t\t\t} else if ( itemPriority == bestPriority ) { // TinMan: If item has same priority get closest, of course staright distance check is cheap and may not be the closest item due to travel time.\n"
           "\t\t\t\tdist = body.distanceTo( item );\n"
           "\t\t\t\tbestDist = body.distanceTo( bestGoal );\n"
           "\t\t\t\tif ( dist < bestDist ) {\n"
           "\t\t\t\t\tif ( canReachEntity( item ) ) {\n"
           "\t\t\t\t\t\tbestGoal = item;\n"
           "\t\t\t\t\t}\t\t\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\n"
           "\t\tif ( bestGoal ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][chooseGoal][goal: \" + bestGoal.getName() + \" of [\" + numListedEntities + \"]]\" ); // TinMan *debug*\n"
           "\t\t\tgoalType = SABOT_GOAL_MOVE;\n"
           "\t\t\tgoalPriority = getFloatKey( \"priority_goal_item\" ); // TinMan: Pretty much anything will override this goal.\n"
           "\t\t} else {\n"
           "\t\t\tclearGoal();\n"
           "\t\t}\n"
           "\t}\n"
           "\t\n"
           "\treturn bestGoal; // TinMan: This is the goodest loot\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::lookForGoal\n"
           "TinMan: Find an item to huntz0r.\n"
           "=====================\n"
           "*/\n"
           "entity bot_sabot::lookForGoal( float ignoreLow, float useFov ) {\n"
           "\tfloat i, numListedEntities;\n"
           "\tfloat itemPriority, bestPriority;\n"
           "\tfloat dist, bestDist;\n"
           "\tfloat radius;\n"
           "\tfloat maxHeight, minHeight;\n"
           "\tentity item, bestItem;\n"
           "\tvector origin, itemOrigin;\n"
           "\n"
           "\tradius = 300; // Todo: *demagic*\n"
           "\t\n"
           "\tbestDist = radius;\n"
           "\t\n"
           "\torigin = body.getOrigin();\n"
           "\t\n"
           "\tmaxHeight = 128;\n"
           "\tminHeight = 64;\n"
           "\t\n"
           "\tnumListedEntities = findInRadius( origin, radius, \"idItem\" );\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][lookForGoal][numListedEntities: \" + numListedEntities + \"]\" ); // TinMan *debug*\n"
           "\tfor ( i = 0; i < numListedEntities; i++ ) {\n"
           "\t\titem = getEntityList( i );\n"
           "\t\t\n"
           "\t\titemOrigin = item.getOrigin();\n"
           "\t\tif ( itemOrigin_z > origin_z + maxHeight || itemOrigin_z < origin_z - minHeight ) { // TinMan: tunnel vision *todo* rethink.\n"
           "\t\t\tcontinue;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\titemPriority = getItemPriority( item ); // TinMan: Sort out health and armour, stuff that he can't pick up when he's full, the glutton.\n"
           "\t\t\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][lookForGoal][listedEntity[\" + i + \"]:\" + item.getName() + \"][Prioriy: \" + itemPriority + \"]\" ); // TinMan *debug* \" \n"
           "\t\t// TinMan: Find closest l00t\n"
           "\t\tif ( itemPriority > ignoreLow ) {\n"
           "\t\t\tif ( canSeePosition( item.getOrigin(), true ) && item.isHidden() ) { // TinMan: If we can see it's not there.\n"
           "\t\t\t\tcontinue;\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\tif ( !AI_ENEMY_DEAD && !canSeeEntity( item, true ) ) { // TinMan: *cheaphack, only go for item you can see when fighting\n"
           "\t\t\t\tcontinue;\n"
           "\t\t\t}\n"
           "\n"
           "\t\t\tdist = body.distanceTo( item );\n"
           "\t\t\tif ( dist < bestDist ) {\n"
           "\t\t\t\tif ( canReachEntity( item ) ) {\n"
           "\t\t\t\t\tbestDist = dist;\n"
           "\t\t\t\t\tbestItem = item;\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][listedEntity[\" + i + \"] : \" + item.getName() +  \"][dist: \" + dist + \"]\" ); // TinMan *debug* \" \n"
           "\t}\n"
           "\t\n"
           "\tradius = 400;\n"
           "\t// TinMan: Check for dropped weapons\n"
           "\tnumListedEntities = findInRadius( origin, radius, \"idMoveableItem\" );\n"
           "\tfor ( i = 0; i < numListedEntities; i++ ) {\n"
           "\t\titem = getEntityList( i );\n"
           "\t\t// sys.println( \"[\" + int( sys.getTime() ) + \"][lookForGoal:Movable][listedEntity[\" + i + \"] : \" + item.getName() +  \"]\" ); // TinMan *debug* \"\n"
           "\t\t\n"
           "\t\titemOrigin = item.getOrigin();\n"
           "\t\tif ( itemOrigin_z > origin_z + maxHeight || itemOrigin_z < origin_z - minHeight ) { // TinMan: tunnel vision *todo* rethink.\n"
           "\t\t\tcontinue;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\titemPriority = getItemPriority( item ); // TinMan: Sort out health and armour, stuff that he can't pick up when he's full, the glutton.\n"
           "\t\t// TinMan: Find closest l00t\n"
           "\t\tif ( !item.isHidden() && ( itemPriority > ignoreLow ) ) { // TinMan: *todo* once you get a propper check to see if item is there then you can go for hidden here. However you might want to add some variation to priorities since that's what exluding hidden items is currently doing.\n"
           "\t\t\tif ( canSeeEntity( item, useFov ) ) {\n"
           "\t\t\t\tdist = body.distanceTo( item );\n"
           "\t\t\t\tif ( dist < bestDist ) {\n"
           "\t\t\t\t\tif ( canReachEntity( item ) ) {\n"
           "\t\t\t\t\t\tbestDist = dist;\n"
           "\t\t\t\t\t\tbestItem = item;\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][listedEntity[\" + i + \"] : \" + item.getName() +  \"][dist: \" + dist + \"]\" ); // TinMan *debug* \" : \" + getClassName( item ) +\n"
           "\t}\n"
           "\n"
           "\tif ( gameType == GAME_CTF ) {\n"
           "\t\t// TinMan: Check for dropped flags\n"
           "\t\tradius = 600;\n"
           "\t\tnumListedEntities = findInRadius( origin, radius, \"idItemTeam\" );\n"
           "\t\n"
           "\t\tfor ( i = 0; i < numListedEntities; i++ ) {\n"
           "\t\t\titem = getEntityList( i );\n"
           "\t\t\t// sys.println( \"[\" + int( sys.getTime() ) + \"][lookForGoal:Movable][listedEntity[\" + i + \"] : \" + item.getName() +  \"]\" ); // TinMan *debug* \"\n"
           "\t\t\t\n"
           "\t\t\titemOrigin = item.getOrigin();\n"
           "\t\t\tif ( itemOrigin_z > origin_z + maxHeight || itemOrigin_z < origin_z - minHeight ) { // TinMan: tunnel vision *todo* rethink.\n"
           "\t\t\t\tcontinue;\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\t//itemPriority = getItemPriority( item ); // TinMan: Sort out health and armour, stuff that he can't pick up when he's full, the glutton.\n"
           "\t\t\t// TinMan: Find closest l00t\n"
           "\t\t\t//if ( !item.isHidden() && ( itemPriority > ignoreLow ) ) { // TinMan: *todo* once you get a propper check to see if item is there then you can go for hidden here. However you might want to add some variation to priorities since that's what exluding hidden items is currently doing.\n"
           "\t\t\t\t// TinMan: Check to see if the flag isn't just at base.\n"
           "\t\t\t\tif ( item == ourFlag ) {\n"
           "\t\t\t\t\tif ( getFlagStatus( team ) != FLAGSTATUS_STRAY ) { // TinMan: Our flag should only be a goal if it needs returning.\n"
           "\t\t\t\t\t\tcontinue;\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t} else if ( item == theirFlag ) {\n"
           "\t\t\t\t\tif ( getFlagStatus( 1 - team ) == FLAGSTATUS_TAKEN ) { // TinMan: Flag shouldn't be grabbed\n"
           "\t\t\t\t\t\tcontinue;\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t\t\n"
           "\t\t\t\tif ( canSeeEntity( item, useFov ) ) {\n"
           "\t\t\t\t\tdist = body.distanceTo( item );\n"
           "\t\t\t\t\tif ( dist < bestDist ) {\n"
           "\t\t\t\t\t\tif ( canReachEntity( item ) ) {\n"
           "\t\t\t\t\t\t\tbestDist = dist;\n"
           "\t\t\t\t\t\t\tbestItem = item;\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t\t\n"
           "\t\t\t//}\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + getName() + \"][listedEntity[\" + i + \"] : \" + item.getName() +  \"][dist: \" + dist + \"]\" ); // TinMan *debug* \" : \" + getClassName( item ) +\n"
           "\t\t}\n"
           "\t}\n"
           "\t\n"
           "\t/*\tif ( bestItem ) {\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][lookForGoal][subGoal: \" + bestItem.getName() + \" of [\" + numListedEntities + \"]]\" ); // TinMan *debug*\n"
           "\t} */\n"
           "\n"
           "\treturn bestItem; // TinMan: This is the goodest loot\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::lookForEnemies\n"
           "TinMan: Searches for enemies. You must know where the hurty men are.\n"
           "=====================\n"
           "*/\n"
           "entity bot_sabot::lookForEnemies( float useFov ) {\n"
           "\tfloat i, numListedEnemies;\n"
           "\tentity thisEnemy, bestEnemy;\n"
           "\tfloat dist, bestDist;\n"
           "\t\n"
           "\tbestDist = 999999;\n"
           "\t\n"
           "\tnumListedEnemies = findEnemies( useFov );\n"
           "\tfor ( i = 0; i < numListedEnemies; i++ ) {\n"
           "\t\tthisEnemy = getEntityList( i );\n"
           "\t\t\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][lookForEnemy][listedEnemy[\" + i + \"] : \" + thisEnemy.getName() +  \"]\" ); // TinMan: *debug*\n"
           "\t\tdist = body.distanceTo( thisEnemy );\n"
           "\t\tif ( dist < bestDist ) {\n"
           "\t\t\tif ( thisEnemy != getEnemy() ) {\n"
           "\t\t\t\tbestDist = dist;\n"
           "\t\t\t\tbestEnemy = thisEnemy;\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t}\n"
           "\n"
           "\t/* if ( bestEnemy ) {\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][lookForEnemy][bestEnemy: \" + bestEnemy.getName() + \" of [\" + i + \"]]\" ); // TinMan *debug*\n"
           "\t} */\n"
           "\n"
           "\treturn bestEnemy; // TinMan: He be the badest of the bad\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot::listenForEnemies\n"
           "TinMan: I think I hear something in the basement dear. heardSound is only really geared towards single player ai with one player causing a ruckus.\n"
           "=====================\n"
           "*/\n"
           "entity bot_sabot::listenForEnemies() {\n"
           "\tentity newEnemy;\n"
           "\n"
           "\tnewEnemy = heardSound( false );\n"
           "\tif ( newEnemy == getEnemy() || !canSeeEntity( newEnemy, false ) ) { // TinMan: Visible but not in fov *todo* hmm\n"
           "\t\tnewEnemy = $null_entity;\n"
           "\t}\n"
           "\n"
           "\treturn newEnemy;\n"
           "}\n"
           "\n";
}

/*******************************************************************************
SABot - Stupid Angry Bot - release alpha 8 - "I'm not a puppet! I'm a real boy!"

bot_sabot
The brains of SABot. Braaaaaiiinnns!
********************************************************************************/
idStr botAi::GetBotSabotA8Script(void)
{
    return "#define\tSABOT_NEXT_ENEMY_LOOK\t\t\t\t\t\t\t0.2\n"
           "#define\tSABOT_NEXT_GOAL_CHOOSE\t\t\t\t\t\t1\n"
           "#define\tSABOT_NEXT_GOAL_LOOK\t\t\t\t\t\t\t0.3\n"
           "#define\tSABOT_NEXT_AIM\t\t\t\t\t\t\t\t\t\t0.05\n"
           "\n"
           "// TinMan: Delays before reacting to events\n"
           "#define\tSABOT_REACT_TO_ENEMY\t\t\t\t\t\t\t0.2 //0.3\n"
           "#define\tSABOT_REACT_TO_ENEMY_SOUND\t\t\t\t0.3 //0.4\n"
           "#define\tSABOT_REACT_FIRE\t\t\t\t\t\t\t\t\t0.2\n"
           "\n"
           "#define\tSABOT_ENEMY_LOST_TIME\t\t\t\t\t\t\t0.6\n"
           "#define SABOT_SUBGOAL_LOST_TIME\t\t\t\t\t\t3\n"
           "\n"
           "#define SABOT_CHASE_TIME\t\t\t\t\t\t\t\t\t12 // TinMan: Time to chase (out of view) enemy before giving up\n"
           "#define SABOT_HOLD_TIME\t\t\t\t\t\t\t\t\t\t90\n"
           "\n"
           "#define\tSABOT_CHECK_MOVE_DISTANCE\t\t\t\t\t48\n"
           "\n"
           "// TinMan: time between random strafe changes\n"
           "#define\tSABOT_STRAFE_MIN\t\t\t\t\t\t\t\t\t1\n"
           "#define\tSABOT_STRAFE_MAX\t\t\t\t\t\t\t\t\t3\n"
           "\n"
           "// TinMan: Distances for following\n"
           "#define SABOT_FOLLOWDIST_MAX\t\t\t\t\t\t\t140\n"
           "#define SABOT_FOLLOWDIST_MIN\t\t\t\t\t\t\t100\n"
           "\n"
           "#define SABOT_GOAL_NONE\t\t\t\t\t\t\t\t\t\t\t0\n"
           "#define SABOT_GOAL_MOVE\t\t\t\t\t\t\t\t\t\t\t1\n"
           "#define SABOT_GOAL_HOLD\t\t\t\t\t\t\t\t\t\t\t2\n"
           "#define SABOT_GOAL_FOLLOW\t\t\t\t\t\t\t\t\t\t3\n"
           "#define SABOT_GOAL_ATTACK\t\t\t\t\t\t\t\t\t\t4\n"
           "\n"
           "#define SABOT_ROLE_ROAM\t\t\t\t\t\t\t\t\t\t\t0\n"
           "#define SABOT_ROLE_OFFENCE\t\t\t\t\t\t\t\t\t1\n"
           "#define SABOT_ROLE_DEFENCE\t\t\t\t\t\t\t\t\t2\n"
           "\n"
           "// TinMan: Basically just used as a workaround the fact that setMoveToEntity doesn't like moving to triggers (what ctf cappoints are).\n"
           "#define SABOT_GOALTYPE_ENTITY\t\t\t\t\t\t\t\t0\n"
           "#define SABOT_GOALTYPE_POSITION\t\t\t\t\t\t\t1\n"
           "\n"
           "#define\tSABOT_ITEMTYPE_NONE\t\t\t\t\t\t\t\t\t0\n"
           "#define\tSABOT_ITEMTYPE_HEALTH\t\t\t\t\t\t\t\t1\n"
           "#define\tSABOT_ITEMTYPE_ARMOR\t\t\t\t\t\t\t\t2\n"
           "#define\tSABOT_ITEMTYPE_WEAPON\t\t\t\t\t\t\t\t3\n"
           "#define\tSABOT_ITEMTYPE_AMMO\t\t\t\t\t\t\t\t\t4\n"
           "#define\tSABOT_ITEMTYPE_POWERUP\t\t\t\t\t\t\t5\n"
           "#define\tSABOT_ITEMTYPE_ITEM\t\t\t\t\t\t\t\t\t6\n"
           "\n"
           "object bot_sabot_a8 : bot_base {\n"
           "\tvector\t\tweaponRange;\n"
           "\t\n"
           "\tentity \t\tgoal;\n"
           "\tvector\t\tgoalPosition;\n"
           "\tfloat\t\t\tgoalType;\n"
           "\tfloat\t\t\tgoalPriority;\n"
           "\t\n"
           "\tentity \t\toldGoal;\n"
           "\t\n"
           "\tfloat\t\t\tmoveType;\n"
           "\t\n"
           "\t// TinMan: alternate goal for comparing against current, oh yes the crudeness of script\n"
           "\tentity \t\tnewGoal;\n"
           "\tvector\t\tnewGoalPosition;\n"
           "\tfloat\t\t\tnewMoveType;\n"
           "\tfloat\t\t\tnewGoalType;\n"
           "\tfloat\t\t\tnewGoalPriority;\t\n"
           "\t\n"
           "\tfloat\t\t\trole;\n"
           "\tfloat\t\t\troleDefault;\n"
           "\t\n"
           "\tfloat \t\tteam;\n"
           "\t// TinMan: *CTF*\n"
           "\tentity\t\tourFlag;\n"
           "\tentity\t\ttheirFlag;\n"
           "\tentity\t\tourCap;\n"
           "\tentity\t\ttheirCap;\n"
           "\t\n"
           "\tfloat \t\tgameType;\n"
           "\t\n"
           "\tfloat\t\t\tviewHeight;\n"
           "\tfloat\t\t\tjumpHeight;\n"
           "\t\n"
           "\t//float\t\t\ttimerAmount;\n"
           "\t//float\t\t\ttimerStart;\n"
           "\tfloat\t\t\ttimerEnd;\n"
           "\t\n"
           "\tvector\t\tlastPosition;\n"
           "\tfloat\t\t\tlastPositionTime;\n"
           "\t\n"
           "\tfloat\t\t\tnextEnemyLookTime;\n"
           "\t\n"
           "\tvector\t\tplatTop;\n"
           "\t\n"
           "\tvoid \t\t\tdebugPrint( string func, string message );\n"
           "\n"
           "\t// TinMan: States\n"
           "\tvoid \t\t\tstate_Begin();\n"
           "\tvoid \t\t\tstate_MoveToGoal();\n"
           "\tvoid \t\t\tstate_Combat();\n"
           "\tvoid \t\t\tstate_Chase();\n"
           "\tvoid\t\t\tstate_Retreat();\n"
           "\tvoid\t\t\tstate_Hold();\n"
           "\tvoid\t\t\tstate_Follow();\n"
           "\tvoid \t\t\tstate_Killed();\n"
           "\n"
           "\t// TinMan: Functions\n"
           "\tvoid \t\t\tsetNewGoal();\n"
           "\tvoid\t\t\tclearGoal();\n"
           "\tvoid\t\t\tclearNewGoal();\n"
           "\t\n"
           "\tvoid \t\t\tmoveForward();\n"
           "\tvoid \t\t\tmoveBackward();\n"
           "\tvoid \t\t\tmoveRight();\n"
           "\tvoid \t\t\tmoveLeft();\n"
           "\t\n"
           "\tvector \t\tmoveAction();\n"
           "\n"
           "\tvoid \t\t\tsetTimer( float endTime );\n"
           "\tfloat \t\tgetTimer();\n"
           "\tvoid \t\t\tclearTimer();\n"
           "\tboolean\t\tnextEnemyLook();\n"
           "\n"
           "\tboolean \tcheckGoal();\n"
           "\tboolean\t\tgotFlag();\n"
           "\tboolean \tcheckEnemy( entity thisEnemy );\n"
           "\tboolean \tcheckSelf();\n"
           "\tboolean \tcheckLeader( entity thisLeader );\n"
           "\tboolean\t\tcheckWeapon();\n"
           "\n"
           "\tboolean \tcheckStrafeLeft();\n"
           "\tboolean \tcheckStrafeRight();\n"
           "\tboolean \tcheckMoveForward();\n"
           "\tboolean \tcheckMoveBack();\n"
           "\tfloat\t\t \tcheckMoves();\n"
           "\t\n"
           "\tboolean \tcheckBlocked();\n"
           "\n"
           "\tboolean \tcheckShot( boolean simple );\n"
           "\tboolean \tcheckAimedShot( vector aimPosition, float range );\n"
           "\t\n"
           "\tvoid \t\t\tchooseWeapon( float range );\n"
           "\n"
           "\tvector\t\tpredictTargetPosition( vector targetPosition, vector myPosition, vector targetVelocity, float projectileSpeed );\n"
           "\tvector \t\taddAimVariation( vector aimPosition );\n"
           "\n"
           "\tvector\t\tgetAimTarget( entity target );\n"
           "\n"
           "\tfloat \t\tgetItemPriority( entity item );\n"
           "\tfloat \t\tgetPlayerPriority( entity badass );\n"
           "\tfloat \t\tgetProjectileSpeed( string weaponName );\n"
           "\n"
           "\tentity \t\tchooseGoal( entity ignoreGoal );\n"
           "\tentity \t\tlookForGoal( float useFov );\n"
           "\tentity \t\tlookForEnemies( float useFov );\n"
           "\tentity\t\tlistenForEnemies();\n"
           "};\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::init\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot_a8::init() {\n"
           "\t// TinMan: Grab your keys please\n"
           "\tviewHeight = body.getFloatKey( \"pm_normalviewheight\" );\n"
           "\tjumpHeight = body.getFloatKey( \"pm_jumpheight\" );\n"
           "\t\n"
           "\tgameType = getGameType(); // TinMan: *todo* see if gametype change restarts map (and bot), on brief look it does\n"
           "\troleDefault = SABOT_ROLE_ROAM;\n"
           "\t\n"
           "\tclearTimer();\n"
           "\t\n"
           "\tsetState( \"state_Begin\" );\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::destroy\n"
           "TinMan: Clean up stuff for when script is killed.\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot_a8::destroy() {\n"
           "\twaitFrame();\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::debugPrint\n"
           "TinMan: Sommat a leetle cleaner, lets you have more control over what bots are spamming out debug. For great justice!\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot_a8::debugPrint( string func, string message ) {\n"
           "\tif ( getIntKey( \"debug\" ) ) {\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][\" + func + \"][\" + message + \"]\" );\n"
           "\t}\n"
           "}\n"
           "\n"
           "/***********************************************************************\n"
           "\n"
           "\tStates - Main AI\n"
           "\n"
           "***********************************************************************/\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::state_Begin\n"
           "TinMan: Basic setup. Wakey wakey, rise 'n' shine.\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot_a8::state_Begin() {\n"
           "\tgameType = getGameType(); // TinMan: *todo* see if gametype change restarts map (and bot), on brief look it does\n"
           "\t\n"
           "\t// TinMan: Wait till you get your weapon.\n"
           "\twhile( !weapon ) {\n"
           "\t\tweapon = body.getWeaponEntity();\n"
           "\t\twaitFrame();\n"
           "\t}\n"
           "\t\n"
           "\tcheckWeapon(); // TinMan: Update our weapon vars (currentweapon, weaponrange)\n"
           "\t\n"
           "\tAI_RUN = true;\n"
           "\t\n"
           "\tclearGoal();\n"
           "\t\n"
           "\tclearEnemy();\n"
           "\t\n"
           "\trole = roleDefault;\n"
           "\t\n"
           "\tgameType = getGameType(); // TinMan: *todo* see if gametype change restarts map (and bot), on brief look it does\n"
           "\tif ( gameType == GAME_CTF ) {\n"
           "\t\tteam \t\t\t\t= getTeam( body );  // TinMan: *todo* see if there is any auto ballance during game that could change bots team while it's alive, else this is safe\n"
           "\t\tourFlag \t\t= getFlag( team );\n"
           "\t\ttheirFlag \t= getFlag( 1 - team );\n"
           "\t\tourCap \t\t\t= getCapturePoint( team );\n"
           "\t\ttheirCap \t\t= getCapturePoint( 1 - team );\n"
           "\t}\n"
           "\t\n"
           "\tsetState( \"state_Idle\" );\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::state_Idle\n"
           "TinMan: Default fallback state\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot_a8::state_Idle() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Idle]\" ); // TinMan *debug*\n"
           "\tfloat nextGoalChoose;\n"
           "\tfloat reactToEnemy;\n"
           "\tentity newEnemy;\n"
           "\t\n"
           "\tclearNewGoal();\n"
           "\t\n"
           "\teachFrame {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Idle]\" ); // TinMan *debug*\n"
           "\t\t\n"
           "\t\t// TinMan: Choose a role, which is used to decide on a goal. Curses rhyming strikes again!\n"
           "\t\tif ( checkSelf() ) { // TinMan: Bot too beat up to be thinging abount anything\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Idle][checkSelf: not happy]\" ); // TinMan *debug*\n"
           "\t\t\trole = SABOT_ROLE_ROAM;\n"
           "\t\t} else {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Idle][checkSelf: happy]\" ); // TinMan *debug*\n"
           "\t\t\t// TinMan: *CTF* Choose a goalType\n"
           "\t\t\tif ( gameType == GAME_CTF ) { // TinMan: *todo* check to see when gametype is set, if map is restarted on gametype change then bot will be restarted, then you can just set a local gameType on state_Begin and save the function lookup\n"
           "\t\t\t\tif ( role == SABOT_ROLE_ROAM ) {\n"
           "\t\t\t\t\t//if ( sys.random( 100 ) < 50 ) {\n"
           "\t\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Idle][SABOT_ROLE_OFFENCE]\" ); // TinMan *debug*\n"
           "\t\t\t\t\t\trole = SABOT_ROLE_OFFENCE;\n"
           "\t\t\t\t\t//} else {\n"
           "\t\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Idle][SABOT_GOAL_DEFENCE]\" ); // TinMan *debug*\n"
           "\t\t\t\t\t//\trole = SABOT_ROLE_DEFENCE;\n"
           "\t\t\t\t\t//}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\t\n"
           "\t\tif ( !goal && sys.getTime() > nextGoalChoose ) {\n"
           "\t\t\tnextGoalChoose = sys.getTime() + SABOT_NEXT_GOAL_CHOOSE;\n"
           "\t\t\tgoal = chooseGoal( oldGoal );\n"
           "\t\t\tif ( !goal ) {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Idle][\" + me + \"][Cannot find long range goal]\" ); // TinMan *debug*\n"
           "\t\t\t\tstopMove();\n"
           "\t\t\t\twaitFrame(); // TinMan: Catch a breather.\n"
           "\t\t\t\t// TinMan: *todo* set up some kind of wander goal/state?\n"
           "\n"
           "\t\t\t\t//karin: forbid freeze, always moving!\n"
           "\t\t\t\tgoal = findOther();\n"
           "\t\t\t\tif(goal)\n"
           "\t\t\t\t{\n"
           "\t\t\t\t\tgoalType = SABOT_GOAL_MOVE;\n"
           "\t\t\t\t\tmoveType = SABOT_MOVETYPE_ENTITY;\n"
           "\t\t\t\t}\n"
           "\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\twaitFrame(); // TinMan: Catch a breather.\n"
           "\t\t\n"
           "\t\tif ( goal ) {\n"
           "\t\t\tif ( goalType == SABOT_GOAL_MOVE ) {\n"
           "\t\t\t\tsetState( \"state_MoveToGoal\" );\n"
           "\t\t\t} else if ( goalType == SABOT_GOAL_FOLLOW ) {\n"
           "\t\t\t\tsetState( \"state_Follow\" );\n"
           "\t\t\t} else if ( goalType == SABOT_GOAL_HOLD ) {\n"
           "\t\t\t\tsetState( \"state_Hold\" );\n"
           "\t\t\t}\telse if ( goalType == SABOT_GOAL_ATTACK ) {\n"
           "\t\t\t\tsetState( \"state_Combat\" );\n"
           "\t\t\t} else {\n"
           "\t\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][state_Idle][!Unknown goalType!]\" ); // TinMan *debug*\n"
           "\t\t\t}\n"
           "\t\t} else { // TinMan: no goal, just look for trouble *todo* something else\n"
           "\t\t\tvector bodyOrigin, pushPosition, moveDir;\n"
           "\t\t\tbodyOrigin = body.getOrigin();\n"
           "\t\t\tpushPosition = pushPointIntoAAS( bodyOrigin );\n"
           "\t\t\tif ( pushPosition != bodyOrigin ) {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Idle][\" + me + \"][pushpos != bodyOrigin]\" ); // TinMan *debug*\n"
           "\t\t\t\tmoveDir = pushPosition - bodyOrigin;\n"
           "\t\t\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: *todo* create a wander state for !goal - flip to idle after certian time to see if new goal\n"
           "\t\t\tif ( !reactToEnemy ) {\n"
           "\t\t\t\tif ( nextEnemyLook() || AI_PAIN || AI_ENEMY_VISIBLE ) {\n"
           "\t\t\t\t\tif ( AI_ENEMY_VISIBLE ) {\n"
           "\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY; // TinMan: Set react timer.\n"
           "\t\t\t\t\t} else {\n"
           "\t\t\t\t\t\tnewEnemy = lookForEnemies( true );\n"
           "\t\t\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY; // TinMan: Set react timer.\n"
           "\t\t\t\t\t\t} else {\n"
           "\t\t\t\t\t\t\t// TinMan: Shh, I hear something.\n"
           "\t\t\t\t\t\t\tnewEnemy = listenForEnemies();\n"
           "\t\t\t\t\t\t\tif ( !newEnemy && AI_PAIN ) { // TinMan: *cheaphack* work around due to fack heardsound is being shoehorned into something it's not desiged to handle - multiple players\n"
           "\t\t\t\t\t\t\t\tnewEnemy = lookForEnemies( false );\n"
           "\t\t\t\t\t\t\t}\n"
           "\t\t\t\t\t\t\tif ( newEnemy ) {\n"
           "\t\t\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY_SOUND; // TinMan: Set react timer.\n"
           "\t\t\t\t\t\t\t}\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t} else {\n"
           "\t\t\t\tif ( reactToEnemy < sys.getTime() ) {\n"
           "\t\t\t\t\tsetEnemy( newEnemy );\n"
           "\t\t\t\t\tsetState( \"state_Combat\" );\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::state_MoveToGoal\n"
           "TinMan: Only interested in moving here, ie grabbing item.\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot_a8::state_MoveToGoal() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_MoveToGoal]\" ); // TinMan *debug*\n"
           "\tvector movePosition, secondaryPosition;\n"
           "\tvector aimPosition, aimDir;\n"
           "\tfloat nextGoalLook;\n"
           "\tfloat weaponRangeBuffer;\n"
           "\tfloat enemyLostTime;\n"
           "\tfloat nextAimTime;\n"
           "\tfloat reactToEnemy;\n"
           "\tfloat reactFire, fire;\n"
           "\tfloat lastVisibleEnemyDist;\n"
           "\tvector lastVisibleEnemyPos;\n"
           "\tentity newEnemy;\n"
           "\t\n"
           "\treactToEnemy = 0;\n"
           "\n"
           "\tweaponRangeBuffer = sys.random( 16 ) + 16; // TinMan: *todo* rethink\n"
           "\n"
           "\t//stopMove();\n"
           "\t\n"
           "\tif ( goal ) {\n"
           "\t\tif ( moveType == SABOT_GOALTYPE_ENTITY ) {\n"
           "\t\t\tsetMoveToEntity( goal );\n"
           "\t\t} else {\n"
           "\t\t\tsetMoveToPosition( goalPosition );\n"
           "\t\t}\n"
           "\t}\n"
           "\t\n"
           "\teachFrame {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_MoveToGoal][goal: \" + goal.getName() + \"]\" ); // TinMan *debug*\n"
           "\t\t//debugPrint( \"state_MoveToGoal\", goalPriority );\n"
           "\t\t\t\n"
           "\t\t// TinMan: Look for new goals. The shinier the better.\n"
           "\t\tif ( sys.getTime() > nextGoalLook ) {\n"
           "\t\t\tnextGoalLook = sys.getTime() + SABOT_NEXT_GOAL_LOOK;\n"
           "\t\t\tlookForGoal( true ); // TinMan: Will set newGoal. More important than it might seem, here is the ultimate decision whether to discard current goal (via a higher priority), which may be something set by chooseGoal, and something as important as capping flag.\n"
           "\t\t\t// TinMan: If pretty new thing better than current plaything.\n"
           "\t\t\tif ( newGoal ) {\n"
           "\t\t\t\tif ( newGoal != goal ) {\n"
           "\t\t\t\t\tif ( newGoalPriority > goalPriority ) {\n"
           "\t\t\t\t\t\tsetNewGoal();\n"
           "\t\t\t\t\t\tbreak;\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Lookin for trouble with a big T.\n"
           "\t\tif ( !reactToEnemy ) {\n"
           "\t\t\tif ( nextEnemyLook() || AI_PAIN || AI_ENEMY_VISIBLE ) {\n"
           "\t\t\t\tif ( AI_ENEMY_VISIBLE ) {\n"
           "\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY; // TinMan: Set react timer.\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\tnewEnemy = lookForEnemies( true );\n"
           "\t\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY; // TinMan: Set react timer.\n"
           "\t\t\t\t\t} else {\n"
           "\t\t\t\t\t\t// TinMan: Shh, I hear something.\n"
           "\t\t\t\t\t\tnewEnemy = listenForEnemies();\n"
           "\t\t\t\t\t\tif ( !newEnemy && AI_PAIN ) { // TinMan: *cheaphack* work around due to fack heardsound is being shoehorned into something it's not desiged to handle - multiple players\n"
           "\t\t\t\t\t\t\tnewEnemy = lookForEnemies( false );\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t\tif ( newEnemy ) {\n"
           "\t\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY_SOUND; // TinMan: Set react timer.\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tif ( reactToEnemy < sys.getTime() ) {\n"
           "\t\t\t\tsetEnemy( newEnemy );\n"
           "\t\t\t\treactToEnemy = 0;\n"
           "\t\t\t\tnewGoalPriority = getPlayerPriority( newEnemy );\n"
           "\t\t\t\tif ( newGoalPriority > goalPriority ) {\n"
           "\t\t\t\t\tnewGoal = newEnemy;\n"
           "\t\t\t\t\tnewGoalType = SABOT_GOAL_ATTACK;\n"
           "\t\t\t\t\tsetNewGoal();\n"
           "\t\t\t\t\tsetState( \"state_Combat\" );\t\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t/*\n"
           "\t\t// TinMan: *todo* rejigger NGS\n"
           "\t\tif ( gameType == GAME_CTF ) {\n"
           "\t\t\tif ( !checkSelf() && gotFlag() ) { // TinMan: *cheaphack* got flag?\n"
           "\t\t\t\tclearGoal();\n"
           "\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t*/\n"
           "\t\t\n"
           "\t\t// TinMan: Move along given path\n"
           "\t\tmovePosition = moveAction();\n"
           "\t\t\n"
           "\t\tcheckBlocked();\n"
           "\t\t\n"
           "\t\tif ( getEnemy() ) { // TinMan: *todo* look through and overhaul looking at enemy/fighting\n"
           "\t\t\tif ( !AI_ENEMY_DEAD ) {\n"
           "\t\t\t\tlastVisibleEnemyPos = getEnemyPos();\n"
           "\t\t\t\tlastVisibleEnemyPos_z += viewHeight; // TinMan: cheap hack pos off ground since we'll be aiming at it when enemy dead\n"
           "\t\t\t\tlastVisibleEnemyDist = enemyRange();\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: Aim at enemy\n"
           "\t\t\tif ( nextAimTime < sys.getTime() ) { // TinMan: Roughen up aiming a bit\n"
           "\t\t\t\tnextAimTime = sys.getTime() + SABOT_NEXT_AIM;\n"
           "\t\t\t\tif ( AI_ENEMY_VISIBLE ) {\n"
           "\t\t\t\t\t// TinMan: Get initial aim position  - chest, feets.\n"
           "\t\t\t\t\taimPosition = getAimTarget( getEnemy() );\n"
           "\t\t\t\t\t// TinMan: Lead shot\n"
           "\t\t\t\t\tentity enemy = getEnemy();\n"
           "\t\t\t\t\taimPosition = predictTargetPosition( aimPosition, getViewPosition(), enemy.getLinearVelocity(), getProjectileSpeed( currentWeapon ) );\n"
           "\t\t\t\t\taimDir = addAimVariation( aimPosition ); // TinMan: Screw up aim cause I'm mean.\n"
           "\t\t\t\t\t//aimDir = aimPosition - getViewPosition(); // TinMan: *test* simple\n"
           "\t\t\t\t\tsetAimDirection( aimDir ); // TinMan: Finally set our target to aim to.\n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][aimPosition = \" + aimPosition_x + \" \" + aimPosition_y + \" \" +aimPosition_z + \"]\" ); // TinMan: *debug*\n"
           "\t\t\t\t} else { // TinMan: Aim at teh dedders\n"
           "\t\t\t\t\taimDir = lastVisibleEnemyPos - getViewPosition();\n"
           "\t\t\t\t\tsetAimDirection( aimDir );\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: Check shot is within weapon range. AND SMITE HIM!\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][CurrentWeapon: \" + currentWeapon + \"][Weaponrange]\" ); // TinMan: *debug*\n"
           "\t\t\tif ( ( lastVisibleEnemyDist > weaponRange_y ) && ( lastVisibleEnemyDist < weaponRange_z ) )\t{\n"
           "\t\t\t\t// TinMan: See if any enemies in shot.\n"
           "\t\t\t\tif ( !reactFire ) { // TinMan: Allready going to fire\n"
           "\t\t\t\t\tif ( checkShot( false ) ) { // TinMan: See if enemy in straight bounds trace.\n"
           "\t\t\t\t\t\treactFire = sys.getTime() + SABOT_REACT_FIRE;\n"
           "\t\t\t\t\t} else if ( checkShot( true ) ) { // TinMan: See if enemy in straight point trace.\n"
           "\t\t\t\t\t\treactFire = sys.getTime() + SABOT_REACT_FIRE;\n"
           "\t\t\t\t\t} else if ( checkAimedShot( aimPosition, lastVisibleEnemyDist ) ) { // TinMan: See if we are aimed at position and shot will make it.\n"
           "\t\t\t\t\t\treactFire = sys.getTime() + SABOT_REACT_FIRE;\n"
           "\t\t\t\t\t} else {\n"
           "\t\t\t\t\t\treactFire = 0;\n"
           "\t\t\t\t\t\tfire = false;\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\telse { // TinMan: Aw, out of weapon range.\n"
           "\t\t\t\treactFire = 0;\n"
           "\t\t\t\tfire = false;\n"
           "\t\t\t}\n"
           "\t\n"
           "\t\t\tif ( reactFire != 0 ) {\n"
           "\t\t\t\tif ( reactFire < sys.getTime() ) {\n"
           "\t\t\t\t\tfire = true; // TinMan: Ratatat tat, boom, fwoosh!\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\tif ( fire && ( enemyLostTime < 0.2 || AI_ENEMY_DEAD ) ) { // TinMan: The delayed fire is working out quite nicely at the moment except leads to the bot shooting into walls too much.\n"
           "\t\t\t\tAI_WEAPON_FIRE = true;\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\t// TinMan: Lookee where we damn be going.\n"
           "\t\t\tif ( AI_ONGROUND && movePosition != body.getOrigin() ) { // TinMan: *cheaphack* stop bot from looking down when movepos = body.org\n"
           "\t\t\t\taimDir = movePosition - body.getOrigin();\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_MoveToGoal][aimdir: \" + aimDir + \"]\" ); // TinMan: expensive *debug*\n"
           "\t\t\t\tsetAimDirection( aimDir );\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t/*\n"
           "\t\tif ( checkShot( true ) ) {\n"
           "\t\t\tAI_WEAPON_FIRE = true;\n"
           "\t\t}\n"
           "\t\t*/\n"
           "\t\t\n"
           "\t\t// TinMan: Wherizy?\n"
           "\t\tif ( !AI_ENEMY_VISIBLE ) {\n"
           "\t\t\tif ( enemyLostTime == 0 ) {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_MoveToGoal][start lost timer]\" ); // TinMan: *debug*\n"
           "\t\t\t\tenemyLostTime = RandomDelay( SABOT_ENEMY_LOST_TIME, SABOT_ENEMY_LOST_TIME + 0.5 );\n"
           "\t\t\t} else if ( enemyLostTime < sys.getTime() ) {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_MoveToGoal][lost]\" ); // TinMan: *debug*\n"
           "\t\t\t\t//setState( \"state_Chase\" );\n"
           "\t\t\t\tclearEnemy();\n"
           "\t\t\t}\n"
           "\t\t} else if ( AI_ENEMY_VISIBLE ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_MoveToGoal][reset lost timer]\" ); // TinMan: *debug*\n"
           "\t\t\tenemyLostTime = 0; // TinMan: Can see enemy again, so stop timer\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: See if we should still go for goal.\n"
           "\t\tif ( checkGoal() ) {\n"
           "\t\t\tif ( goalType != SABOT_GOAL_HOLD ) { // TinMan: *cheaphack* need goal stack\n"
           "\t\t\t\tclearGoal();\n"
           "\t\t\t}\n"
           "\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t}\n"
           "\t\tif ( AI_MOVE_DONE || AI_DEST_UNREACHABLE ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_MoveToGoal][movedone or cannot reach]\" ); // TinMan: *debug*\n"
           "\t\t\tif ( goalType != SABOT_GOAL_HOLD ) { // TinMan: *cheaphack* need goal stack\n"
           "\t\t\t\tclearGoal();\n"
           "\t\t\t}\n"
           "\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t}\n"
           "\t\n"
           "\t\tcheckWeapon(); // TinMan: Make sure your weapon is nice and shiny\n"
           "\t} // TinMan: End eachFrame/state\n"
           "\t\n"
           "\t// TinMan: Exit state\n"
           "\tsetState( \"state_Idle\" );\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::state_Combat\n"
           "TinMan: Direct combat with enemy. Strike him down!\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot_a8::state_Combat() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Combat]\" ); // TinMan: *debug*\n"
           "\t\n"
           "\tfloat weaponRangeBuffer;\n"
           "\tfloat nextAimTime;\n"
           "\tfloat nextGoalLook;\n"
           "\tfloat enemyLostTime;\n"
           "\tfloat fire, forwards, back, left, right;\n"
           "\tfloat nextStrafeTime;\n"
           "\tfloat moveFlags;\n"
           "\tfloat reactToEnemy, reactFire;\n"
           "\tfloat dist;\n"
           "\tfloat lastVisibleEnemyDist;\n"
           "\tfloat checkTime;\n"
           "\tvector lastVisibleEnemyPos;\n"
           "\tvector aimDir, aimPosition;\n"
           "\tentity enemy, newEnemy;\n"
           "\t\n"
           "\tif ( !getEnemy() ) {\n"
           "\t\tclearGoal();\n"
           "\t\tsetState( \"state_Idle\" );\n"
           "\t}\n"
           "\t\n"
           "\treactToEnemy = false;\n"
           "\tenemyLostTime = 0;\n"
           "\t\n"
           "\tenemy = getEnemy();\n"
           "\n"
           "\tsetMoveToEnemy();\n"
           "\t// TinMan: Flip out straight away if you can't do move. *todo* move to attack position instead\n"
           "\t/*\n"
           "\tif ( AI_DEST_UNREACHABLE ) {\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][Start:Cannot move to enemy!]\" ); // TinMan: *debug*\n"
           "\t\tsetState( \"state_Idle\" );\n"
           "\t}\n"
           "\t*/\n"
           "\n"
           "\tweaponRangeBuffer = sys.random( 16 ) + 16; // TinMan: *todo* rethink\n"
           "\teachFrame {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Combat]\" ); // TinMan: *debug*\n"
           "\t\t// TinMan: Look for new goals. The shinier the better.\n"
           "\t\tif ( sys.getTime() > nextGoalLook ) {\n"
           "\t\t\tnextGoalLook = sys.getTime() + SABOT_NEXT_GOAL_LOOK;\n"
           "\t\t\tlookForGoal( true ); // TinMan: Will set newGoal. More important than it might seem, here is the ultimate decision whether to discard current goal (via a higher priority), which may be something set by choosgoal, and something as important as capping flag.\n"
           "\t\t\t// TinMan: If pretty new thing better than current plaything.\n"
           "\t\t\tif ( newGoal ) {\n"
           "\t\t\t\tif ( newGoal != goal ) {\n"
           "\t\t\t\t\tif ( newGoalPriority > goalPriority ) {\n"
           "\t\t\t\t\t\tsetNewGoal();\n"
           "\t\t\t\t\t\tbreak;\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Check to see if enemy died, and set some reaction time\n"
           "\t\tif ( AI_ENEMY_DEAD || !getEnemy() ) { // TinMan: idAI checks to see if enemy is alive each think and sets these if not.\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"[state_Combat][no enemy]\" ); // TinMan *debug*\n"
           "\t\t\tif ( timerEnd == -1 ) {\n"
           "\t\t\t\tsetMoveToPosition( lastVisibleEnemyPos );\n"
           "\t\t\t\tsetTimer( 0.3 );\n"
           "\t\t\t} else if ( getTimer() ) {\n"
           "\t\t\t\tclearTimer();\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"[state_Combat][no enemy]\" ); // TinMan *debug*\n"
           "\t\t\t\tclearGoal();\n"
           "\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tlastVisibleEnemyPos = getEnemyPos();\n"
           "\t\t\tlastVisibleEnemyPos_z += viewHeight; // TinMan: cheap hack pos off ground since we'll be aiming at it when enemy dead\n"
           "\t\t\tlastVisibleEnemyDist = enemyRange();\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: The enemy might move to an unreachable spot, wall edge, or be midair, so we need to reset move *todo* Ideally we want to do a movetoattackposition\n"
           "\t\tif ( AI_DEST_UNREACHABLE || AI_MOVE_DONE ) {\n"
           "\t\t\tif ( checkTime < sys.getTime() ) {\n"
           "\t\t\t\tif ( getEnemy() ) {\n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][reset move to enemy!]\" ); // TinMan: *debug*\n"
           "\t\t\t\t\tcheckTime = sys.getTime() + 0.3;\n"
           "\t\t\t\t\tif ( AI_MOVE_DONE ) { // TinMan: at last reachable enemy pos\n"
           "\t\t\t\t\t\tlocateEnemy(); // TinMan: force update\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t\tsetMoveToEnemy();\n"
           "\t\t\t\t\t//setMoveToAttackPosition( getEnemy() );\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t/* TinMan: *todo* NGS rejigger\n"
           "\t\t// TinMan: See if we even want to be fighting - if enemy too badass or too beatup\n"
           "\t\tif ( checkSelf() ) { // checkEnemy( enemy ) || \n"
           "\t\t\t//if ( sys.random( 100 ) < 40 ) { // TinMan: *todo* demagic, set a limit/timer\n"
           "\t\t\t\t//if ( body.distanceTo( getEnemy() ) > 128 ) {\n"
           "\t\t\t\t\twaitFrame();\n"
           "\t\t\t\t\tsetState( \"state_CombatRetreat\" );\n"
           "\t\t\t\t//}\n"
           "\t\t\t//}\n"
           "\t\t}\n"
           "\t\t*/\n"
           "\n"
           "\t\t// TinMan: Aim at enemy\n"
           "\t\tif ( nextAimTime < sys.getTime() ) { // TinMan: Roughen up aiming a bit\n"
           "\t\t\tnextAimTime = sys.getTime() + SABOT_NEXT_AIM;\n"
           "\t\t\tif ( !AI_ENEMY_DEAD ) {\n"
           "\t\t\t\t// TinMan: Get initial aim position  - chest, feets.\n"
           "\t\t\t\taimPosition = getAimTarget( getEnemy() );\n"
           "\t\t\t\t\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][aimPosition = \" + aimPosition_x + \" \" + aimPosition_y + \" \" +aimPosition_z + \"]\" ); // TinMan: *debug*\n"
           "\t\t\t\t// TinMan: Lead shot\n"
           "\t\t\t\taimPosition = predictTargetPosition( aimPosition, getViewPosition(), enemy.getLinearVelocity(), getProjectileSpeed( currentWeapon ) );\n"
           "\t\t\t\taimDir = addAimVariation( aimPosition ); // TinMan: Screw up aim cause I'm mean.\n"
           "\t\t\t\t\n"
           "\t\t\t\t//aimPosition = enemy.getOrigin(); // TinMan: *test* simple\n"
           "\t\t\t\t//aimDir = aimPosition - getViewPosition(); // TinMan: *test* simple\n"
           "\t\t\t\t\n"
           "\t\t\t\tsetAimDirection( aimDir ); // TinMan: Finally set our target to aim to.\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][aimDir = \" + aimDir_x + \" \" + aimDir_y + \" \" +aimDir_z + \"]\" ); // TinMan: *debug*\n"
           "\t\t\t} else { // TinMan: Aim at teh dedders\n"
           "\t\t\t\taimDir = lastVisibleEnemyPos - getViewPosition();\n"
           "\t\t\t\tsetAimDirection( aimDir );\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\n"
           "\t\t// TinMan: Check shot is within weapon range. AND SMITE HIM!\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][CurrentWeapon: \" + currentWeapon + \"][Weaponrange]\" ); // TinMan: *debug*\n"
           "\t\tif ( ( lastVisibleEnemyDist > weaponRange_y ) && ( lastVisibleEnemyDist < weaponRange_z ) )\t{\n"
           "\t\t\t// TinMan: See if any enemies in shot.\n"
           "\t\t\tif ( !reactFire ) { // TinMan: Allready going to fire\n"
           "\t\t\t\tif ( checkShot( false ) ) { // TinMan: See if enemy in straight bounds trace.\n"
           "\t\t\t\t\treactFire = sys.getTime() + SABOT_REACT_FIRE;\n"
           "\t\t\t\t} else if ( checkShot( true ) ) { // TinMan: See if enemy in straight point trace.\n"
           "\t\t\t\t\treactFire = sys.getTime() + SABOT_REACT_FIRE;\n"
           "\t\t\t\t} else if ( checkAimedShot( aimPosition, lastVisibleEnemyDist ) ) { // TinMan: See if we are aimed at position and shot will make it.\n"
           "\t\t\t\t\treactFire = sys.getTime() + SABOT_REACT_FIRE;\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\treactFire = 0;\n"
           "\t\t\t\t\tfire = false;\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\telse { // TinMan: Aw, out of weapon range.\n"
           "\t\t\treactFire = 0;\n"
           "\t\t\tfire = false;\n"
           "\t\t}\n"
           "\n"
           "\t\tif ( reactFire != 0 ) {\n"
           "\t\t\tif ( reactFire < sys.getTime() ) {\n"
           "\t\t\t\tfire = true; // TinMan: Ratatat tat, boom, fwoosh!\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tif ( fire && ( enemyLostTime < 0.2 || AI_ENEMY_DEAD ) ) { // TinMan: The delayed fire is working out quite nicely at the moment except leads to the bot shooting into walls too much. *todo* we should really be stopping firing after a delay like the starting fire does.\n"
           "\t\t\tAI_WEAPON_FIRE = true;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Look out for more imediate threats.\n"
           "\t\tif ( !reactToEnemy ) {\n"
           "\t\t\tif ( nextEnemyLook() ) {\n"
           "\t\t\t\tnewEnemy = lookForEnemies( true );\n"
           "\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\tdist = body.distanceTo( newEnemy );\n"
           "\t\t\t\t\tif ( dist < lastVisibleEnemyDist - 64 ) {\n"
           "\t\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][Wah! New enemy closy close]\" ); // TinMan: *debug*\n"
           "\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY; // TinMan: Set react timer.\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\t// TinMan: Shh, I hear something.\n"
           "\t\t\t\t\tnewEnemy = listenForEnemies();\n"
           "\t\t\t\t\tif ( !newEnemy && AI_PAIN ) { // TinMan: *cheaphack* work around due to fack heardsound is being shoehorned into something it's not desiged to handle - multiple players\n"
           "\t\t\t\t\t\tnewEnemy = lookForEnemies( false );\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\t\tdist = body.distanceTo( newEnemy );\n"
           "\t\t\t\t\t\tif ( dist < lastVisibleEnemyDist - 64 ) {\n"
           "\t\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY_SOUND; // TinMan: Set react timer.\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tif ( reactToEnemy < sys.getTime() ) {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me +\"][state_Combat][newenemy!!]\" ); // TinMan: *debug*\n"
           "\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\n"
           "\t\t// TinMan: Move closer/ retreat/ strafe.. to get to weapon sweet spot\n"
           "\t\tif ( lastVisibleEnemyDist > weaponRange_x + weaponRangeBuffer ) { // TinMan *todo* rejigger to lastenpos\n"
           "\t\t\t// TinMan: Closer than weaponRange\n"
           "\t\t\tif ( AI_ENEMY_VISIBLE ) {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][Moving to sweet spot: \" + weaponRange_x + \"]\" ); // TinMan: *debug*\n"
           "\t\t\t\tif ( travelDistanceToPoint( lastVisibleEnemyPos ) < 600  ) { // TinMan: *todo* remove once better solution implemented\n"
           "\t\t\t\t\t// TinMan: -v- still like the careening off any height\n"
           "\t\t\t\t\t/*if ( checkMoveForward() ) {\n"
           "\t\t\t\t\t\tmoveForward();\n"
           "\t\t\t\t\t}*/\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t\tmoveAction();\n"
           "\t\t\t\t}\n"
           "\t\t\t} else { // !AI_ENEMY_VIS\n"
           "\t\t\t\tmoveAction();\n"
           "\t\t\t}\n"
           "\t\t} else if ( lastVisibleEnemyDist < ( weaponRange_x - weaponRangeBuffer ) ) { // TinMan: EnemyRange Further than weaponRange\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][Moving backwards to sweet spot]\" ); // TinMan: *debug*\n"
           "\t\t\tAI_FORWARD = false;\n"
           "\t\t\tif ( checkMoveBack() ) {\n"
           "\t\t\t\tmoveBackward();\n"
           "\t\t\t}\n"
           "\t\t} /*else {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][At sweet spot]\" ); // TinMan: *debug*\n"
           "\t\t} */\n"
           "\n"
           "\t\tif ( nextStrafeTime < sys.getTime() ) { // TinMan: Randomly change strafe\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][Strafe]\" ); // TinMan: *debug*\n"
           "\t\t\tnextStrafeTime = RandomDelay( SABOT_STRAFE_MIN, SABOT_STRAFE_MAX );\n"
           "\t\n"
           "\t\t\tleft = false;\n"
           "\t\t\tright = false;\n"
           "\t\t\tleft = checkStrafeLeft();\n"
           "\t\t\tright = checkStrafeRight();\n"
           "\t\t\t \t\n"
           "\t\t\tif ( left && right ) {\n"
           "\t\t\t\tright == !AI_STRAFE_RIGHT; // TinMan: went right last time\n"
           "\t\t\t \tleft == !AI_STRAFE_LEFT;\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\n"
           "\t\tif ( right ) {\n"
           "\t\t\tmoveRight();\n"
           "\t\t} else if ( left ) {\n"
           "\t\t\tmoveLeft();\n"
           "\t\t}\n"
           "\n"
           "\t\t// TinMan: *cheaphack* stop bashing into stuff\n"
           "\t\tif ( AI_STRAFE_RIGHT && !checkStrafeRight() ) {\n"
           "\t\t\tAI_STRAFE_RIGHT = false;\n"
           "\t\t\tnextStrafeTime = sys.getTime() + 0.05;\n"
           "\t\t}\n"
           "\t\tif ( AI_STRAFE_LEFT && !checkStrafeLeft() ) {\n"
           "\t\t\tAI_STRAFE_LEFT = false;\t\t\n"
           "\t\t\tnextStrafeTime = sys.getTime() + 0.05;\n"
           "\t\t}\n"
           "\t\tif ( AI_FORWARD && !checkMoveForward() ) {\n"
           "\t\t\tAI_FORWARD = false;\n"
           "\t\t}\n"
           "\t\tif ( AI_BACKWARD && !checkMoveBack() ) {\n"
           "\t\t\tAI_BACKWARD = false;\n"
           "\t\t}\n"
           "\n"
           "\t\t// TinMan: Wherizy?\n"
           "\t\tif ( !AI_ENEMY_VISIBLE ) {\n"
           "\t\t\tif ( enemyLostTime == 0 ) {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][start lost timer]\" ); // TinMan: *debug*\n"
           "\t\t\t\tenemyLostTime = RandomDelay( SABOT_ENEMY_LOST_TIME, SABOT_ENEMY_LOST_TIME + 0.5 );\n"
           "\t\t\t} else if ( enemyLostTime < sys.getTime() ) {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][chase]\" ); // TinMan: *debug*\n"
           "\t\t\t\tsetState( \"state_Chase\" );\n"
           "\t\t\t}\n"
           "\t\t} else if ( AI_ENEMY_VISIBLE ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][reset lost timer]\" ); // TinMan: *debug*\n"
           "\t\t\tenemyLostTime = 0; // TinMan: Can see enemy again, so stop timer\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tcheckBlocked();\n"
           "\n"
           "\t\tcheckWeapon();\n"
           "\t\t\n"
           "\t} // TinMan: End eachFrame/state\n"
           "\t\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][Exit state]\" ); // TinMan: *debug*\n"
           "\t\n"
           "\t// TinMan: Exit state\n"
           "\tif ( newEnemy ) { // TinMan: *cheaphack* Fix the loosing enemy due to reactiontime and state change *todo* rethink\n"
           "\t\tsetEnemy( newEnemy );\n"
           "\t}\n"
           "\t\n"
           "\tif ( getEnemy() ) {\n"
           "\t\tsetState( \"state_Combat\" );\n"
           "\t} else {\n"
           "\t\tclearGoal();\n"
           "\t\tsetState( \"state_Idle\" );\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::state_Chase\n"
           "TinMan: Move to restablish combat. Hunt him down!\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot_a8::state_Chase() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Chase]\" ); // TinMan: *debug*\n"
           "\tvector movePosition, aimDir, aimPosition;\n"
           "\tfloat chaseTime;\n"
           "\tfloat nextGoalLook;\n"
           "\tfloat reactToEnemy;\n"
           "\tentity newEnemy;\n"
           "\t\n"
           "\tif ( !getEnemy() ) {\n"
           "\t\tsetState( \"state_Idle\" );\n"
           "\t}\n"
           "\n"
           "\t// TinMan: Gentlemen, start your engines.\n"
           "\t//if ( canReachEntity( getEnemy() ) ) {\n"
           "\tsetMoveToEnemy();\n"
           "\t//} else {\n"
           "\t\t//setMoveToAttackPosition( getEnemy() );\n"
           "\t\t//\n"
           "\t\t/*\n"
           "\t\tif ( AI_DEST_UNREACHABLE ) {\n"
           "\t\t\t// sys.println( \"[\" + int( sys.getTime() ) + \"][state_Chase][Cannot reach enemy or attack position]\" ); // TinMan: *debug*\n"
           "\t\t\tclearEnemy();\n"
           "\t\t\tsetState( \"state_Idle\" );\n"
           "\t\t}\n"
           "\t\t*/\n"
           "\t\t// sys.println( \"[\" + int( sys.getTime() ) + \"][state_Chase][Moving to attack position]\" ); // TinMan: *debug*\n"
           "\t//}\n"
           "\t// TinMan: Flip out straight away if you can't do move.\n"
           "\t/*if ( AI_MOVE_DONE || AI_DEST_UNREACHABLE ) {\n"
           "\t\tsetState( \"state_Idle\" );\t\t\n"
           "\t}*/\n"
           "\t\n"
           "\treactToEnemy = false;\n"
           "\n"
           "\tsetTimer( SABOT_CHASE_TIME ); // TinMan: Start chase timer.\n"
           "\t//chaseTime = sys.getTime() + SABOT_CHASE_TIME; // TinMan: Start chase timer.\n"
           "\n"
           "\teachFrame {\t\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Chase]\" ); // TinMan: *debug*\n"
           "\t\t// TinMan: Check to see if enemy died\n"
           "\t\tif ( AI_ENEMY_DEAD || !getEnemy() ) { // TinMan: idAI checks to see if enemy is alive each think and sets these if not.\n"
           "\t\t\tsetState( \"state_Idle\" );\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Move along given path\n"
           "\t\tmovePosition = moveAction();\n"
           "\t\t\n"
           "\t\t// TinMan: Lookee where we damn be going.\n"
           "\t\t//movePosition = getMovePosition(); // TinMan: expensive\n"
           "\t\tif ( AI_ONGROUND && movePosition != body.getOrigin() ) {\n"
           "\t\t\taimDir = movePosition - body.getOrigin();\n"
           "\t\t\tsetAimDirection( aimDir );\n"
           "\t\t}\n"
           "\t\t\t\t\n"
           "\t\tcheckBlocked();\n"
           "\t\t\n"
           "\t\tif ( checkShot( true ) ) {\n"
           "\t\t\tAI_WEAPON_FIRE = true;\n"
           "\t\t}\n"
           "\n"
           "\t\t// TinMan: Look out for new badasses trying to kill you.\n"
           "\t\tif ( !reactToEnemy ) {\n"
           "\t\t\tif ( nextEnemyLook() || AI_PAIN || AI_ENEMY_VISIBLE ) {\n"
           "\t\t\t\tif ( AI_ENEMY_VISIBLE ) {\n"
           "\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY; // TinMan: Set react timer.\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\tnewEnemy = lookForEnemies( true );\n"
           "\t\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\t\tif ( body.distanceTo( newEnemy ) < enemyRange() ) { // TinMan: Closer than the chump I'm hunting.\n"
           "\t\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY; // TinMan: Set react timer.\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t} else {\n"
           "\t\t\t\t\t\t// TinMan: Shh, I hear something.\n"
           "\t\t\t\t\t\tnewEnemy = listenForEnemies();\n"
           "\t\t\t\t\t\tif ( !newEnemy && AI_PAIN ) { // TinMan: *cheaphack* work around due to fack heardsound is being shoehorned into something it's not desiged to handle - multiple players\n"
           "\t\t\t\t\t\t\tnewEnemy = lookForEnemies( false );\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t\tif ( newEnemy ) {\n"
           "\t\t\t\t\t\t\tif (  body.distanceTo( newEnemy ) < enemyRange() ) { // TinMan: Closer than the chump I'm hunting.\n"
           "\t\t\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY_SOUND; // TinMan: Set react timer.\n"
           "\t\t\t\t\t\t\t}\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tif ( reactToEnemy < sys.getTime() ) {\n"
           "\t\t\t\tsetEnemy( newEnemy );\n"
           "\t\t\t\tsetState( \"state_Combat\" );\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\n"
           "\t\tcheckWeapon();\n"
           "\t\t\n"
           "\t\t// TinMan: Get back into the fightening\n"
           "\t\tif ( AI_ENEMY_IN_FOV ) {\n"
           "\t\t\twaitFrame();\n"
           "\t\t\tsetState( \"state_Combat\" );\n"
           "\t\t}\n"
           "\t\t\t\n"
           "\t\t// TinMan: At last seen enemy pos and can't see enemy *todo* rethink\n"
           "\t\tif ( AI_MOVE_DONE || AI_DEST_UNREACHABLE ) {\n"
           "\t\t\tfloat checkTime;\n"
           "\t\t\tif ( checkTime < sys.getTime() ) {\n"
           "\t\t\t\tif ( getEnemy() ) {\n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Chase][reset move to enemy!]\" ); // TinMan: *debug*\n"
           "\t\t\t\t\tcheckTime = sys.getTime() + 0.3;\n"
           "\t\t\t\t\tif ( AI_MOVE_DONE ) { // TinMan: Cheat a bit, move towards current enemy pos\n"
           "\t\t\t\t\t\tlocateEnemy(); \n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t\tsetMoveToEnemy();\n"
           "\t\t\t\t\t//setMoveToAttackPosition( getEnemy() );\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Only chase the enemy for a certain amount of time, if it's up you've lost him.\n"
           "\t\t//if ( chaseTime < sys.getTime() ) {\n"
           "\t\tif ( getTimer() ) {\n"
           "\t\t\t// sys.println( \"[\" + int( sys.getTime() ) + \"][state_Chase][ChaseTime Up]\" ); // TinMan: *debug*\n"
           "\t\t\tclearTimer();\n"
           "\t\t\tclearEnemy();\n"
           "\t\t\tsetState( \"state_Idle\" );\n"
           "\t\t}\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::state_Retreat\n"
           "TinMan: Trying to escape enemy. Run Forest! Run!\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot_a8::state_Retreat() {\n"
           "\t// sys.println( \"[\" + int( sys.getTime() ) + \"][state_Retreat]\" ); // TinMan: *debug*\n"
           "\tfloat nextGoalLook;\n"
           "\tfloat reactToEnemy;\n"
           "\tfloat enemyLostTime;\n"
           "\tvector movePosition;\n"
           "\tvector aimDir;\n"
           "\tentity newEnemy;\n"
           "\t\n"
           "\tif ( !getEnemy() ) {\n"
           "\t\tsetState( \"state_Idle\" );\n"
           "\t} \n"
           "\t\n"
           "\tsetMoveToCover();\n"
           "\tif ( AI_DEST_UNREACHABLE || AI_MOVE_DONE ) {\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][state_Retreat][Cannot move to cover]\" ); // TinMan: *debug*\n"
           "\t\t/*setMoveOutOfRange( getEnemy(), 400 ); // TinMan: *todo* no magic\n"
           "\t\tif ( AI_DEST_UNREACHABLE || AI_MOVE_DONE ) {\n"
           "\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][state_Retreat][Cannot move out of range]\" ); // TinMan: *debug*\n"
           "\t\t}\telse {\n"
           "\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][state_Retreat][Moving out of range]\" ); // TinMan: *debug*\n"
           "\t\t}\n"
           "\t\t*/\n"
           "\t} /*else {\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][state_Retreat][Moving to cover]\" ); // TinMan: *debug*\n"
           "\t} */\n"
           "\n"
           "\teachFrame {\n"
           "\t\t// TinMan: Check to see if enemy died\t\n"
           "\t\tif ( AI_ENEMY_DEAD || !getEnemy() ) { // TinMan: idAI checks to see if enemy is alive each think and sets these if not.\n"
           "\t\t\tbreak;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tif ( AI_MOVE_DONE || AI_DEST_UNREACHABLE ) {\n"
           "\t\t\t//clearEnemy();\n"
           "\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Don't want to be running all our lives\n"
           "\t\tif ( !AI_ENEMY_VISIBLE ) {\n"
           "\t\t\tif ( enemyLostTime == 0 ) {\n"
           "\t\t\t\tenemyLostTime = sys.getTime() + 12; // TinMan: *todo* demagic\n"
           "\t\t\t} else if ( enemyLostTime < sys.getTime() ) {\n"
           "\t\t\t\tclearEnemy();\n"
           "\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tif ( AI_PAIN && AI_ENEMY_VISIBLE ) { // TinMan: *todo* set reaction timer\n"
           "\t\t\t\tsetState( \"state_CombatRetreat\" );\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Move along given path\n"
           "\t\tmovePosition = moveAction();\n"
           "\t\t\n"
           "\t\t// TinMan: Lookee where we damn be going.\n"
           "\t\t//movePosition = getMovePosition(); // TinMan: expensive\n"
           "\t\tif ( AI_ONGROUND && movePosition != body.getOrigin() ) {\n"
           "\t\t\taimDir = movePosition - body.getOrigin();\n"
           "\t\t\tsetAimDirection( aimDir );\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tcheckBlocked();\n"
           "\t\t\n"
           "\t\tif ( checkShot( true ) ) {\n"
           "\t\t\tAI_WEAPON_FIRE = true;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Look out for new badasses trying to kill you.\n"
           "\t\tif ( !reactToEnemy ) {\n"
           "\t\t\tif ( nextEnemyLook() || AI_PAIN ) {\n"
           "\t\t\t\tnewEnemy = lookForEnemies( true );\n"
           "\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\tif ( body.distanceTo( newEnemy ) < enemyRange() ) { // TinMan: Closer than the chump I'm hunting.\n"
           "\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY; // TinMan: Set react timer.\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\t// TinMan: Shh, I hear something.\n"
           "\t\t\t\t\tnewEnemy = listenForEnemies();\n"
           "\t\t\t\t\tif ( !newEnemy && AI_PAIN ) { // TinMan: *cheaphack* work around due to fack heardsound is being shoehorned into something it's not desiged to handle - multiple players\n"
           "\t\t\t\t\t\tnewEnemy = lookForEnemies( false );\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t\tif ( newEnemy ) {\n"
           "\t\t\t\t\t\tif ( body.distanceTo( newEnemy ) < enemyRange() ) { // TinMan: Closer than the chump I'm hunting.\n"
           "\t\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY_SOUND; // TinMan: Set react timer.\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tif ( reactToEnemy < sys.getTime() ) {\n"
           "\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\t\t\n"
           "\t\tcheckWeapon();\n"
           "\t} // TinMan: End eachFrame/state\n"
           "\t\n"
           "\t// TinMan: Exit state\n"
           "\tif ( newEnemy ) { // TinMan: *cheaphack* Fix the loosing enemy due to reactiontime and state change *todo* rethink\n"
           "\t\tsetEnemy( newEnemy );\n"
           "\t}\n"
           "\t\n"
           "\tif ( getEnemy() ) {\n"
           "\t\tsetState( \"state_Combat\" );\n"
           "\t} else {\n"
           "\t\tsetState( \"state_Idle\" );\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::state_Hold\n"
           "TinMan: Hold position - Aka camp.\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot_a8::state_Hold() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Hold]\" ); // TinMan *debug*\n"
           "\tfloat nextSubGoalLook;\n"
           "\tvector movePosition;\n"
           "\tentity newEnemy;\n"
           "\tfloat reactToEnemy;\n"
           "\n"
           "\treactToEnemy = 0;\n"
           "\n"
           "\tstopMove(); // TinMan: *note* All states should handle movement to that goal, if it doesn't do a move command at start then stopMove previous movement.\n"
           "\t\n"
           "\tsetTimer( SABOT_HOLD_TIME ); // TinMan: Start timer if we don't want to wait forever\n"
           "\t\n"
           "\teachFrame {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + getName() + \"][state_Hold][\" + goal.getName() + \"]\" ); // TinMan *debug*\n"
           "\t\t\n"
           "\t\t// TinMan: Lookin for trouble with a big T.\n"
           "\t\tif ( !reactToEnemy ) {\n"
           "\t\t\tif ( nextEnemyLook() || AI_PAIN || AI_ENEMY_VISIBLE ) {\n"
           "\t\t\t\tif ( AI_ENEMY_VISIBLE ) {\n"
           "\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY; // TinMan: Set react timer.\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\tnewEnemy = lookForEnemies( true );\n"
           "\t\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY; // TinMan: Set react timer.\n"
           "\t\t\t\t\t} else {\n"
           "\t\t\t\t\t\t// TinMan: Shh, I hear something.\n"
           "\t\t\t\t\t\tnewEnemy = listenForEnemies();\n"
           "\t\t\t\t\t\tif ( !newEnemy && AI_PAIN ) { // TinMan: *cheaphack* work around due to fack heardsound is being shoehorned into something it's not desiged to handle - multiple players\n"
           "\t\t\t\t\t\t\tnewEnemy = lookForEnemies( false );\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t\tif ( newEnemy ) {\n"
           "\t\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY_SOUND; // TinMan: Set react timer.\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tif ( reactToEnemy < sys.getTime() ) {\n"
           "\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\n"
           "\t\t// TinMan: What are we waiting for?\t\t\n"
           "\t\tif ( gameType == GAME_CTF ) {\n"
           "\t\t\t/*\n"
           "\t\t\tif ( goal == ourCap ) {\n"
           "\t\t\t\tif ( getFlagStatus( team ) == FLAGSTATUS_INBASE ) {\n"
           "\t\t\t\t\tif ( body.distanceToPoint( goal.getOrigin() ) > 32 ) {\n"
           "\t\t\t\t\t\tgoalType = SABOT_GOAL_MOVE;\n"
           "\t\t\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t} else if ( goal == theirCap ) {\n"
           "\t\t\t\tif ( getFlagStatus( team ) == FLAGSTATUS_INBASE ) {\n"
           "\t\t\t\t\tif ( body.distanceToPoint( goal.getOrigin() ) > 32 ) {\n"
           "\t\t\t\t\t\tgoalType = SABOT_GOAL_MOVE;\n"
           "\t\t\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\t\t\t\t\n"
           "\t\t\t}\n"
           "\t\t\t*/\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: *cheaphack* look somewhere usefull (hopefully), better would be to do a quick predict towards theircap and look there.\n"
           "\t\t\tvector lookDir, capPos;\n"
           "\t\t\tif ( goal == ourCap ) {\n"
           "\t\t\t\tcapPos = theirCap.getOrigin();;\n"
           "\t\t\t} else if ( goal == theirCap ) {\n"
           "\t\t\t\tcapPos = ourCap.getOrigin();\n"
           "\t\t\t}\n"
           "\t\t\tlookDir = capPos - body.getOrigin();\n"
           "\t\t\tlookDir_z = 0;\n"
           "\t\t\tsetAimDirection( lookDir );\n"
           "\t\t\t\n"
           "\t\t\tif ( gotFlag() ) { // TinMan: *cheaphack* got flag?\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + getName() + \"][state_Hold][\" + goal.getName() + \"]\" ); // TinMan *debug*\n"
           "\t\t\t\tclearGoal();\n"
           "\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: We only hold for a certain amount of time in ctf\n"
           "\t\t\tif ( getTimer() ) {\n"
           "\t\t\t\t// sys.println( \"[\" + int( sys.getTime() ) + \"][state_Hold][HoldTime Up]\" ); // TinMan: *debug*\n"
           "\t\t\t\tclearTimer();\n"
           "\t\t\t\tclearGoal();\n"
           "\t\t\t\tbreak; // TinMan: Exit state\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t/* TinMan: *todo* rejigger\n"
           "\t\t// TinMan: Look for other items to grab\n"
           "\t\tif ( sys.getTime() > nextSubGoalLook ) {\n"
           "\t\t\tnextSubGoalLook = sys.getTime() + SABOT_NEXT_SUBGOAL_LOOK;\n"
           "\t\t\tsubGoal = lookForGoal( 10, false );\n"
           "\t\t\tif ( subGoal ) {\n"
           "\t\t\t\twaitFrame();\n"
           "\t\t\t\tif ( newEnemy ) { // TinMan: *cheaphack*\n"
           "\t\t\t\t\tsetEnemy( newEnemy );\n"
           "\t\t\t\t}\n"
           "\t\t\t\tsetState( \"state_SubGoal\" );\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t*/\n"
           "\t\n"
           "\t\t// TinMan: Move to hold position if too far away\n"
           "\t\tif ( body.distanceToPoint( goalPosition ) > 128 ) {\n"
           "\t\t\t//goalType = SABOT_GOAL_MOVE; // TinMan: Once the bot reaches the hold goal via movetogoal, the choosegoal will probably set goal back to hold. *todo* really need a stack\n"
           "\t\t\t//break; // TinMan: Exit state\n"
           "\t\t\tsetState( \"state_MoveToGoal\" );\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tcheckWeapon(); // TinMan: Make sure your weapon is nice and shiny\n"
           "\t} // TinMan: End eachFrame/state\n"
           "\t\n"
           "\t// TinMan: Exit state\n"
           "\tif ( newEnemy ) { // TinMan: *cheaphack* Fix the loosing enemy due to reactiontime and state change *todo* rethink\n"
           "\t\tsetEnemy( newEnemy );\n"
           "\t}\n"
           "\t\n"
           "\tif ( getEnemy() ) {\n"
           "\t\tsetState( \"state_Combat\" );\n"
           "\t} else {\n"
           "\t\tsetState( \"state_Idle\" );\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::state_Follow\n"
           "TinMan: Follow teammate.\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot_a8::state_Follow() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Follow]\" ); // TinMan *debug*\n"
           "\tvector movePosition;\n"
           "\tvector aimDir;\n"
           "\tfloat nextGoalLook;\n"
           "\tentity leader;\n"
           "\tentity newEnemy;\n"
           "\tfloat reactToEnemy;\n"
           "\n"
           "\treactToEnemy = 0;\n"
           "\t\n"
           "\tif ( !goal ) {\n"
           "\t\tsetState( \"state_Idle\" );\n"
           "\t}\n"
           "\t\n"
           "\tleader = goal;\n"
           "\t\n"
           "\tsetMoveToPosition( goal.getOrigin() );\n"
           "\n"
           "\teachFrame {\n"
           "\t\tif ( checkLeader( leader ) || !leader ) { // TinMan: See if we should still go for it\n"
           "\t\t\tsetState( \"state_Idle\" );\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Lookin for trouble with a big T.\n"
           "\t\tif ( !reactToEnemy ) {\n"
           "\t\t\tif ( nextEnemyLook() || AI_PAIN && !getEnemy() ) {\n"
           "\t\t\t\tnewEnemy = lookForEnemies( true );\n"
           "\t\t\t\tif ( newEnemy ) { // TinMan: We have a new challenger\n"
           "\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY; // TinMan: Set react timer.\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\t// TinMan: Shh, I hear something.\n"
           "\t\t\t\t\tnewEnemy = listenForEnemies();\n"
           "\t\t\t\t\tif ( !newEnemy && AI_PAIN ) { // TinMan: *cheaphack* work around due to fack heardsound is being shoehorned into something it's not desiged to handle - multiple players\n"
           "\t\t\t\t\t\tnewEnemy = lookForEnemies( false );\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t\tif ( newEnemy ) {\n"
           "\t\t\t\t\t\treactToEnemy = sys.getTime() + SABOT_REACT_TO_ENEMY_SOUND; // TinMan: Set react timer.\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tif ( reactToEnemy < sys.getTime() ) {\n"
           "\t\t\t\tsetEnemy( newEnemy );\n"
           "\t\t\t\t//setState( \"state_Combat\" );\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t/* *todo* rejigger\n"
           "\t\t// TinMan: Look for other items to grab on the way\n"
           "\t\tif ( sys.getTime() > nextGoalLook ) {\n"
           "\t\t\tnextGoalLook = sys.getTime() + SABOT_NEXT_GOAL_LOOK;\n"
           "\t\t\tsubGoal = lookForGoal( true, false );\n"
           "\t\t\tif ( subGoal ) {\n"
           "\t\t\t\t// TinMan: Don't want to go after items that are out of the way. Unless the bot needs excersise.\n"
           "\t\t\t\t//if ( travelDistanceBetweenEntities( goal, subGoal ) < travelDistanceToEntity( goal ) + 192 ) { // TinMan: *todo* tweak buffer *todo* these funcs are expensive, can you grab current travel distance for current route, I seem to remember it being set somewhere\n"
           "\t\t\t\t\twaitFrame();\n"
           "\t\t\t\t\tsetState( \"state_SubGoal\" );\n"
           "\t\t\t\t//}\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t*/\n"
           "\t\t\n"
           "\t\tsetMoveToPosition( leader.getOrigin() ); // TinMan: Diferent from other states, our goal, the leader is on the move\n"
           "\t\t\n"
           "\t\t// TinMan: The actual following\n"
           "\t\tif  ( body.distanceTo( leader ) < SABOT_FOLLOWDIST_MIN ) {\n"
           "\t\t\t//setAimPosition( getAIAimTargets( leader, true ) );\n"
           "\t\t\tstopMove();\n"
           "\t\t} else if ( body.distanceTo( leader ) > SABOT_FOLLOWDIST_MAX ) {\n"
           "\t\t\t// TinMan: Move along given path\n"
           "\t\t\tmovePosition = moveAction();\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: Lookee where we damn be going.\n"
           "\t\t\t//movePosition = getMovePosition(); // TinMan: expensive\n"
           "\t\t\tif ( AI_ONGROUND && movePosition != body.getOrigin() ) {\n"
           "\t\t\t\taimDir = movePosition - body.getOrigin();\n"
           "\t\t\t\tsetAimDirection( aimDir );\n"
           "\t\t\t}\t\t\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tcheckBlocked();\n"
           "\t\t\n"
           "\t\tif ( checkShot( true ) ) {\n"
           "\t\t\tAI_WEAPON_FIRE = true;\n"
           "\t\t}\n"
           "\n"
           "\t\tcheckWeapon(); // TinMan: Make sure your weapon is nice and shiny\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::state_Killed\n"
           "TinMan: botAi hijacks script when bots fakeclient is AI_DEAD, sets state to this.\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot_a8::state_Killed() {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][Died]\" ); // TinMan: *debug*\n"
           "\n"
           "\tstopMove();\n"
           "\t\n"
           "\twhile( AI_DEAD ) {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][state_Killed][waiting]\" ); // TinMan: *debug*\n"
           "\t\t\n"
           "\t\tfloat nextFire;\n"
           "\t\tif ( sys.getTime() > nextFire ) {\n"
           "\t\t\tnextFire = sys.getTime() + 0.1;\n"
           "\t\t\tAI_WEAPON_FIRE = true; // TinMan: Fire so bot respawns\n"
           "\t\t}\n"
           "\t\twaitFrame();\n"
           "\t}\n"
           "\t\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + me + \"][Restarting]\" ); // TinMan: *debug*\n"
           "\tsetState( \"state_Begin\" );\n"
           "}\n"
           "\n"
           "\n"
           "/***********************************************************************\n"
           "\n"
           "\tFunctions\n"
           "\n"
           "***********************************************************************/\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::setNewGoal\n"
           "TinMan: *todo* complete\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot_a8::setNewGoal() {\n"
           "\tgoalType = newGoalType;\n"
           "\tmoveType = newMoveType;\n"
           "\tgoal = newGoal;\n"
           "\tgoalPosition = newGoalPosition;\n"
           "\tgoalPriority = newGoalPriority;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::clearGoal\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot_a8::clearGoal() {\n"
           "\tif ( goal ) {\n"
           "\t\toldGoal = goal;\n"
           "\t}\n"
           "\t\n"
           "\tgoalType = 0;\n"
           "\tmoveType = 0;\n"
           "\tgoal = $null_entity;\n"
           "\tgoalPosition = '0 0 0'; // TinMan: *todo* hmm how do you null a vector?\n"
           "\tgoalPriority = 0;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::clearNewGoal\n"
           "TinMan: *todo* complete\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot_a8::clearNewGoal() {\n"
           "\tnewGoalType = 0;\n"
           "\tnewMoveType = 0;\n"
           "\tnewGoal = $null_entity;\n"
           "\tnewGoalPosition = '0 0 0'; // TinMan: *todo* hmm how do you null a vector?\n"
           "\tnewGoalPriority = 0;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::moveForward\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot_a8::moveForward() {\n"
           "\tAI_FORWARD = true;\n"
           "\tAI_BACKWARD = false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::moveBackward\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot_a8::moveBackward() {\n"
           "\tAI_BACKWARD = true;\n"
           "\tAI_FORWARD = false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::moveRight\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot_a8::moveRight() {\n"
           "\tAI_STRAFE_RIGHT = true;\n"
           "\tAI_STRAFE_LEFT = false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::moveLeft\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot_a8::moveLeft() {\n"
           "\tAI_STRAFE_LEFT = true;\n"
           "\tAI_STRAFE_RIGHT = false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::moveAction\n"
           "TinMan: Folow path given by routing, check and do more complex navigation actions: Jumps, elevators \n"
           "*todo* Rough as guts, should be moved into botAi and overhauled.\n"
           "Note: pathtype is allways ored against pathtype_walk which is enum 0 so doing equality tests is fine.\n"
           "=====================\n"
           "*/\n"
           "vector bot_sabot_a8::moveAction() {\n"
           "\tfloat pathType;\n"
           "\tvector movePosition, secondaryMovePosition, bodyOrigin, moveDir, velocity;\n"
           "\tfloat dist, moveSpeed;\n"
           "\t\n"
           "\tentity plat;\n"
           "\tfloat i, numListedEntities, radius;\n"
           "\tvector platOrigin, platStart, platBottom;\n"
           "\tvector waitPos;\n"
           "\tradius = 256;\n"
           "\t\n"
           "\tmovePosition = getMovePosition(); // TinMan: expensive\n"
           "\t\n"
           "\tif ( AI_MOVE_DONE || AI_DEST_UNREACHABLE ) {\n"
           "\t\treturn movePosition;\n"
           "\t}\n"
           "\t\n"
           "\tpathType = getPathType();\n"
           "\t\n"
           "\tvelocity = body.getLinearVelocity();\n"
           "\tbodyOrigin = body.getOrigin();\n"
           "\t\n"
           "\t// TinMan: *test* don't strafe on complicated paths\n"
           "\tif ( pathType != PATHTYPE_WALK ) {\n"
           "\t\tAI_STRAFE_RIGHT = false;\n"
           "\t\tAI_STRAFE_LEFT = false;\n"
           "\t}\n"
           "\t\n"
           "\t// reset the topOfPlat reach memory when it has a value and we are no longer using a plat\n"
           "\tif ( pathType != PATHTYPE_ELEVATOR && platTop != '0 0 0' ) {\n"
           "\t\t//sys.println( \"re setting topOfPlat\" ); // TinMan *debug*\n"
           "\t\tplatTop = '0 0 0';\n"
           "\t\tplat = $null_entity;\n"
           "\t}\n"
           "\t\n"
           "\t//sys.debugBounds( '1 1 0', movePosition + '-1 -1 -1', movePosition + '1 1 1' , 0.01 ); // TinMan: *debug*\n"
           "\t\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_MoveToGoal][PATHTYPE: \" + getPathType() + \"]\" ); // TinMan *debug*\n"
           "\tif ( pathType == PATHTYPE_WALK ) {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_MoveToGoal][PATHTYPE_WALK]\" ); // TinMan *debug*\n"
           "\t\t\t\n"
           "\t\t// TinMan: Do actual movement\n"
           "\t\tmoveDir = movePosition - bodyOrigin;\n"
           "\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\n"
           "\t\tdist = sys.vecLength( moveDir );\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][dist: \" + dist + \"]\" ); // TinMan *debug*\n"
           "\t\t// TinMan: This code is a complete nasty mess at the moment. The problem being caused by an area under a platform. A bot chasing a player as he hits the platform will get a walk path to the area under the platform, if the platfor rises the bot could move under the platform. The path doesn't seem to fail or be done despite ai_debugmove showing bot trying to move to top of elevator ( which in a walk path he can't )\n"
           "\t\tif ( dist < 128 ) { // TinMan: Getting close\n"
           "\t\t\t//float pong = movePosition_z  - bodyOrigin_z;\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][ping][pong: \" + pong + \"]\" ); // TinMan *debug*\n"
           "\t\t\t//if ( movePosition_z - bodyOrigin_z > 16 ) { // TinMan: At moveposition but it's above bots head. stupid *todo* hmm, moveposition still seems to be at ground so this won't work.\n"
           "\t\t\t\t// TinMan: See if it's the plat weirdness *todo* shift this to checkblocked?\n"
           "\t\t\t\tnumListedEntities = findInRadius( movePosition, radius, \"idPlat\" );\n"
           "\t\t\t\t/* if ( numListedEntities > 1 ) {\n"
           "\t\t\t\t\tsys.warning( \"[\" + int( sys.getTime() ) + \"][moveAction][More than 1 plat]\" ); // TinMan *debug*\n"
           "\t\t\t\t\t// TinMan: *todo* get closest\n"
           "\t\t\t\t} */\n"
           "\t\t\t\tfor ( i = 0; i < numListedEntities; i++ ) {\n"
           "\t\t\t\t\tplat = getEntityList( i );\n"
           "\t\t\t\t}\n"
           "\t\t\t\tif ( plat ) {\n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][Found plat]\" ); // TinMan *debug*\n"
           "\t\t\t\t\tplatOrigin = plat.getOrigin();\n"
           "\t\t\t\t\tplatStart = plat.getVectorKey( \"origin\" ); // TinMan: Grab spawn origin - the plats starting origin - the top\n"
           "\t\t\t\t\tplatBottom = platStart;\n"
           "\t\t\t\t\tplatBottom_z -= plat.getFloatKey( \"height\" );\n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][platOrigin z: \" + platOrigin_z + \"][platOrigin z: \" + platStart_z + \"]\" ); // TinMan *debug* *todo* why isn't origin updated?\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t\t//sys.debugBounds( '1 0 0', platOrigin + plat.getMins(), platOrigin + plat.getMaxs() , 1 ); // TinMan: *debug* \n"
           "\t\t\t\t\tif ( platOrigin_z > platBottom_z + 32 && isUnderPlat( plat ) ) { // TinMan: Plat above?\n"
           "\t\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][under plat!]\" ); // TinMan *debug* *todo* why isn't origin updated?\n"
           "\t\t\t\t\t\twaitPos = getWaitPosition( plat );\n"
           "\t\t\t\t\t\tmoveDir = waitPos - bodyOrigin;\n"
           "\t\t\t\t\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\t\t\t\tdist = sys.vecLength( moveDir );\n"
           "\t\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][dist to waitpos:\" + dist + \"]\" ); // TinMan *debug*\n"
           "\t\t\t\t\t\tif ( dist > 8 ) {\n"
           "\t\t\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][path_walk: move to waitpos]\" ); // TinMan *debug*\n"
           "\t\t\t\t\t\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t\t\t\t\t}\n"
           "\t\t\t\t\t} else {\n"
           "\t\t\t\t\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t\t\t\t }\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t\t\t}\n"
           "\t\t\t//}\n"
           "\t\t} else {\n"
           "\t\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t}\n"
           "\t\t//moveForward();\n"
           "\t\t\n"
           "\t\t//checkBlocked();\n"
           "\t//} else if ( getPathType() & PATHTYPE_WALKOFFLEDGE ) {\n"
           "\t\t\n"
           "\t} else if ( pathType & PATHTYPE_BARRIERJUMP ) {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][PATHTYPE_BARRIERJUMP]\" ); // TinMan *debug*\n"
           "\t\t//sys.debugBounds( '1 0 0', getSecondaryMovePosition() + '-1 -1 -1', getSecondaryMovePosition() + '1 1 1' , 0.01 ); // TinMan: *debug* show bound secondarypos\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][LinearVelocity:\" + body.getLinearVelocity() + \"][vecLength:\" + sys.vecLength( body.getLinearVelocity() ) + \"]\" ); // TinMan *debug*\n"
           "\t\tif ( body.distanceToPoint( movePosition ) < 8 ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][close to moveposition]\" ); // TinMan *debug*\n"
           "\t\t\t\t\n"
           "\t\t\t// TinMan: Ping a vector from self through jump end (which will be directly above jump start position)\n"
           "\t\t\t//secondaryMovePosition = getSecondaryMovePosition();\n"
           "\n"
           "\t\t\t//moveDir = movePosition - bodyOrigin;\n"
           "\t\t\t//moveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\t//movePosition = moveDir * 2048;\n"
           "\t\t\t//movePosition_z = bodyOrigin_z + viewHeight;\n"
           "\t\t\t//sys.debugBounds( '0 1 0', movePosition + '-1 -1 -1', movePosition + '1 1 1' , 0.01 ); // TinMan: *debug* show bound secondarypos\n"
           "\t\t\t//setAimPosition( movePosition );\n"
           "\t\t\t\t\n"
           "\t\t\t//moveForward();\n"
           "\t\t\tAI_JUMP = true;\n"
           "\t\t\t//AI_JUMP = !AI_JUMP;\n"
           "\t\t} else if ( AI_ONGROUND ) { // TinMan: Move to jump position *todo* need propper check to indicate we aren't interested in reach start but reach end.\n"
           "\t\t\t// TinMan: Do actual movement\n"
           "\t\t\tmoveDir = movePosition - bodyOrigin;\n"
           "\t\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\t\n"
           "\t\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t\t//moveForward();\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][vertical vel: \" + velocity_z + \"]\" ); // TinMan *debug*\n"
           "\t\t\n"
           "\t\t// TinMan: Going down\n"
           "\t\tif ( velocity_z < 250 /*&& !AI_ONGROUND*/ ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][falling]\" ); // TinMan *debug*\n"
           "\t\t\t//moveForward();\n"
           "\t\t\t\t\n"
           "\t\t\t// TinMan: While it's more propper to use secondarypos, since in this case the reach end is right above reach start there isn't much of a difference, movepos even seems to be working a little better, haven't looked into why.\n"
           "\t\t\t//secondaryMovePosition = getSecondaryMovePosition();\n"
           "\t\t\t//moveDir = secondaryMovePosition - bodyOrigin;\n"
           "\t\t\tmoveDir = movePosition - bodyOrigin;\n"
           "\t\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\t\t\n"
           "\t\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t}\n"
           "\t\n"
           "\t} else if ( pathType & PATHTYPE_ELEVATOR ) {\n"
           "\t\t// set the topOfPlat the first time we hit elevator and it isn't set (this is valid top from WalkPathToGoal)\n"
           "\t\tif ( platTop == '0 0 0' ) {\n"
           "\t\t\tplatTop = getSecondaryMovePosition();\n"
           "\t\t} \n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][PATHTYPE_ELEVATOR]\" ); // TinMan *debug*\n"
           "\t\t\n"
           "\t\t//secondaryMovePosition = getSecondaryMovePosition();\n"
           "\t\t//sys.debugBounds( '0 0 1', movePosition + '-4 -4 -4', movePosition + '4 4 4' , 10 ); // TinMan: *debug*\n"
           "\t\t//sys.debugBounds( '0.5 0 1', secondaryMovePosition + '-4 -4 -4', secondaryMovePosition + '4 4 4' , 10 ); // TinMan: *debug*\n"
           "\t\t\t\n"
           "\t\t// TinMan: *todo* so damn crude, better to just go through all plats and find closest to bot?\n"
           "\t\tnumListedEntities = findInRadius( bodyOrigin, radius, \"idPlat\" );\n"
           "\t\t//numListedEntities = findInRadius( movePosition, radius, \"idPlat\" );\n"
           "\t\t/*if ( !numListedEntities ) {\n"
           "\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][spang!]\" ); // TinMan *debug*\n"
           "\t\t\tnumListedEntities = findInRadius( secondaryMovePosition, radius, \"idPlat\" );\n"
           "\t\t}\n"
           "\t\t*/\n"
           "\t\t/*if ( !numListedEntities ) {\n"
           "\t\t\tnumListedEntities = findInRadius( bodyOrigin, radius, \"idPlat\" );\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][why bobo why!]\" ); // TinMan *debug*\n"
           "\t\t}*/\n"
           "\t\t\n"
           "\t\t/*\n"
           "\t\tif ( numListedEntities > 1 ) {\n"
           "\t\t\tsys.warning( \"[\" + int( sys.getTime() ) + \"][moveAction][More than 1 plat]\" ); // TinMan *debug*\n"
           "\t\t\t// TinMan: *todo* get closest\n"
           "\t\t}\n"
           "\t\t*/\n"
           "\t\tfor ( i = 0; i < numListedEntities; i++ ) {\n"
           "\t\t\tplat = getEntityList( i );\n"
           "\t\t}\n"
           "\t\tif ( plat ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][Found plat]\" ); // TinMan *debug*\n"
           "\t\t\tplatOrigin = plat.getOrigin();\n"
           "\t\t\tplatStart = plat.getVectorKey( \"origin\" ); // TinMan: Grab spawn origin - the plats starting origin - the top\n"
           "\t\t\tplatBottom = platStart;\n"
           "\t\t\tplatBottom_z -= plat.getFloatKey( \"height\" );\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][platOrigin z: \" + platOrigin_z + \"][platOrigin z: \" + platStart_z + \"]\" ); // TinMan *debug* *todo* why isn't origin updated?\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tif ( body.touches( plat ) && platOrigin_z <= bodyOrigin_z ) { // TinMan: On plat (not under)\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][On plat][platOrigin z: \" + platStart_z + \"][platOrigin z: \" + platStart_z + \"]\" ); // TinMan *debug*\n"
           "\t\t\tif ( platOrigin_z >= platStart_z - 24 ) { // TinMan: Plat near top. 18 = stepheight\n"
           "\t\t\t\t// TinMan: Move to end point\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][On plat: Move to end]\" ); // TinMan *debug*\n"
           "\t\t\t\t//moveDir = movePosition - bodyOrigin;\n"
           "\t\t\t\tmoveDir = platTop - bodyOrigin;\n"
           "\t\t\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t\t\t\n"
           "\t\t\t\tmovePosition = platTop;\n"
           "\t\t\t} else {\n"
           "\t\t\t\t// TinMan: Move to middle of plat\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][On plat: Move to center]\" ); // TinMan *debug*\n"
           "\t\t\t\tmoveDir = platBottom - bodyOrigin;\n"
           "\t\t\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\t\tdist = sys.vecLength( moveDir );\n"
           "\t\t\t\tif ( dist > 4 ) { \n"
           "\t\t\t\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t\t\t}\n"
           "\t\t\t\t\n"
           "\t\t\t\t//movePosition = platBottom;\n"
           "\t\t\t}\n"
           "\t\t} else if ( plat ) { // TinMan: Not on plat\n"
           "\t\t\t// TinMan: Move to plat\n"
           "\t\t\tmoveDir = movePosition - bodyOrigin;\n"
           "\t\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\tdist = sys.vecLength( moveDir );\n"
           "\t\t\tif ( platOrigin_z < platBottom_z + 18 ) { // TinMan: plat at bottom \n"
           "\t\t\t\tif ( dist > 32 ) { \n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][move reach start]\" ); // TinMan *debug*\n"
           "\t\t\t\t\tsetMoveDirection( moveDir, 400 ); // TinMan: Move to reach start\n"
           "\t\t\t\t} else { // TinMan: else close to reach\n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][move plat center]\" ); // TinMan *debug*\n"
           "\t\t\t\t\t// TinMan: Move to middle of plat\n"
           "\t\t\t\t\tmoveDir = platBottom - bodyOrigin;\n"
           "\t\t\t\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\t\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t\t//movePosition = platBottom;\n"
           "\t\t\t\t}\n"
           "\t\t\t} else {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][plat not at bottom: move reach start]\" ); // TinMan *debug*\n"
           "\t\t\t\tif ( isUnderPlat( plat ) ) { // TinMan: Plat above?\n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][under plat!]\" ); // TinMan *debug* *todo* why isn't origin updated?\n"
           "\t\t\t\t\twaitPos = getWaitPosition( plat );\n"
           "\t\t\t\t\tmoveDir = waitPos - bodyOrigin;\n"
           "\t\t\t\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\t\t\tdist = sys.vecLength( moveDir );\n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][dist to waitpos:\" + dist + \"]\" ); // TinMan *debug*\n"
           "\t\t\t\t\tif ( dist > 8 ) {\n"
           "\t\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][path_elev: move to waitpos]\" ); // TinMan *debug*\n"
           "\t\t\t\t\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t\t//movePosition = waitPos;\n"
           "\t\t\t\t} /*else {\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t}*/\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t} else if ( !plat ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][!plat]\" ); // TinMan *debug*\t\n"
           "\t\t\t//sys.debugBounds( '1 0 0', movePosition + '-4 -4 -4', movePosition + '4 4 4' , 10 ); // TinMan: *debug*\n"
           "\t\t\tmoveDir = movePosition - bodyOrigin;\n"
           "\t\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t//sys.debugBounds( '1 0 0', platStart + '-1 -1 -1', platStart + '1 1 1' , 1000 ); // TinMan: *debug*\n"
           "\t\t//sys.debugBounds( '1 1 0', platBottom + '-1 -1 -1', platBottom + '1 1 1' , 1000 ); // TinMan: *debug*\n"
           "\t\t\n"
           "\t} else { // TinMan: Unknown pathtype\n"
           "\t\t// TinMan: Have a bash at it anyway\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][moveAction][Unhandled pathtype: \" + getPathType() + \"]\" ); // TinMan *debug*\n"
           "\t\t\n"
           "\t\t// TinMan: Do actual movement\n"
           "\t\tmoveDir = movePosition - bodyOrigin;\n"
           "\t\tmoveDir_z = 0; // TinMan: Only horizontal\n"
           "\t\tsetMoveDirection( moveDir, 400 );\n"
           "\t\t\n"
           "\t\t//checkBlocked();\n"
           "\t}\n"
           "\t\n"
           "\treturn movePosition;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::setTimer\n"
           "TinMan: I am the very model of a modern major general\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot_a8::setTimer( float endTime ) {\n"
           "\t//timerAmount = time;\n"
           "\t//timerStart = sys.getTime();\n"
           "\ttimerEnd = sys.getTime() + endTime;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::getTimer\n"
           "TinMan: the bell, the bells\n"
           "=====================\n"
           "*/\n"
           "float bot_sabot_a8::getTimer() {\n"
           "\tif ( timerEnd == -1 ) { // TinMan: Timer not set\n"
           "\t\t//return -1;\n"
           "\t\treturn false;\n"
           "\t} else if ( timerEnd < sys.getTime() ) { // TinMan: Timer over\n"
           "\t\t// TinMan: *todo* return Elapsed time\n"
           "\t\t//clearTimer(); // TinMan: Reset timer now it's over, since sometimes you'll be checking if theres a timer set `*todo* rethink this\n"
           "\t\treturn true; \n"
           "\t} else { // TinMan: Timer still going\n"
           "\t\t// TinMan: *todo* return Elapsed time\n"
           "\t\treturn false; \n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::clearTimer\n"
           "TinMan: car button cloth\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot_a8::clearTimer() {\n"
           "\ttimerEnd = -1;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::nextEnemyLook\n"
           "TinMan: Timer\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot_a8::nextEnemyLook() {\n"
           "\tif ( sys.getTime() > nextEnemyLookTime ) {\n"
           "\t\tnextEnemyLookTime = sys.getTime() + SABOT_NEXT_ENEMY_LOOK;\n"
           "\t\treturn true;\n"
           "\t}\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/***********************************************************************\n"
           "\n"
           "\tChecks\n"
           "\n"
           "***********************************************************************/\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::checkGoal\n"
           "TinMan: See if we still want this goal, bumps off goal if it's old and mankey, or if we just want to rechoose goal.\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot_a8::checkGoal() {\n"
           "\tvector origin, goalOrigin;\n"
           "\tfloat goalDist;\n"
           "\n"
           "\tif ( moveType == SABOT_GOALTYPE_ENTITY ) {\n"
           "\t\tif ( !goal ) {\n"
           "\t\t\treturn true;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tgoalDist = body.distanceTo( goal );\n"
           "\n"
           "\t\tif ( goalDist < 128 ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][checkGoal][close, checking]\" ); // TinMan *debug*\n"
           "\t\t\n"
           "\t\t\tif ( goal.isHidden() ) {\n"
           "\t\t\t\treturn true;\n"
           "\t\t\t} else if ( body.touches( goal ) ) {\n"
           "\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][checkGoal][touched goal]\" ); // TinMan *debug*\n"
           "\t\t\t\treturn true;\n"
           "\t\t\t} else if ( goalDist < 4 ) {\n"
           "\t\t\t\treturn true;\n"
           "\t\t\t}\t\n"
           "\t\t}\n"
           "\t} else { // TinMan: SABOT_GOALTYPE_POSITION\n"
           "\t\tgoalDist = body.distanceToPoint( goalPosition );\n"
           "\t\tif ( goalDist < 4 ) {\n"
           "\t\t\treturn true;\n"
           "\t\t}\t\n"
           "\t}\n"
           "\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::gotFlag\n"
           "TinMan: *cheaphack* a fix untill single goal/priority is sorted\n"
           "*todo* expand into more general flag checking?\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot_a8::gotFlag() {\n"
           "\tif ( getFlagCarrier( team ) == body ) {\n"
           "\t\t// TinMan: Did we get flag somehow? If so dump goal and go to idle where chooseGoal will sort it out.\n"
           "\t\tif ( goal != ourCap ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_hold][!have flag!]\" ); // TinMan *debug*\n"
           "\t\t\treturn true;\n"
           "\t\t}\n"
           "\t}\n"
           "\t\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::checkEnemy\n"
           "TinMan: See if we still want to fight this enemy.\n"
           "TinMan: *todo* no magic numbers, set em up and tweak em.\n"
           "*todo* *rem* outdated\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot_a8::checkEnemy( entity thisEnemy ) {\n"
           "\tfloat selfPriority, enemyPriority;\n"
           "\t\n"
           "\t/*\n"
           "\tif ( !getEnemy() ) {\n"
           "\t\treturn true;\n"
           "\t}\n"
           "\t*/\n"
           "\t\n"
           "\tif ( AI_ENEMY_VISIBLE ) {\n"
           "\t\tenemyPriority = getPlayerPriority( thisEnemy );\n"
           "\t\tselfPriority = getPlayerPriority( body ) + 30;  // TinMan: *todo* fool! no magic number\n"
           "\t\t// TinMan: Enemy too badass for me! I ph34r him!\n"
           "\t\tif ( enemyPriority > selfPriority ) {\n"
           "\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][checkEnemy][Enemy too badass for me! I ph34r him!]\" ); // TinMan *debug* \" : \" + getClassName( item ) +\n"
           "\t\t\treturn true;\n"
           "\t\t} /* else if ( selfPriority < 50 ) { // TinMan: *todo* fool! no magic number\n"
           "\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][checkEnemy][Self Priority too low]\" ); // TinMan *debug* \" : \" + getClassName( item ) +\n"
           "\t\t\treturn true;\n"
           "\t\t} */\n"
           "\t}\n"
           "\t\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::checkSelf\n"
           "TinMan: See if you are happy with your weapon/hp/armor. Returns true if not happy happy joy joy.\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot_a8::checkSelf() {\n"
           "\tfloat weaponPriority;\n"
           "\n"
           "\tweaponPriority = getFloatKey( \"priority_\" + currentWeapon ); // TinMan: Grab priority from def\n"
           "\t\n"
           "\tif ( weaponPriority <= 3 && getActorHealth( body ) + getArmor( body ) < 40 ) { // TinMan: better weapon than pistol *todo* demagic happystrenght\n"
           "\t\treturn true;\n"
           "\t}\n"
           "\t\n"
           "\tif ( weaponPriority < 40 && getActorHealth( body ) + getArmor( body ) <= 20 && !AI_PAIN ) { // TinMan: Weapon < chaingun and very beat up, if your allready getting hurt you're probably going to die anyway\n"
           "\t\treturn true;\n"
           "\t}\n"
           "\t\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::checkLeader\n"
           "TinMan: \n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot_a8::checkLeader( entity thisLeader ) {\n"
           "\tif ( !thisLeader ) {\n"
           "\t\treturn true;\n"
           "\t}\n"
           "\n"
           "\tif ( getActorHealth( thisLeader ) <= 0 ) {\n"
           "\t\treturn true;\n"
           "\t}\n"
           "\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::checkWeapon\n"
           "TinMan: Make sure your weapon is in order\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot_a8::checkWeapon() {\n"
           "\tentity enemy;\n"
           "\tstring weaponName;\n"
           "\t\n"
           "\t/*\n"
           "\tif ( getEnemy() ) {\n"
           "\t\tchooseWeapon( enemyRange() );\t\n"
           "\t} else {\n"
           "\t\tchooseWeapon( -1 );\t\n"
           "\t}\n"
           "\t*/\n"
           "\t\n"
           "\t//nextBestWeapon();\n"
           "\tchooseWeapon( 1 );\n"
           "\t\n"
           "\t// TinMan: Unless you can be sure weapon only changes in above function (eg no auto switch or empty weapon switch ) you'll have to chack and update weapon stuff here\n"
           "\tweaponName = body.getCurrentWeapon();\n"
           "\tif ( weaponName != currentWeapon ) {\n"
           "\t\tcurrentWeapon = weaponName;\t\n"
           "\t\tweaponRange = getVectorKey( \"range_\" + currentWeapon ); // TinMan: Grab ranges from def\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][checkweapon][currentWeapon: \" + currentWeapon + \"][weaponrange: \" + weaponRange + \"]\" ); // TinMan *debug*\n"
           "\t}\n"
           "\n"
           "\t// TinMan: Autoload only works on next fire after empty (I may be mistaken)\n"
           "\tif ( weapon.ammoInClip() == 0 ) {\n"
           "\t\tweapon.WEAPON_RELOAD = true;\n"
           "\t}\n"
           "\n"
           "\tif ( !getEnemy() ) {\n"
           "\t\tif ( weapon.ammoInClip() <= 20 ) { // TinMan:*todo* demagic\n"
           "\t\t\tweapon.WEAPON_RELOAD = true;\n"
           "\t\t}\n"
           "\t}\n"
           "\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::checkStrafeLeft\n"
           "TinMan: Crude as hell, but will do for now\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot_a8::checkStrafeLeft() {\n"
           "\tvector\tpos, ang, dir, tracePosition;\n"
           "\tfloat maxRange, frac, traceDistance;\n"
           "\t//entity\ttraceEntity;\n"
           "\n"
           "\tmaxRange = SABOT_CHECK_MOVE_DISTANCE; // TinMan: Max a bounds trace can do is 4096.\n"
           "\n"
           "\tpos = getViewPosition();\n"
           "\tang = body.getViewAngles();\n"
           "\n"
           "\tang_x = 0;\n"
           "\tang_z = 0;\n"
           "\tang_y += 90;\n"
           "\tdir = sys.angToForward( ang ); // TinMan: Convert angles (pitch yaw roll), to forward vector (x y z).\n"
           "\n"
           "\tfrac = sys.tracePoint( pos, pos + ( dir * maxRange ), CONTENTS_OPAQUE | MASK_SHOT_RENDERMODEL, self );\n"
           "\n"
           "\t/*\n"
           "\ttraceDistance = frac * maxRange; // TinMan: Convert the fraction of trace completed to game units\n"
           "\ttracePosition = sys.getTraceEndPos(); // TinMan: Get where trace hit\n"
           "\n"
           "\tfloat debugTime = 0.01;\n"
           "\tsys.debugLine( '0 1 1', pos, pos + ( dir * maxRange ), debugTime ); // TinMan: *debug* full trace\n"
           "\tsys.debugBounds( '1 0 0', pos + '-1 -1 -1', pos + '1 1 1' , debugTime ); // TinMan: *debug* show bound at eyes\n"
           "\n"
           "\tsys.debugLine( '0 1 0', pos, tracePosition,\tdebugTime ); // TinMan: *debug* trace\n"
           "\tsys.debugBounds( '1 1 0', tracePosition + '-2 -2 -2', tracePosition + '2 2 2' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\t*/\n"
           "\n"
           "\tif ( frac == 1 ) {\n"
           "\t\treturn true;\n"
           "\t} else {\n"
           "\t\treturn false;\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::checkStrafeRight\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot_a8::checkStrafeRight() {\n"
           "\tvector\tpos, ang, dir, tracePosition;\n"
           "\tfloat maxRange, frac, traceDistance;\n"
           "\t//entity\ttraceEntity;\n"
           "\n"
           "\tmaxRange = SABOT_CHECK_MOVE_DISTANCE; // TinMan: Max a bounds trace can do is 4096.\n"
           "\n"
           "\tpos = getViewPosition();\n"
           "\tang = body.getViewAngles();\n"
           "\n"
           "\tang_x = 0;\n"
           "\tang_z = 0;\n"
           "\tang_y -= 90;\n"
           "\tdir = sys.angToForward( ang ); // TinMan: Convert angles (pitch yaw roll), to forward vector (x y z).\n"
           "\n"
           "\tfrac = sys.tracePoint( pos, pos + ( dir * maxRange ), CONTENTS_OPAQUE | MASK_SHOT_RENDERMODEL, self );\n"
           "\n"
           "\t/*\n"
           "\ttraceDistance = frac * maxRange; // TinMan: Convert the fraction of trace completed to game units\n"
           "\ttracePosition = sys.getTraceEndPos(); // TinMan: Get where trace hit\n"
           "\n"
           "\tfloat debugTime = 0.01;\n"
           "\tsys.debugLine( '0 1 1', pos, pos + ( dir * maxRange ), debugTime ); // TinMan: *debug* full trace\n"
           "\tsys.debugBounds( '1 0 0', pos + '-1 -1 -1', pos + '1 1 1' , debugTime ); // TinMan: *debug* show bound at eyes\n"
           "\n"
           "\tsys.debugLine( '0 1 0', pos, tracePosition,\tdebugTime ); // TinMan: *debug* trace\n"
           "\tsys.debugBounds( '1 1 0', tracePosition + '-2 -2 -2', tracePosition + '2 2 2' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\t*/\n"
           "\n"
           "\tif ( frac == 1 ) {\n"
           "\t\treturn true;\n"
           "\t} else {\n"
           "\t\treturn false;\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::checkMoveForward\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot_a8::checkMoveForward() {\n"
           "\tvector\tpos, ang, dir, tracePosition;\n"
           "\tfloat maxRange, frac, traceDistance;\n"
           "\tentity\ttraceEntity;\n"
           "\n"
           "\tmaxRange = SABOT_CHECK_MOVE_DISTANCE; // TinMan: Max a bounds trace can do is 4096.\n"
           "\n"
           "\t//pos = getViewPosition();\n"
           "\tpos = body.getOrigin();\n"
           "\tang = body.getViewAngles();\n"
           "\n"
           "\tang_x = 0;\n"
           "\tang_z = 0;\n"
           "\tdir = sys.angToForward( ang ); // TinMan: Convert angles (pitch yaw roll), to forward vector (x y z).\n"
           "\n"
           "\tfrac = sys.tracePoint( pos, pos + ( dir * maxRange ), CONTENTS_OPAQUE | MASK_SHOT_RENDERMODEL, self );\n"
           "\n"
           "\ttraceDistance = frac * maxRange; // TinMan: Convert the fraction of trace completed to game units\n"
           "\ttracePosition = sys.getTraceEndPos(); // TinMan: Get where trace hit\n"
           "\n"
           "\t/*\n"
           "\tfloat debugTime = 0.01;\n"
           "\tsys.debugLine( '0 1 1', pos, pos + ( dir * maxRange ), debugTime ); // TinMan: *debug* full trace\n"
           "\tsys.debugBounds( '1 0 0', pos + '-1 -1 -1', pos + '1 1 1' , debugTime ); // TinMan: *debug* show bound at eyes\n"
           "\t*/\n"
           "\n"
           "\t/*\n"
           "\tsys.debugLine( '0 1 0', pos, tracePosition,\tdebugTime ); // TinMan: *debug* trace\n"
           "\tsys.debugBounds( '1 1 0', tracePosition + '-2 -2 -2', tracePosition + '2 2 2' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\t*/\n"
           "\n"
           "\tif ( frac == 1 ) {\n"
           "\t\treturn true;\n"
           "\t} else {\n"
           "\t\treturn false;\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::checkMoveBack\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot_a8::checkMoveBack() {\n"
           "\tvector\tpos, ang, dir, tracePosition;\n"
           "\tfloat maxRange, frac, traceDistance;\n"
           "\t//entity\ttraceEntity;\n"
           "\n"
           "\tmaxRange = SABOT_CHECK_MOVE_DISTANCE; // TinMan: Max a bounds trace can do is 4096.\n"
           "\n"
           "\tpos = getViewPosition();\n"
           "\tang = body.getViewAngles();\n"
           "\n"
           "\tang_x = 0;\n"
           "\tang_z = 0;\n"
           "\tang_y += 180;\n"
           "\tdir = sys.angToForward( ang ); // TinMan: Convert angles (pitch yaw roll), to forward vector (x y z).\n"
           "\n"
           "\tfrac = sys.tracePoint( pos, pos + ( dir * maxRange ), CONTENTS_OPAQUE | MASK_SHOT_RENDERMODEL, self );\n"
           "\n"
           "\t/*\n"
           "\ttraceDistance = frac * maxRange; // TinMan: Convert the fraction of trace completed to game units\n"
           "\ttracePosition = sys.getTraceEndPos(); // TinMan: Get where trace hit\n"
           "\n"
           "\tfloat debugTime = 0.01;\n"
           "\tsys.debugLine( '0 1 1', pos, pos + ( dir * maxRange ), debugTime ); // TinMan: *debug* full trace\n"
           "\tsys.debugBounds( '1 0 0', pos + '-1 -1 -1', pos + '1 1 1' , debugTime ); // TinMan: *debug* show bound at eyes\n"
           "\n"
           "\tsys.debugLine( '0 1 0', pos, tracePosition,\tdebugTime ); // TinMan: *debug* trace\n"
           "\tsys.debugBounds( '1 1 0', tracePosition + '-2 -2 -2', tracePosition + '2 2 2' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\t*/\n"
           "\n"
           "\tif ( frac == 1 ) {\n"
           "\t\treturn true;\n"
           "\t} else {\n"
           "\t\treturn false;\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::checkMoves\n"
           "TinMan: Do simple trace check in each direction and return results as flags. *todo* can't seem to do a propper negative test, doesn't matter anyway these functions are just hacks untill I delve a bit deeper into pathing.\n"
           "=====================\n"
           "*/\n"
           "float bot_sabot_a8::checkMoves() {\n"
           "\tvector\tpos, ang, dir, tracePosition;\n"
           "\tfloat maxRange, frac, traceDistance;\n"
           "\tfloat i, moveFlags;\n"
           "\t//entity\ttraceEntity;\n"
           "\n"
           "\tmoveFlags = 0;\n"
           "\n"
           "\tmaxRange = SABOT_CHECK_MOVE_DISTANCE; // TinMan: Max a bounds trace can do is 4096.\n"
           "\n"
           "\tpos = getViewPosition();\n"
           "\tang = body.getViewAngles();\n"
           "\n"
           "\tang_x = 0;\n"
           "\tang_z = 0;\n"
           "\n"
           "\t//float debugTime = 0.01;\n"
           "\t//sys.debugBounds( '1 0 0', pos + '-1 -1 -1', pos + '1 1 1' , debugTime ); // TinMan: *debug* show bound at eyes\n"
           "\n"
           "\t// TinMan: Test fwd,right,back,left.\n"
           "\tfor( i = 1; i < 10; i = i * 2 ) {\n"
           "\t\tdir = sys.angToForward( ang ); // TinMan: Convert angles (pitch yaw roll), to forward vector (x y z).\n"
           "\n"
           "\t\tfrac = sys.tracePoint( pos, pos + ( dir * maxRange ), CONTENTS_OPAQUE | MASK_SHOT_RENDERMODEL, self );\n"
           "\n"
           "\t\ttraceDistance = frac * maxRange; // TinMan: Convert the fraction of trace completed to game units\n"
           "\t\ttracePosition = sys.getTraceEndPos(); // TinMan: Get where trace hit\n"
           "\n"
           "\t\t/*\n"
           "\t\tsys.debugLine( '0 1 1', pos, pos + ( dir * maxRange ), debugTime ); // TinMan: *debug* full trace\n"
           "\n"
           "\t\tsys.debugLine( '0 1 0', pos, tracePosition,\tdebugTime ); // TinMan: *debug* trace\n"
           "\t\tsys.debugBounds( '1 1 0', tracePosition + '-2 -2 -2', tracePosition + '2 2 2' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\t\t*/\n"
           "\n"
           "\t\tif ( frac == 1 ) {\n"
           "\t\t\tmoveFlags |= i;\n"
           "\t\t}\n"
           "\n"
           "\t\tang_y += 90;\n"
           "\t}\n"
           "\n"
           "\treturn moveFlags;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_vladimir::checkBlocked\n"
           "TinMan: Deals with being blocked while moving to destination. \n"
           "*todo* save obstacle pos and check if it's moved, if it hasn't return true so we can choose new path\n"
           "*todo* this is currenly the only func that traps in a loop, rethink if you want this.\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot_a8::checkBlocked() {\n"
           "\t//sys.println( \"[\" + sys.getTime() + \"][checkBlocked()]\" ); // TinMan: *debug*\n"
           "\tentity obstacle;\n"
           "\tvector obstacle_pos;\n"
           "\tvector delta;\n"
           "\tfloat dist;\n"
           "\tfloat endTime;\n"
           "\tvector movePosition;\n"
           "\tvector aimDir;\n"
           "\t\n"
           "\tfloat numListedEnemies;\n"
           "\tentity enemy;\n"
           "\t\n"
           "\t/*if ( moveStatus() > MOVE_STATUS_DONE ) {\n"
           "\t\tsys.println( \"[\" + sys.getTime() + \"][checkBlocked()][Movestatus:\" + moveStatus() + \"]\" ); // TinMan: *debug*\n"
           "\t}\t*/\n"
           "\t\n"
           "\t// TinMan: *cheaphack* see if we're not moving by comparing against previous. !! Interferes with new routing (stopping for elev etc)\n"
           "\tif ( moveStatus() == MOVE_STATUS_MOVING ) {\n"
           "\t\t//sys.println( \"[\" + sys.getTime() + \"][checkBlocked()][Movestatus:\" + moveStatus() + \"]\" ); // TinMan: *debug*\n"
           "\t\tvector currentPosition;\n"
           "\t\t\n"
           "\t\tcurrentPosition = body.getOrigin();\n"
           "\t\t\n"
           "\t\tif ( lastPositionTime < sys.getTime() ) {\n"
           "\t\t\tlastPositionTime = sys.getTime() + 0.3;\n"
           "\t\t\t// TinMan: Compare current position with previous to get movement vector.\n"
           "\t\t\tdelta = currentPosition  - lastPosition;\n"
           "\t\t\tdelta_z = 0;\n"
           "\t\t\tdist = sys.vecLength( delta );\n"
           "\t\t\t\n"
           "\t\t\tlastPosition = currentPosition;\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: Haven't moved enough?\n"
           "\t\t\tif ( dist <= 2 ) {\n"
           "\t\t\t\t//sys.println( \"[\" + sys.getTime() + \"][checkBlocked][blocked by something]\" ); // TinMan: *debug*\n"
           "\t\t\t\tsaveMove();\n"
           "\t\t\t\tsetMoveWander();\n"
           "\t\t\t\tendTime = RandomDelay( 0.6, 0.7 );\n"
           "\t\t\t\twhile( sys.getTime() < endTime || dist > 16 ) {\n"
           "\t\t\t\t\tdelta = currentPosition  - lastPosition;\n"
           "\t\t\t\t\tdelta_z = 0;\n"
           "\t\t\t\t\tdist = sys.vecLength( delta ); // TinMan: set dist wandered\t\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t\t// TinMan: Do actual movement\n"
           "\t\t\t\t\tmovePosition = moveAction();\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t\t// TinMan: Lookee where we damn be going.\n"
           "\t\t\t\t\t//movePosition_z = movePosition_z + viewHeight;\n"
           "\t\t\t\t\t//setAimPosition( movePosition );\n"
           "\t\t\t\t\t\n"
           "\t\t\t\t\t// TinMan: Check for enemies\n"
           "\t\t\t\t\tif ( findEnemies( true ) ) {\n"
           "\t\t\t\t\t\tbreak;\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t\tenemy = heardSound( false );\n"
           "\t\t\t\t\tif ( canSeeEntity( enemy, false ) ) {\n"
           "\t\t\t\t\t\tbreak;\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t\twaitFrame();\n"
           "\t\t\t\t}\n"
           "\t\t\t\trestoreMove();\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t}\n"
           "\t\n"
           "\t/*\n"
           "\t// TinMan: *todo* Hmm doesn't seem to really trigger much at all\n"
           "\tif ( AI_BLOCKED ) {\n"
           "\t\tsys.println( \"[\" + sys.getTime() + \"][checkBlocked()][AI_BLOCKED]\" ); // TinMan: *debug*\n"
           "\t\tsaveMove();\n"
           "\t\tsetMoveWander();\n"
           "\t\tendTime = sys.getTime() + 0.8;\n"
           "\t\twhile( sys.getTime() < endTime ) {\n"
           "\t\t\t// TinMan: Lookee where we damn be going.\n"
           "\t\t\tmovePosition = getMovePosition(); // TinMan: expensive\n"
           "\t\t\tmovePosition_z = movePosition_z + viewHeight;\n"
           "\t\t\tsetAimPosition( movePosition );\n"
           "\t\t\t\t\t\n"
           "\t\t\t// TinMan: Do actual movement\n"
           "\t\t\tmoveForward();\n"
           "\t\t\t\t\n"
           "\t\t\t// TinMan: Check for enemies\n"
           "\t\t\tif ( findEnemies( true ) ) {\n"
           "\t\t\t\tbreak;\n"
           "\t\t\t}\n"
           "\t\t\tenemy = heardSound( false );\n"
           "\t\t\tif ( canSeeEntity( enemy, false ) ) {\n"
           "\t\t\t\tbreak;\n"
           "\t\t\t}\n"
           "\t\t\twaitFrame();\n"
           "\t\t}\n"
           "\t\trestoreMove();\n"
           "\t} else*/ if ( moveStatus() == MOVE_STATUS_BLOCKED_BY_MONSTER ) {\n"
           "\t\t//sys.println( \"[\" + sys.getTime() + \"][checkblocked][blocked by monster]\" ); // TinMan: *debug*\n"
           "\t\tobstacle = getObstacle();\n"
           "\t\tobstacle_pos = obstacle.getOrigin(); // TinMan: This wil come in handy later.\n"
           "\t\n"
           "\t\tsaveMove();\n"
           "\t\tsetMoveWander();\n"
           "\t\tendTime = sys.getTime() + 0.8;\n"
           "\t\twhile( sys.getTime() < endTime ) {\n"
           "\t\t\t// TinMan: Do actual movement\n"
           "\t\t\tmovePosition = moveAction();\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: Lookee where we damn be going.\n"
           "\t\t\t//movePosition = getMovePosition(); // TinMan: expensive\n"
           "\t\t\tif ( AI_ONGROUND && movePosition != body.getOrigin() ) {\n"
           "\t\t\t\taimDir = movePosition - body.getOrigin();\n"
           "\t\t\t\tsetAimDirection( aimDir );\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: Compare current position with previous to get movement vector.\n"
           "\t\t\tdelta = obstacle_pos - obstacle.getOrigin();\n"
           "\t\t\tdelta_z = 0;\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: Check for enemies\n"
           "\t\t\tif ( findEnemies( true ) ) {\n"
           "\t\t\t\tbreak;\n"
           "\t\t\t}\n"
           "\t\t\tenemy = heardSound( false );\n"
           "\t\t\tif ( canSeeEntity( enemy, false ) ) {\n"
           "\t\t\t\tbreak;\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: Yay it moved enough.\n"
           "\t\t\tif ( sys.vecLength( delta ) >= 4 ) {\n"
           "\t\t\t\t//sys.println( \"[\" + sys.getTime() + \"][\" + me + \"][checkBlocked][obstacle moved]\" ); // TinMan: *debug*\n"
           "\t\t\t\tbreak;\n"
           "\t\t\t}\n"
           "\t\t\twaitFrame();\n"
           "\t\t}\n"
           "\t\trestoreMove();\n"
           "\t}\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::checkShot\n"
           "TinMan: Find what we would hit if we fired. Bounds shot from eyes along viewangles. Itchy itch trigger finger.\n"
           "When bounds are used to decide whether to fire gives nice simulation of player pulling trigger when enemy near crosshair.\n"
           "*todo* axis align bounding box if possible.\n"
           "*todo* false if trace dist < min weapon range? checkaimedshot would intefere. also would have to make sure bot weaponswitches to something that can.\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot_a8::checkShot( boolean simple ) {\n"
           "\tvector\tpos, ang, dir, tracePosition;\n"
           "\tfloat maxRange, frac, traceDistance;\n"
           "\tentity\ttraceEntity;\n"
           "\tfloat gameType;\n"
           "\tfloat boundSize, halfBound;\n"
           "\tvector boundMins, boundMaxs;\n"
           "\n"
           "\tmaxRange = 2048; // TinMan: Max a bounds trace can do is 4096.\n"
           "\t\n"
           "\t/*\n"
           "\tboundSize = 8;\n"
           "\thalfBound = boundSize / 2;\n"
           "\t\n"
           "\tboundMins_x = -halfBound;\n"
           "\tboundMins_y = -halfBound;\n"
           "\tboundMins_z = -halfBound;\n"
           "\tboundMaxs_x = halfBound;\n"
           "\tboundMaxs_y = halfBound;\n"
           "\tboundMaxs_z = halfBound;\n"
           "\t*/\n"
           "\t\n"
           "\t\n"
           "\n"
           "\tpos = getViewPosition();\n"
           "\tang = body.getViewAngles();\n"
           "\tdir = sys.angToForward( ang ); // TinMan: Convert angles (pitch yaw roll), to forward vector (x y z).\n"
           "\n"
           "\tif ( simple ) {\n"
           "\t\tfrac = sys.tracePoint( pos, pos + ( dir * maxRange ), MASK_SOLID|CONTENTS_BODY, self );  //  CONTENTS_OPAQUE | MASK_SHOT_RENDERMODEL\n"
           "\t} else { // TinMan: Bounds trace\n"
           "\t\tfrac = sys.trace( pos, pos + ( dir * maxRange ), '-4 -4 -4', '4 4 4', MASK_SOLID|CONTENTS_BODY, self );\n"
           "\t}\n"
           "\ttraceEntity = sys.getTraceEntity(); // TinMan: Get what was hit by trace\n"
           "\n"
           "\ttraceDistance = frac * maxRange; // TinMan: Convert the fraction of trace completed to game units\n"
           "\t// TinMan: Hmm, do straight maths, or call function ( which returns value allready calculated when trace func was called. )\n"
           "\t//tracePosition = pos + ( dir * traceDistance ); // TinMan: Get where trace hit\n"
           "\ttracePosition = sys.getTraceEndPos(); // TinMan: Get where trace hit\n"
           "/*\n"
           "\tfloat debugTime = 0.01;\n"
           "\t//sys.debugLine( '0 1 1', pos, pos + ( dir * maxRange ), debugTime ); // TinMan: *debug* full trace\n"
           "\tsys.debugBounds( '1 0 0', pos + '-1 -1 -1', pos + '1 1 1' , debugTime ); // TinMan: *debug* show bound at eyes\n"
           "\n"
           "\tsys.debugLine( '0 1 0', pos, tracePosition,\tdebugTime ); // TinMan: *debug* trace\n"
           "\n"
           "\tsys.debugBounds( '1 1 0', tracePosition + '-4 -4 -4', tracePosition + '4 4 4' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\t//sys.debugBounds( '0 0.5 1', traceEntity.getOrigin() + traceEntity.getMins(), traceEntity.getOrigin() + traceEntity.getMaxs(), debugTime ); // TinMan: *debug* hilite hit ent\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][Trace Hit: \" + traceEntity.getName() + \"]\" ); // TinMan: *debug*\n"
           "\n"
           "\tsys.debugBounds( '1 0 1', getAimPosition() + '-4 -4 -4', getAimPosition() + '4 4 4', debugTime ); // TinMan: *debug* show bound at aimPos\n"
           "\t//sys.debugBounds( '1 1 0', body.getOrigin() + getMins() + '-2 -2 -2', body.getOrigin() + getMaxs() + '2 2 2' , debugTime ); // TinMan: *debug* aimPos reset\n"
           "\n"
           "\t//sys.debugLine( '0 1 0', body.getOrigin(), body.getOrigin() + getLinearVelocity(),\tdebugTime ); // TinMan: *debug* trace velocity\n"
           "*/\n"
           "\n"
           "\t// TinMan: Oh my god I think we hit something. Charles, I think we hit something!\n"
           "\tif ( traceEntity ) {\n"
           "\t\tstring type = getClassType( traceEntity );\n"
           "\t\tif ( type == \"idPlayer\" || type == \"idAI\" ) {\n"
           "\t\t\t// TinMan: Friendly fire check. I swear his orange hunting jacket look just like a prize buck officer! *todo* IsGametypeTeamBased?\n"
           "\t\t\tgameType = getGameType();\n"
           "\t\t\tif ( gameType == GAME_SP || gameType == GAME_TDM || gameType == GAME_CTF ) {\n"
           "\t\t\t\tif ( getTeam( traceEntity ) != getTeam( body ) ) {\n"
           "\t\t\t\t\treturn true;\n"
           "\t\t\t\t}\n"
           "\t\t\t} else {\n"
           "\t\t\t\treturn true;\n"
           "\t\t\t}\n"
           "\t\t} else if ( traceDistance < 64 && type == \"idBrittleFracture\"  ) { // TinMan: Breakable glass *todo* this will hurt if the bot got rockets.\n"
           "\t\t\treturn true;\n"
           "\t\t} /* else if ( traceDistance > 128 && type == \"idExplodingBarrel\"  ) { // TinMan: *todo* a wider cansee check for barrels to shoot when enemy is near.\n"
           "\t\t\treturn true;\n"
           "\t\t} */\n"
           "\t}\n"
           "\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::checkAimedShot\n"
           "TinMan: See if bot is aimed at given position and if a shot would make it.\n"
           "=====================\n"
           "*/\n"
           "boolean bot_sabot_a8::checkAimedShot( vector aimDir, float range ) {\n"
           "\tvector viewDir, aimDir, tracePosition, eyePosition;\n"
           "\tfloat ang;\n"
           "\tfloat frac, maxRange;\n"
           "\n"
           "\tmaxRange = 2048; // TinMan: Max a bounds trace can do is 4096.\n"
           "\n"
           "\teyePosition = getViewPosition();\n"
           "\tviewDir = sys.angToForward( body.getViewAngles() );\t// TinMan: Vector of where bot is looking\n"
           "\t//aimDir = aimPosition - eyePosition;\t\t\t// TinMan: Vector of where aimPosition is\n"
           "\n"
           "\tang = sys.DotProduct( sys.vecNormalize( viewDir ), sys.vecNormalize( aimDir ) );\n"
           "\tang = acos( ang ); // TinMan: Angle between viewDir and aimDir\n"
           "\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][state_Combat][viewDir<>aimDir Ang:\" + ang + \"]\" ); // TinMan: *debug*\n"
           "\tif ( ang < 0.1 ) { // TinMan: Minimal angle between the two so must be looking at aimed spot. Frankenstein says: I like nice mice.\n"
           "\n"
           "\t\t// TinMan: Figure out if bots shot will make it to aimPosition\n"
           "\t\tfrac = sys.tracePoint( eyePosition, eyePosition + aimDir * maxRange, MASK_SOLID|CONTENTS_BODY, self );  //  CONTENTS_OPAQUE | MASK_SHOT_RENDERMODEL\n"
           "\n"
           "\t\t//traceDistance = frac * maxRange; // TinMan: Convert the fraction of trace completed to game units\n"
           "\t\ttracePosition = sys.getTraceEndPos(); // TinMan: Get where trace hit\n"
           "\n"
           "\t\t/*\n"
           "\t\tfloat debugTime = 0.01;\n"
           "\t\tsys.debugBounds( '1 0 0', pos + '-1 -1 -1', pos + '1 1 1' , debugTime ); // TinMan: *debug* show bound at eyes\n"
           "\n"
           "\t\tsys.debugLine( '0 1 0', pos, tracePosition,\tdebugTime ); // TinMan: *debug* trace\n"
           "\t\tsys.debugBounds( '1 1 0', tracePosition + '-2 -2 -2', tracePosition + '2 2 2' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\n"
           "\t\tsys.debugLine( '1 0 0', pos, pos + aimDir,\tdebugTime ); // TinMan: *debug* trace\n"
           "\t\tsys.debugBounds( '1 0 0', aimPosition + '-2 -2 -2', aimPosition + '2 2 2' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\t\t*/\n"
           "\n"
           "\t\t// TinMan: Something in the way of shot.\n"
           "\t\tif ( body.distanceToPoint( tracePosition ) + 32 < range ) { // TinMan: traceDistance should have buffer since it will be shorter than aimPosition due to the trace hitting the model, of course my buffer is rough and inaccurate.\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][checkAimedShot][aimPosition blocked][tracePosition: \" + distanceToPoint( tracePosition ) + \"][aimPosition: \" + distanceToPoint( aimPosition ) + \"]\" ); // TinMan: *debug*\n"
           "\t\t\treturn false;\n"
           "\t\t} else {\n"
           "\t\t\treturn true;\n"
           "\t\t}\n"
           "\t}\n"
           "\n"
           "\treturn false;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::chooseWeapon\n"
           "TinMan: Chose weapon based on range *todo* fix/rethink, and use.\n"
           "=====================\n"
           "*/\n"
           "void bot_sabot_a8::chooseWeapon( float range ) {\n"
           "\tfloat w;\n"
           "\tstring weap, bestWeapon;\n"
           "\tfloat maxWeapons, weaponPriority, bestPriority;\n"
           "\t\n"
           "\tvector weapRange;\n"
           "\t\n"
           "\tmaxWeapons = 32;\t\n"
           "\n"
           "\tfor ( w = 0; w < maxWeapons; w++ ) {\n"
           "\t\tweap = body.getKey( \"def_weapon\" + w );\n"
           "\t\tif ( !weap ) {\n"
           "\t\t\tbreak;\n"
           "\t\t}\n"
           "\n"
           "\t\t/*\n"
           "\t\tif ( sys.strLeft( weap, 17 ) == \"weapon_bloodstone\" ) { // TinMan: weapon causes trouble with ctf when !_d3xp\n"
           "\t\t\tcontinue;\n"
           "\t\t}\n"
           "\t\t*/\n"
           "\t\t\t\t\n"
           "\t\t//sys.println( \"[\" + sys.getTime() + \"][chooseWeapon][weapon[\" + w + \"]: \" + weap + \"]\" ); // TinMan: *debug*\n"
           "\t\tif ( hasWeapon( weap ) && hasAmmoForWeapon( weap ) ) { // TinMan: *todo* at least a clip?\n"
           "\t\t\t//sys.println( \"[\" + sys.getTime() + \"][chooseWeapon][hasWeapon: \" + weap + \"]\" ); // TinMan: *debug*\n"
           "\t\t\tweaponPriority = getFloatKey( \"priority_\" + weap ); // TinMan: Grab priority from def *todo* ismultiplayer _mp\n"
           "\t\t\t//sys.println( \"[\" + sys.getTime() + \"][chooseWeapon][weapon: \" + weap + \"][priority: \" + weaponPriority + \"]\" ); // TinMan: *debug*\t\t\t\n"
           "\t\t\t\n"
           "\t\t\tif ( weaponPriority > bestPriority ) {\n"
           "\t\t\t\tbestPriority = weaponPriority;\n"
           "\t\t\t\tbestWeapon = weap;\t\n"
           "\t\t\t\t//sys.println( \"[\" + sys.getTime() + \"][chooseWeapon][bestWeapon: \" + bestWeapon + \"]\" ); // TinMan: *debug*\t\t\t\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\t//weapRange = getVectorKey( \"range_\" + weap ); // TinMan: Grab ranges from def\n"
           "\t\t\t/*if ( range > weapRange_y && range < weapRange_z ) { // TinMan: Weapon out of min max ranges of current enemy dist.\n"
           "\t\t\t\tbreak; \n"
           "\t\t\t} else { // TinMan: weapon not good for range, chose next weapon\n"
           "\t\t\t\tcontinue;\n"
           "\t\t\t}*/\n"
           "\t\t}\t\n"
           "\t}\n"
           "\t\n"
           "\t//sys.println( \"[\" + sys.getTime() + \"][chooseWeapon][bestWeapon: \" + bestWeapon + \"]\" ); // TinMan: *debug*\n"
           "\t\n"
           "\tif ( bestWeapon != currentWeapon ) {\n"
           "\t\tbody.selectWeapon( bestWeapon );\n"
           "\t}\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::predictTargetPosition\n"
           "Frankenstein says: I got my eyes from the corpse of the mikeBot.\n"
           "TinMan: Lead target\n"
           "*todo* sort out loop, it's a mess\n"
           "=====================\n"
           "*/\n"
           "vector bot_sabot_a8::predictTargetPosition( vector targetPosition, vector myPosition, vector targetVelocity, float projectileSpeed ) {\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][predictTargetPosition]\" ); // TinMan *debug*\n"
           "\tfloat travelTime = 0.0; // time for projectile to reach target\n"
           "\tfloat timeEstimate; \t\t// estimated time for projectile arrival\n"
           "\tfloat predictError; \t\t// error in target location\n"
           "\tfloat loopCount;\n"
           "\tvector targetLocation = targetPosition; // = targetVelocity;\n"
           "\n"
           "\tfloat debugTime = 0.01;\n"
           "\n"
           "\tfloat predictLoopMaximum = 10;\n"
           "\tfloat predictErrorTollerance = 0.1;\n"
           "\n"
           "\tpredictError = 100;\n"
           "\t\n"
           "\t// TinMan: *todo* maybe a bug here, gettin div by zeros, I think this is the only place I'm doing division. That would mean projectileSpeed is 0. Sort it out.\n"
           "\tif ( projectileSpeed == 0 ) {\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][predictTargetPosition][!!projectileSpeed == 0]\" ); // TinMan *debug*\n"
           "\t\tprojectileSpeed = 1;\n"
           "\t}\n"
           "\n"
           "\tfor ( loopCount = 0; loopCount < predictLoopMaximum; loopCount++ ) {\n"
           "\t\ttargetLocation = travelTime * targetVelocity + targetLocation; // TinMan: This will shift each loop as traveTime is changed\n"
           "\t\t//sys.debugBounds( '1 0.5 0.5', targetLocation + '-2 -2 -2', targetLocation + '2 2 2' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][predictTargetPosition][\" + loopCount + \"]\" ); // TinMan *debug*\n"
           "\t\ttimeEstimate = sys.vecLength( myPosition - targetLocation ) / projectileSpeed; // TinMan: Estimate of how long it will take projectile to reach targetLocation\n"
           "\t\tpredictError = timeEstimate - travelTime;\n"
           "\t\ttravelTime = timeEstimate;\n"
           "\t\tif ( predictError < predictErrorTollerance ) {\n"
           "\t\t\tbreak;\n"
           "\t\t}\n"
           "\t}\n"
           "\n"
           "\t//sys.debugLine( '0 1 1', pos, pos + ( dir * maxRange ), debugTime ); // TinMan: *debug* full trace\n"
           "\t/* sys.debugLine( '1 0 0', myPosition, targetLocation,\tdebugTime ); // TinMan: *debug* trace from self to predicted position\n"
           "\tsys.debugLine( '0 1 0', targetPosition, targetPosition + targetVelocity,\tdebugTime ); // TinMan: *debug* trace from  target along predicted direction\n"
           "\tsys.debugLine( '1 0 1', myPosition, targetPosition,\tdebugTime );\n"
           "\tsys.debugBounds( '0.5 1 0.2', targetPosition + '-1 -1 -1', targetPosition + '1 1 1' , debugTime );\n"
           "\tsys.debugBounds( '1 0.5 0.5', targetLocation + '-2 -2 -2', targetLocation + '2 2 2' , debugTime );\n"
           "\t*/\n"
           "\n"
           "\treturn targetLocation;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::addAimVariation\n"
           "TinMan: Add variation to aiming so it's not so damn good. I call this the drunkeness factor.\n"
           "*todo* just a cheaphack needs rethinking.\n"
           "=====================\n"
           "*/\n"
           "vector bot_sabot_a8::addAimVariation( vector aimPosition ) {\n"
           "\tfloat t, attackAccuracy;\n"
           "\tvector aimDir, viewAng;\n"
           "\t\t\t\n"
           "\tattackAccuracy = getFloatKey( \"aim_accuracy\" );\n"
           "\t\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][addAimVariation][attackAccuracy: \" + attackAccuracy + \"]\" ); // TinMan *debug*\n"
           "\t\n"
           "\taimDir = aimPosition - getViewPosition();\t// TinMan: Vector towards aimPosition\n"
           "\t\n"
           "\tif ( attackAccuracy == 0 ) { // TinMan: No aim variation. uberbot.\n"
           "\t\treturn aimDir;\n"
           "\t}\n"
           "\n"
           "\tt = sys.getTime() * 50;\n"
           "\tviewAng = sys.VecToAngles( aimDir );\n"
           "\tviewAng_x += sys.sin( t * 5.1 ) * attackAccuracy;\n"
           "\tviewAng_y\t+= sys.sin( t * 6.7 ) * attackAccuracy;\n"
           "\n"
           "\tviewAng = sys.angToForward( viewAng );\n"
           "\t\n"
           "\t// TinMan: Convert angles back to position\n"
           "\t//viewAng = eyePosition + viewAng * sys.vecLength( aimDir );\n"
           "\n"
           "\t/*\n"
           "\t// TinMan: *debug*\n"
           "\tfloat maxRange = 2048; // TinMan: Max a bounds trace can do is 4096.\n"
           "\tvector viewDir = sys.angToForward( body.getViewAngles() ); // TinMan: Convert angles (pitch yaw roll), to forward vector (x y z).\n"
           "\n"
           "\tfloat frac = sys.tracePoint( eyePosition, eyePosition + viewDir * maxRange, MASK_SOLID|CONTENTS_BODY, self );  //  CONTENTS_OPAQUE | MASK_SHOT_RENDERMODEL\n"
           "\n"
           "\tvector tracePosition = sys.getTraceEndPos(); // TinMan: Get where trace hit\n"
           "\n"
           "\tfloat debugTime = 0.01;\n"
           "\tsys.debugBounds( '1 0 0',  eyePosition + '-1 -1 -1',  eyePosition + '1 1 1' , debugTime ); // TinMan: *debug* show bound at eyes\n"
           "\tsys.debugLine( '0 1 0',  eyePosition, tracePosition,\tdebugTime ); // TinMan: *debug* trace\n"
           "\tsys.debugBounds( '1 1 0', tracePosition + '-2 -2 -2', tracePosition + '2 2 2' , debugTime ); // TinMan: *debug* show bound where trace hit\n"
           "\n"
           "\tsys.debugBounds( '1 0 0', aimPosition + '-2 -2 -2', aimPosition + '2 2 2' , debugTime ); // TinMan: *debug*\n"
           "\t*/\n"
           "\t\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][addAimVariation][before: \" + aimDir + \"][after: \" + viewAng + \"]\" ); // TinMan *debug*\n"
           "\n"
           "\treturn viewAng;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::getAimTarget\n"
           "TinMan: Find out where to aim.\n"
           "getAIAimTargets automatically uses lastviablenemypos\n"
           "=====================\n"
           "*/\n"
           "vector bot_sabot_a8::getAimTarget( entity target ) {\n"
           "\tvector aimPosition;\n"
           "\tfloat predictType;\n"
           "\n"
           "\tpredictType = getIntKey( \"predict_\" + currentWeapon );\n"
           "\tif ( predictType == 1 ) { // TinMan: Explosive|shoot the feet - I said dance boy, dance!\n"
           "\t\tvector targetOrigin = target.getOrigin();\n"
           "\t\tvector origin = body.getOrigin();\n"
           "\t\tif ( targetOrigin_z <= origin_z && body.distanceTo( target ) > 96 ) { // TinMan: Only attack his shoes if he's lower\n"
           "\t\t//if ( canSeePosition( target.getOrigin(), false ) ) {\n"
           "\t\t\taimPosition = target.getOrigin();\n"
           "\t\t\taimPosition_z += 8; // TinMan: More chance of checkshot hitting enemy.\n"
           "\t\t} else {\n"
           "\t\t\taimPosition = getAIAimTargets( target, false ); // TinMan: false chest, true head. Excuse me, can you point to where you want to be shot?\n"
           "\t\t}\n"
           "\t} else { // TinMan: Default|0|chest\n"
           "\t\taimPosition = getAIAimTargets( target, false );\n"
           "\t}\n"
           "\n"
           "\treturn aimPosition;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::getItemPriority\n"
           "TinMan: Find out what the priority of this entity is.\n"
           "*todo* implement case switching for scripting from tutorial\n"
           "=====================\n"
           "*/\n"
           "float bot_sabot_a8::getItemPriority( entity item ) {\n"
           "\tfloat priority;\n"
           "\tstring itemName, prefix, classType;\n"
           "\tfloat\titemType;\n"
           "\tfloat len;\n"
           "\tfloat health, maxHealth, armor, maxArmor, ammo;\n"
           "\n"
           "\titemName = getClassName( item ); // TinMan: Get the name of the item\n"
           "\t// TinMan: Strip mp suffix\n"
           "\tlen = sys.strLength( itemName ) - 3;\n"
           "\tif ( sys.strSkip( itemName, len ) == \"_mp\" ) {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][getItemPriority][itemName: \" + sys.strLeft( itemName, len ) + \"]\" ); // TinMan *debug*\n"
           "\t\titemName = sys.strLeft( itemName, len );\n"
           "\t}\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][getItemPriority][itemName: \" + itemName + \"]\" ); // TinMan *debug*\n"
           "\t\n"
           "\tclassType = getClassType( item );\n"
           "\tif ( classType == \"idMoveableItem\" ) {\n"
           "\t\titemName = sys.strSkip( itemName, sys.strLength( \"moveable_item_\" ) ); // TinMan: Nasty\n"
           "\t\titemName = \"weapon_\" + itemName; // TinMan: Also cheap *todo* better, this obviously doesn't handle other movables, why did id soft name them moveable_item_machinegun etc instead of moveable_weapon_machinegun. Waaaaaaa!\n"
           "\t}\n"
           "\t\n"
           "\t// TinMan: Grab priority from def *todo* oldski *rem*\n"
           "\t/*\n"
           "\tpriority = getFloatKey( \"priority_\" + itemName ); \n"
           "\tif ( !priority ) {\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][getItemPriority][No Priority for: \" + itemName + \"]\" ); // TinMan *debug*\n"
           "\t\treturn 0;\n"
           "\t}\n"
           "\t*/\n"
           "\t\n"
           "\t// TinMan: Lets us diferentiate between items\n"
           "\tprefix = sys.strLeft( itemName, 4 );\n"
           "\tif ( prefix == \"ammo\" ) {\n"
           "\t\titemType = SABOT_ITEMTYPE_AMMO;\n"
           "\t} else if ( prefix == \"weap\" ) {\n"
           "\t\titemType = SABOT_ITEMTYPE_WEAPON;\n"
           "\t} else if ( prefix == \"item\" ) {\n"
           "\t\tprefix = sys.strLeft( itemName, 10 ); // TinMan: item_medkit, item_armor\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][getItemPriority][prefix: \" + prefix + \"]\" ); // TinMan *debug*\n"
           "\t\tif ( prefix == \"item_medki\" ) {\n"
           "\t\t\titemType = SABOT_ITEMTYPE_HEALTH;\n"
           "\t\t} else if ( prefix == \"item_armor\" ) {\n"
           "\t\t\titemType = SABOT_ITEMTYPE_ARMOR;\n"
           "\t\t} else {\n"
           "\t\t\titemType = SABOT_ITEMTYPE_ITEM;\n"
           "\t\t}\n"
           "\t} else if ( prefix == \"powe\" ) {\n"
           "\t\titemType = SABOT_ITEMTYPE_POWERUP;\n"
           "\t} else {\n"
           "\t\titemType = SABOT_ITEMTYPE_NONE;\n"
           "\t}\n"
           "\t\n"
           "\t/* TinMan: reference *todo* *rem*\n"
           "\t\t\"priority_goal_ammo\"\t\t\t\"10\"\n"
           "\t\"priority_goal_weapon\"\t\t\"20\"\n"
           "\t\"priority_goal_health\"\t\t\"35\"\n"
           "\t\"priority_goal_armor\"\t\t\t\"30\"\n"
           "\t\"priority_goal_powerup\" \t\"30\"\n"
           "\t\"priority_goal_enemy\"\t\t\t\"40\"\n"
           "\t\"priority_goal_team\"\t\t\t\"50\"\n"
           "\t*/\n"
           "\t\n"
           "\tif ( itemType == SABOT_ITEMTYPE_AMMO ) {\n"
           "\t\t//priority = getFloatKey( \"priority_goal_ammo\" ); // TinMan: Get base priority\n"
           "\t\tpriority = 10;\n"
           "\t\tpriority += getFloatKey( \"priority_\" + itemName ); // TinMan: Add specific priority\n"
           "\t\tlen = sys.strLength( itemName ) - 6; // TinMan: Strip off suffix ( _small, _large = 6 chars )\n"
           "\t\titemName = sys.strLeft( itemName, len );\n"
           "\t\tif ( itemName == \"ammo_grenade\" ) { // TinMan: pickups are ammo_grenade, while actuall ammo_type is ammo_grenades. Curses.\n"
           "\t\t\titemName = \"ammo_grenades\";\n"
           "\t\t}\n"
           "\t\tammo = hasAmmo( itemName );\n"
           "\t\tif ( ammo >= body.getFloatKey( \"max_\" + itemName ) ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][getItemPriority][bot has full: \" + itemName + \"]\" ); // TinMan *debug*\n"
           "\t\t\tpriority = 0;\n"
           "\t\t} else if ( !ammo ) {\n"
           "\t\t\tpriority += 5;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t/* TinMan: *todo*\n"
           "\t\tammo current 20, 25?\n"
           "\t\t\tand low ammo 40 (higher than default enemy\n"
           "\t\tbackpack + 10\n"
           "\t\t*/\n"
           "\t\t\n"
           "\t\t// TinMan: Priority [10,10(40todo)]+[1,2]\n"
           "\t} else if ( itemType == SABOT_ITEMTYPE_WEAPON ) {\n"
           "\t\t//priority = getFloatKey( \"priority_goal_weapon\" ); // TinMan: Get base priority\n"
           "\t\tpriority = 20;\n"
           "\t\tpriority += getFloatKey( \"priority_\" + itemName ); // TinMan: Add specific priority\n"
           "\t\tif ( !hasWeapon( itemName ) ) {\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][getItemPriority][bot doesn't have: \" + itemName + \"]\" ); // TinMan *debug*\n"
           "\t\t\tpriority += 5;\n"
           "\t\t}\n"
           "\t\tif ( itemName == currentWeapon ) { // TinMan: Same type as we're using\n"
           "\t\t\tpriority += 5;\n"
           "\t\t\t\n"
           "\t\t\t// TinMan: *todo* and very low ammo + 10\n"
           "\t\t} else if ( getFloatKey( \"priority_\" + itemName ) > getFloatKey( \"priority_\" + currentWeapon ) ) { // TinMan: It's a better weapon than current\n"
           "\t\t\tpriority += 5;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: *todo* it's a dropped weapon +5\n"
           "\t\t\n"
           "\t\t// TinMan: Priority [20,35(45todo)]+[1,10]\n"
           "\t} else if ( itemType == SABOT_ITEMTYPE_HEALTH ) {\n"
           "\t\t//priority = getFloatKey( \"priority_goal_health\" ); // TinMan: Get base priority\n"
           "\t\tpriority = 35;\n"
           "\t\tpriority += getFloatKey( \"priority_\" + itemName ); // TinMan: Add specific priority\t\n"
           "\t\t\n"
           "\t\thealth = getActorHealth( body );\n"
           "\t\tmaxHealth = body.getFloatKey( \"maxhealth\" );\n"
           "\t\t\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][getItemPriority][Health: \" + health + \"][Maxhealth: \" + maxHealth + \"]\" ); // TinMan *debug*\n"
           "\t\t\n"
           "\t\tif ( health < maxHealth ) {\n"
           "\t\t\tif ( health < 40 ) {\n"
           "\t\t\t\tpriority += 10;\n"
           "\t\t\t\t//priority = 45;\n"
           "\t\t\t}\n"
           "\t\t\tif ( health < 20 ) {\n"
           "\t\t\t\tpriority += 10;\n"
           "\t\t\t\t//priority = 55;\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tpriority = 0;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: Priority [35,55]+[1,2]\n"
           "\t} else if ( itemType == SABOT_ITEMTYPE_ARMOR ) {\n"
           "\t\t//priority = getFloatKey( \"priority_goal_armor\" ); // TinMan: Get base priority\n"
           "\t\tpriority = 30;\n"
           "\t\tpriority += getFloatKey( \"priority_\" + itemName ); // TinMan: Add specific priority\t\n"
           "\t\tarmor = getArmor( body );\n"
           "\t\tmaxArmor = body.getFloatKey( \"maxarmor\" );\n"
           "\t\t\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][getItemPriority][Armor: \" + armor + \"][Maxarmor: \" + maxArmor + \"]\" ); // TinMan *debug*\n"
           "\t\t\n"
           "\t\tif ( armor < maxArmor ) {\n"
           "\t\t\tif ( armor < 40 ) {\n"
           "\t\t\t\tpriority += 10;\n"
           "\t\t\t\t//priority = 40;\n"
           "\t\t\t}\n"
           "\t\t\tif ( armor < 20 ) {\n"
           "\t\t\t\tpriority += 10;\n"
           "\t\t\t\t//priority = 50;\n"
           "\t\t\t}\n"
           "\t\t} else {\n"
           "\t\t\tpriority = 0;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t} else if ( itemType == SABOT_ITEMTYPE_POWERUP ) {\n"
           "\t\t//priority = getFloatKey( \"priority_goal_powerup\" ); // TinMan: Get base priority\n"
           "\t\tpriority = 35;\n"
           "\t\tpriority += getFloatKey( \"priority_\" + itemName ); // TinMan: Add specific priority\t\n"
           "\t}\n"
           "\t\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][getItemPriority][\" + itemName + \" Priority: \" + priority + \"]\" ); // TinMan *debug*\n"
           "\t/* if ( priority ) {\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][getItemPriority][\" + itemName + \" Priority: \" + priority + \"]\" ); // TinMan *debug*\n"
           "\t} */\n"
           "\t\n"
           "\treturn priority;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::getPlayerPriority\n"
           "TinMan: How badass is this player?\n"
           "Remember: Unlike item where higher priority is better, here lower is better.\n"
           "*todo* weapon priority\n"
           "*todo* add powerups, + 200, 250, 300, uberbadness.\n"
           "*todo* + distance to enemy? ( shorter higher ) + last time seen enemy? ( shorter higher ), if so, don't put in here but where this func is called.\n"
           "=====================\n"
           "*/\n"
           "float bot_sabot_a8::getPlayerPriority( entity badass ) {\n"
           "\tfloat priority, weaponPriority;\n"
           "\tstring playerWeapon;\n"
           "\t\t\n"
           "\tplayerWeapon = badass.getCurrentWeapon();\n"
           "\tweaponPriority = getFloatKey( \"priority_\" + playerWeapon ); // TinMan: Grab priority from def\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][getPlayerPriority][weapon: \" + playerWeapon + \"][\" + weaponPriority + \"]\" ); // TinMan *debug*\n"
           "\n"
           "\tpriority = getFloatKey( \"priority_goal_enemy\" ); // TinMan: Get base priority\n"
           "\t//priority -= weaponPriority;\n"
           "\t\n"
           "\t//if ( getFloatKey( \"priority_\" + currentWeapon ) > weaponPriority ) {\n"
           "\t //priority += 5;\n"
           "\t//}\n"
           "\t//if ( getFloatKey( \"priority_\" + currentWeapon ) < weaponPriority ) {\n"
           "\t\t//priority -= 5;\n"
           "\t//}\n"
           "\t\n"
           "\tif ( gameType == GAME_CTF ) {\n"
           "\t\tif ( getFlagCarrier( 1 - team ) == badass ) {\n"
           "\t\t\tpriority += 20;\n"
           "\t\t}\n"
           "\t}\n"
           "\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][getPlayerPriority][\" + badass.getName() + \" Priority: \" + priority + \"]\" ); // TinMan *debug*\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][getPlayerPriority][\" + badass.getName() + \" HP: \" + getActorHealth( badass ) + \" ARM: \" + getArmor( badass ) + \" Weap: \" + weaponPriority + \" Priority: \" + priority + \"]\" ); // TinMan *debug*\n"
           "\treturn priority;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::getProjectileSpeed\n"
           "TinMan: How speedy are the shooty shooty kill kills?\n"
           "=====================\n"
           "*/\n"
           "float bot_sabot_a8::getProjectileSpeed( string weaponName ) {\n"
           "\tfloat projectileSpeed = 0;\n"
           "\n"
           "\tif ( sys.isMultiplayer() ) {\n"
           "\t\tprojectileSpeed = getIntKey( \"projectile_\" + weaponName +  \"_mp\" );\n"
           "\t}\n"
           "\tif ( !sys.isMultiplayer() || !projectileSpeed ) { // TinMan: If mp projspeed isn't defined fall back to regular projspeed\n"
           "\t\tprojectileSpeed = getIntKey( \"projectile_\" + weaponName );\n"
           "\t}\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][predictShot][\" + weaponName + \"][\" + projectileSpeed + \"]\" ); // TinMan *debug*\n"
           "\n"
           "\treturn projectileSpeed;\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::chooseGoal\n"
           "TinMan: \n"
           "Note: This function is somewhat expensive since nearly all entities found are reachability checked in getItemPriority.\n"
           "Note: Debug output is off by one.\n"
           "=====================\n"
           "*/\n"
           "entity bot_sabot_a8::chooseGoal( entity ignoreGoal ) {\n"
           "\tfloat i, numListedEntities;\n"
           "\tfloat itemPriority, bestPriority;\n"
           "\tfloat dist, bestDist;\n"
           "\tfloat radius;\n"
           "\tentity item, bestGoal;\n"
           "\t\n"
           "\tclearGoal();\n"
           "\t\n"
           "\t// TinMan: Command\n"
           "\tif ( BOT_COMMAND ) {\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][chooseGoal][have command]\" ); // TinMan *debug*\n"
           "\t\tBOT_COMMAND = false;\n"
           "\t\tif ( getCommandType() ) {\n"
           "\t\t\tgoalType = getCommandType();\n"
           "\t\t\tbestGoal = getCommandEntity();\n"
           "\t\t\tif ( !bestGoal ) {\n"
           "\t\t\t\tbestGoal = self;\n"
           "\t\t\t}\n"
           "\t\t\tgoalPriority = 200;\n"
           "\t\t\tmoveType = SABOT_GOALTYPE_POSITION;\n"
           "\t\t\tgoalPosition = getCommandPosition();\n"
           "\t\t\tif ( goalPosition == '0 0 0' ) {\n"
           "\t\t\t\tgoalPosition = bestGoal.getOrigin();\n"
           "\t\t\t}\n"
           "\t\t\tgoalPosition = pushPointIntoAAS( goalPosition );\n"
           "\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][chooseGoal][commandtype: \" + goalType + \"][commandEntity:\" + bestGoal.getName() + \"]\" ); // TinMan *debug*\n"
           "\t\t\tclearCommand();\n"
           "\t\t\treturn bestGoal; // TinMan: Done\n"
           "\t\t} else {\n"
           "\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][chooseGoal][no cmdtype]\" ); // TinMan *debug*\n"
           "\t\t}\n"
           "\t}\n"
           "\t\n"
           "\t// TinMan: *CTF* flag goals\t\n"
           "\tif ( gameType == GAME_CTF ) {\n"
           "\t\tif ( getFlagCarrier( team ) == body ) { // TinMan: w00t we gots teh falg!\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][chooseGoal][!have flag!]\" ); // TinMan *debug*\n"
           "\t\t\tbestGoal = ourCap;\n"
           "\t\t\t\n"
           "\t\t\tmoveType = SABOT_GOALTYPE_POSITION;\n"
           "\t\t\tgoalPosition = bestGoal.getOrigin();\n"
           "\t\t\tif ( body.distanceToPoint( goalPosition ) > 32 ) {\n"
           "\t\t\t\tgoalType = SABOT_GOAL_MOVE;\n"
           "\t\t\t} else { // TinMan: Close enough, camp it\n"
           "\t\t\t\tgoalType = SABOT_GOAL_HOLD;\n"
           "\t\t\t}\n"
           "\t\t\tgoalPriority = getFloatKey( \"priority_goal_team\" );\n"
           "\t\t} else if ( role == SABOT_ROLE_OFFENCE ) {\n"
           "\t\t\tbestGoal = theirCap;\n"
           "\t\t\tmoveType = SABOT_GOALTYPE_POSITION;\n"
           "\t\t\t\n"
           "\t\t\tif ( body.distanceToPoint( goalPosition ) > 128 ) {\n"
           "\t\t\t\tgoalType = SABOT_GOAL_MOVE;\n"
           "\t\t\t} else { // TinMan: Close enough, camp it\n"
           "\t\t\t\tif ( getFlagStatus( 1 - team ) == FLAGSTATUS_INBASE ) {\n"
           "\t\t\t\t\tgoal = theirFlag;\n"
           "\t\t\t\t\tmoveType = SABOT_GOALTYPE_ENTITY;\n"
           "\t\t\t\t\tgoalPriority = getFloatKey( \"priority_goal_team\" );\n"
           "\t\t\t\t} else {\n"
           "\t\t\t\t\tgoalType = SABOT_GOAL_HOLD;\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\tgoalPosition = bestGoal.getOrigin();\n"
           "\t\t\t//goalPriority = getFloatKey( \"priority_goal_team\" );\n"
           "\t\t\tgoalPriority = 20;\n"
           "\t\t} /*else if ( role == SABOT_ROLE_DEFENCE ) {\n"
           "\t\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][chooseGoal][defence][goal: ourFlag]\" ); // TinMan *debug*\n"
           "\t\t\t\tmoveType = SABOT_GOALTYPE_POSITION;\n"
           "\t\t\t\tgoalType = SABOT_GOAL_HOLD;\n"
           "\t\t\t\tbestGoal = ourCap;\n"
           "\t\t\t\tgoalPosition = bestGoal.getOrigin();\n"
           "\t\t\t\tgoalPriority = getFloatKey( \"priority_goal_team\" );\n"
           "\t\t}*/\n"
           "\t\t\t\n"
           "\t\t// TinMan: Check if goal can be reached *todo* think about how you are going to handle unreachable goal. *todo* hmm it's ok if enemy is unreachable, he might not be later, or your still might be able to shoot him\n"
           "\t\tif ( bestGoal ) {\n"
           "\t\t\tif ( moveType = SABOT_GOALTYPE_POSITION ) {\n"
           "\t\t\t\tif ( !canReachPosition( bestGoal.getOrigin() ) ) {\n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][chooseGoal][can't reach goal position]\" ); // TinMan *debug*\n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][chooseGoal][GoalPosition: \" + goalPosition + \"]\" ); // TinMan *debug*\n"
           "\t\t\t\t\t//clearGoal();\n"
           "\t\t\t\t\tbestGoal = $null_entity;\n"
           "\t\t\t\t}\n"
           "\t\t\t} else {\n"
           "\t\t\t\tif ( !canReachEntity( bestGoal ) ) {\n"
           "\t\t\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][chooseGoal][can't reach goal]\" ); // TinMan *debug*\n"
           "\t\t\t\t\tclearGoal();\n"
           "\t\t\t\t\tbestGoal = $null_entity;\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tif ( !bestGoal ) { // TinMan: Can't CTF so roam\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][chooseGoal][!!No CTF Goal!!]\" ); // TinMan *debug*\n"
           "\t\t\trole = roleDefault;\n"
           "\t\t}\n"
           "\t}\n"
           "\n"
           "\t// TinMan: Find an item to hunt. Want l00t!\n"
           "\tif ( role == SABOT_ROLE_ROAM ) {\n"
           "\t\tnumListedEntities = findItems();\n"
           "\t\t// sys.println( \"[\" + int( sys.getTime() ) + \"][chooseGoal][numListedEntities: \" + numListedEntities + \"]\" ); // TinMan *debug*\n"
           "\t\tfor ( i = 0; i < numListedEntities; i++ ) {\n"
           "\t\t\titem = getEntityList( i );\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][chooseGoal][listedEntity[\" + i + \"] : \" + item.getName() +  \"]\" ); // TinMan *debug* \" : \" + getClassName( item ) +\n"
           "\t\t\tif ( item == ignoreGoal || item.isHidden() ) { // TinMan: *todo* Shouldnt really do a ishidden but at the moment this is stopping ping pong and adding variation\n"
           "\t\t\t\tcontinue;\n"
           "\t\t\t}\n"
           "\t\t\titemPriority = getItemPriority( item );\n"
           "\t\t\tif ( !itemPriority ) {\n"
           "\t\t\t\tcontinue;\n"
           "\t\t\t}\n"
           "\t\t\tif ( itemPriority > bestPriority ) {\n"
           "\t\t\t\tif ( canReachEntity( item ) ) {\n"
           "\t\t\t\t\tbestPriority = itemPriority;\n"
           "\t\t\t\t\tbestGoal = item;\n"
           "\t\t\t\t}\n"
           "\t\t\t} else if ( itemPriority == bestPriority ) { // TinMan: If item has same priority get closest, of course staright distance check is cheap and may not be the closest item due to travel time.\n"
           "\t\t\t\tdist = body.distanceTo( item );\n"
           "\t\t\t\tbestDist = body.distanceTo( bestGoal );\n"
           "\t\t\t\tif ( dist < bestDist ) {\n"
           "\t\t\t\t\tif ( canReachEntity( item ) ) {\n"
           "\t\t\t\t\t\tbestGoal = item;\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\n"
           "\t\tgoalType = SABOT_GOAL_MOVE;\n"
           "\t\tgoalPriority = getFloatKey( \"priority_goal_item\" ); // TinMan: Pretty much anything will override this goal.\n"
           "\t\t\n"
           "\t\t/*\n"
           "\t\tif ( bestGoal ) {\n"
           "\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][chooseGoal][goal: \" + getClassName( bestGoal ) + \" of \" + numListedEntities + \"][priority: \" + goalPriority + \"]\" ); // TinMan *debug*\n"
           "\t\t}\n"
           "\t\t*/\n"
           "\t}\n"
           "\t\n"
           "\treturn bestGoal; // TinMan: This is the goodest loot\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::lookForGoal\n"
           "TinMan: Look for nice and shiny baubles to gather.\n"
           "*todo* split the seperate looks into funcs that just return best and do a priority compare?\n"
           "=====================\n"
           "*/\n"
           "entity bot_sabot_a8::lookForGoal( float useFov ) {\n"
           "\tfloat i, numListedEntities;\n"
           "\tfloat itemPriority, bestPriority;\n"
           "\tfloat dist, bestDist;\n"
           "\tfloat radius;\n"
           "\tfloat maxHeight, minHeight;\n"
           "\tentity item;\n"
           "\tvector origin, itemOrigin;\n"
           "\t\n"
           "\t// TinMan: items, dropped weapons, ctf flags\n"
           "\tentity bestGoal;\n"
           "\tentity bestItem, bestDrop, bestFlag;\n"
           "\tfloat priorityItem, priorityDrop, priorityFlag;\n"
           "\t\n"
           "\tclearNewGoal(); // TinMan: Wipe the slate, and your nose.\n"
           "\n"
           "\tradius = 300; // Todo: *demagic*\n"
           "\t\n"
           "\tbestDist = radius;\n"
           "\t\n"
           "\torigin = body.getOrigin();\n"
           "\t\n"
           "\tmaxHeight = 128;\n"
           "\tminHeight = 64;\n"
           "\t\n"
           "\tnumListedEntities = findInRadius( origin, radius, \"idItem\" );\n"
           "\t//sys.println( \"[\" + int( sys.getTime() ) + \"][lookForGoal][numListedEntities: \" + numListedEntities + \"]\" ); // TinMan *debug*\n"
           "\tfor ( i = 0; i < numListedEntities; i++ ) {\n"
           "\t\titem = getEntityList( i );\n"
           "\t\t\n"
           "\t\tif ( item == goal ) {\n"
           "\t\t\tcontinue;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\t// TinMan: *todo* rethink\n"
           "\t\tif ( item == oldGoal ) {\n"
           "\t\t\tcontinue;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\titemOrigin = item.getOrigin();\n"
           "\t\tif ( itemOrigin_z > origin_z + maxHeight || itemOrigin_z < origin_z - minHeight ) { // TinMan: tunnel vision *todo* rethink.\n"
           "\t\t\tcontinue;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\titemPriority = getItemPriority( item ); // TinMan: Sort out health and armour, stuff that he can't pick up when he's full, the glutton.\n"
           "\t\t\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][lookForGoal][listedEntity[\" + i + \"]:\" + item.getName() + \"][Prioriy: \" + itemPriority + \"]\" ); // TinMan *debug* \" \n"
           "\t\t// TinMan: Find closest l00t\n"
           "\t\tif ( itemPriority ) {\n"
           "\t\t\tdist = body.distanceTo( item );\n"
           "\t\t\t\n"
           "\t\t\t//if ( canSeePosition( item.getOrigin(), true ) && item.isHidden() ) { // TinMan: If we can see it's not there. *todo* is this working at all?\n"
           "\t\t\tif ( item.isHidden() ) {\n"
           "\t\t\t\tcontinue;\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\tif ( !AI_ENEMY_DEAD && !canSeeEntity( item, true ) ) { // TinMan: *cheaphack, only go for item you can see when fighting\n"
           "\t\t\t\tcontinue;\n"
           "\t\t\t}\n"
           "\n"
           "\t\t\t\n"
           "\t\t\tif ( dist < bestDist ) {\n"
           "\t\t\t\tif ( canReachEntity( item ) ) {\n"
           "\t\t\t\t\tbestDist = dist;\n"
           "\t\t\t\t\tbestItem = item;\n"
           "\t\t\t\t\tpriorityItem = itemPriority;\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t/* if ( bestItem ) {\n"
           "\t\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][\" + i + \": \" + getClassName( item ) +  \"][dist: \" + int( dist ) + \"][priority: \" + priorityItem +  \"]\" ); // TinMan *debug* \" \n"
           "\t\t} */\n"
           "\t}\n"
           "\t\n"
           "\t// TinMan: Update best goal for comparison later\n"
           "\tif ( bestItem ) {\n"
           "\t\tbestGoal = bestItem;\n"
           "\t\tbestPriority = priorityItem;\n"
           "\t}\n"
           "\t\n"
           "\tradius = 400;\n"
           "\t// TinMan: Check for dropped weapons\n"
           "\tnumListedEntities = findInRadius( origin, radius, \"idMoveableItem\" );\n"
           "\tfor ( i = 0; i < numListedEntities; i++ ) {\n"
           "\t\titem = getEntityList( i );\n"
           "\t\t// sys.println( \"[\" + int( sys.getTime() ) + \"][lookForGoal:Movable][listedEntity[\" + i + \"] : \" + item.getName() +  \"]\" ); // TinMan *debug* \"\n"
           "\t\t\n"
           "\t\tif ( item == goal ) {\n"
           "\t\t\tcontinue;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\tif ( item.isHidden() ) { // TinMan: *todo* is idMoveableItem ever hidden or just removed?\n"
           "\t\t\t\tcontinue;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\titemOrigin = item.getOrigin();\n"
           "\t\tif ( itemOrigin_z > origin_z + maxHeight || itemOrigin_z < origin_z - minHeight ) { // TinMan: tunnel vision *todo* rethink.\n"
           "\t\t\tcontinue;\n"
           "\t\t}\n"
           "\t\t\n"
           "\t\titemPriority = getItemPriority( item ); // TinMan: Sort out health and armour, stuff that he can't pick up when he's full, the glutton.\n"
           "\t\t\n"
           "\t\tif ( !itemPriority ) {\n"
           "\t\t\tcontinue;\n"
           "\t\t}\n"
           "\t\t// TinMan: Find closest l00t\n"
           "\t\tif ( canSeeEntity( item, useFov ) ) {\n"
           "\t\t\tdist = body.distanceTo( item );\n"
           "\t\t\tif ( dist < bestDist ) {\n"
           "\t\t\t\tif ( canReachEntity( item ) ) {\n"
           "\t\t\t\t\tbestDist = dist;\n"
           "\t\t\t\t\tbestDrop = item;\n"
           "\t\t\t\t\tpriorityDrop = itemPriority + 5; // TinMan: Dropped items higher priority *todo* This the right place? Or in getitemprio?\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][listedEntity[\" + i + \"] : \" + item.getName() +  \"][dist: \" + dist + \"]\" ); // TinMan *debug* \" : \" + getClassName( item ) +\n"
           "\t}\n"
           "\t\n"
           "\t// TinMan: Compare against bestgoal (^item)\n"
           "\tif ( priorityDrop > bestPriority ) {\n"
           "\t\tbestGoal = bestDrop;\n"
           "\t\tbestPriority = priorityDrop;\n"
           "\t}\n"
           "\n"
           "\tif ( gameType == GAME_CTF ) {\n"
           "\t\tradius = 600;\n"
           "\t\t// TinMan: Check for dropped flags\n"
           "\t\tnumListedEntities = findInRadius( origin, radius, \"idItemTeam\" );\n"
           "\t\n"
           "\t\tfor ( i = 0; i < numListedEntities; i++ ) {\n"
           "\t\t\titem = getEntityList( i );\n"
           "\t\t\t// sys.println( \"[\" + int( sys.getTime() ) + \"][lookForGoal:Movable][listedEntity[\" + i + \"] : \" + item.getName() +  \"]\" ); // TinMan *debug* \"\n"
           "\t\t\t\n"
           "\t\t\tif ( item == goal ) {\n"
           "\t\t\t\tcontinue;\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\tif ( item.isHidden() ) { // TinMan: *todo* is flag ever hidden?\n"
           "\t\t\t\tcontinue;\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\titemOrigin = item.getOrigin();\n"
           "\t\t\tif ( itemOrigin_z > origin_z + maxHeight || itemOrigin_z < origin_z - minHeight ) { // TinMan: tunnel vision *todo* rethink.\n"
           "\t\t\t\tcontinue;\n"
           "\t\t\t}\n"
           "\t\t\t\n"
           "\t\t\t//itemPriority = getItemPriority( item ); // TinMan: *todo*? do we?\n"
           "\t\t\t// TinMan: Check to see if the flag isn't just at base.\n"
           "\t\t\tif ( item == ourFlag ) {\n"
           "\t\t\t\tif ( getFlagStatus( team ) != FLAGSTATUS_STRAY ) { // TinMan: Our flag should only be a goal if it needs returning.\n"
           "\t\t\t\t\tcontinue;\n"
           "\t\t\t\t}\n"
           "\t\t\t} else if ( item == theirFlag ) {\n"
           "\t\t\t\tif ( getFlagStatus( 1 - team ) == FLAGSTATUS_TAKEN ) { // TinMan: Flag shouldn't be grabbed, cause someone's got it\n"
           "\t\t\t\t\tcontinue;\n"
           "\t\t\t\t}\n"
           "\t\t\t}\n"
           "\t\t\t\t\n"
           "\t\t\tif ( canSeeEntity( item, useFov ) ) {\n"
           "\t\t\t\tdist = body.distanceTo( item );\n"
           "\t\t\t\tif ( dist < bestDist ) {\n"
           "\t\t\t\t\tif ( canReachEntity( item ) ) {\n"
           "\t\t\t\t\t\tbestDist = dist;\n"
           "\t\t\t\t\t\tbestFlag = item;\n"
           "\t\t\t\t\t\tpriorityFlag = getFloatKey( \"priority_goal_team\" );\n"
           "\t\t\t\t\t}\n"
           "\t\t\t\t}\n"
           "\t\t\t}\t\n"
           "\t\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][\" + getName() + \"][listedEntity[\" + i + \"] : \" + item.getName() +  \"][dist: \" + dist + \"]\" ); // TinMan *debug* \" : \" + getClassName( item ) +\n"
           "\t\t}\n"
           "\t}\n"
           "\t\n"
           "\t/*\tif ( bestItem ) {\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][lookForGoal][bestItem: \" + bestItem.getName() + \" of [\" + numListedEntities + \"]]\" ); // TinMan *debug*\n"
           "\t} */\n"
           "\t\n"
           "\tif ( priorityFlag > bestPriority ) {\n"
           "\t\tbestGoal = bestFlag;\n"
           "\t\tbestPriority = priorityFlag;\n"
           "\t}\n"
           "\n"
           "\t// TinMan: This is the goodest loot\n"
           "\tif ( bestGoal ) {\n"
           "\t\tnewGoal = bestGoal;\n"
           "\t\tnewGoalPriority = bestPriority;\n"
           "\t\tnewGoalType = SABOT_GOAL_MOVE;\n"
           "\t\tnewMoveType = SABOT_GOALTYPE_ENTITY;\n"
           "\t}\n"
           "\n"
           "\treturn bestItem; // TinMan: This is the goodest loot\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::lookForEnemies\n"
           "TinMan: Searches for enemies. You must know where the hurty men are.\n"
           "=====================\n"
           "*/\n"
           "entity bot_sabot_a8::lookForEnemies( float useFov ) {\n"
           "\tfloat i, numListedEnemies;\n"
           "\tentity thisEnemy, bestEnemy;\n"
           "\tfloat dist, bestDist;\n"
           "\t\n"
           "\tbestDist = 999999;\n"
           "\t\n"
           "\tnumListedEnemies = findEnemies( useFov );\n"
           "\tfor ( i = 0; i < numListedEnemies; i++ ) {\n"
           "\t\tthisEnemy = getEntityList( i );\n"
           "\t\t\n"
           "\t\t//sys.println( \"[\" + int( sys.getTime() ) + \"][lookForEnemy][listedEnemy[\" + i + \"] : \" + thisEnemy.getName() +  \"]\" ); // TinMan: *debug*\n"
           "\t\tdist = body.distanceTo( thisEnemy );\n"
           "\t\tif ( dist < bestDist ) {\n"
           "\t\t\tif ( thisEnemy != getEnemy() ) {\n"
           "\t\t\t\tbestDist = dist;\n"
           "\t\t\t\tbestEnemy = thisEnemy;\n"
           "\t\t\t}\n"
           "\t\t}\n"
           "\t}\n"
           "\n"
           "\t/* if ( bestEnemy ) {\n"
           "\t\tsys.println( \"[\" + int( sys.getTime() ) + \"][lookForEnemy][bestEnemy: \" + bestEnemy.getName() + \" of [\" + i + \"]]\" ); // TinMan *debug*\n"
           "\t} */\n"
           "\n"
           "\treturn bestEnemy; // TinMan: He be the badest of the bad\n"
           "}\n"
           "\n"
           "/*\n"
           "=====================\n"
           "bot_sabot_a8::listenForEnemies\n"
           "TinMan: I think I hear something in the basement dear. heardSound is only really geared towards single player ai with one player causing a ruckus.\n"
           "=====================\n"
           "*/\n"
           "entity bot_sabot_a8::listenForEnemies() {\n"
           "\tentity newEnemy;\n"
           "\n"
           "\tnewEnemy = heardSound( false );\n"
           "\tif ( newEnemy == getEnemy() || !canSeeEntity( newEnemy, false ) ) { // TinMan: Visible but not in fov *todo* hmm\n"
           "\t\tnewEnemy = $null_entity;\n"
           "\t}\n"
           "\n"
           "\treturn newEnemy;\n"
           "}\n"
           "\n";
}

/***********************************************************************
Doom3Bots - Open bot framework for Doom 3
release ? - "Beware of TinMans horrifying code"

bot_scripts.script
List of bots scripts and script used by framework
***********************************************************************/
idStr botAi::GetBotMainScript(void)
{
    idStr source = GetBotDefScript() +
                   "#define MAX_WEAPONS \t\t\t\t\t\t32 // TinMan: sync with gamecode\n"
                   "\n"
                   "// TinMan: Path types, sync with game code\n"
                   "#define\tPATHTYPE_WALK\t\t\t\t\t\t0\n"
                   "#define\tPATHTYPE_WALKOFFLEDGE\t\t1\n"
                   "#define\tPATHTYPE_BARRIERJUMP\t\t2\n"
                   "#define\tPATHTYPE_JUMP\t\t\t\t\t\t3\n"
                   "#define\tPATHTYPE_ELEVATOR\t\t\t\t4\n"
                   "\n"
                   "// TinMan: Game types, sync with game code\n"
                   "#define\tGAME_SP \t\t\t0\n"
                   "#define\tGAME_DM \t\t\t1\n"
                   "#define\tGAME_TOURNEY\t2\n"
                   "#define\tGAME_TDM \t\t\t3\n"
                   "#define\tGAME_LASTMAN\t4\n"
                   "#define\tGAME_CTF\t\t\t5\n"
                   "#define\tGAME_COOP\t\t\t6\n"
                   "\n"
                   "// TinMan: *CTF* \n"
                   "#define\tFLAGSTATUS_INBASE 0\n"
                   "#define\tFLAGSTATUS_TAKEN  1\n"
                   "#define\tFLAGSTATUS_STRAY  2\n"
                   "#define\tFLAGSTATUS_NONE   3\n"
                   "\n"
                   "//#include \"script/bot_events.script\"\n"
                   "//#include \"script/bot_base.script\"\n"
                   "\n"
                   "//#include \"script/bot_sabot.script\" // TinMan: My precious\n"
                   "//#include \"script/bot_sabot_a8.script\" // TinMan: My precious\n";

    source.Append("\n");
    source.Append(GetBotEventsScript());
    source.Append("\n");
    source.Append(GetBotBaseScript());
    source.Append("\n");
    source.Append(GetBotSabotScript());
    source.Append("\n");
    source.Append(GetBotSabotA8Script());

    return source;
}

idStr botAi::GetBotDefScript(void)
{
    // from script/ai_base.script
    return "// move results\n"
           "#define MOVE_STATUS_DONE 0 // move succeeded, or not moving\n"
           "#define MOVE_STATUS_MOVING 1 // move in progress\n"
           "#define MOVE_STATUS_BLOCKED_BY_MONSTER 8\n"
           "\n"
            ;
}
